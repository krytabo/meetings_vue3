{"ast":null,"code":"import { warn } from '../utils';\nclass ZIndexManager {\n  constructor() {\n    this.elementZIndex = new Map();\n    this.nextZIndex = 2000;\n  }\n  get elementCount() {\n    return this.elementZIndex.size;\n  }\n  ensureZIndex(el, zIndex) {\n    const {\n      elementZIndex\n    } = this;\n    if (zIndex !== undefined) {\n      el.style.zIndex = `${zIndex}`;\n      elementZIndex.delete(el);\n      return;\n    }\n    const {\n      nextZIndex\n    } = this;\n    if (elementZIndex.has(el)) {\n      const currentZIndex = elementZIndex.get(el);\n      if (currentZIndex + 1 === this.nextZIndex) return;\n    }\n    el.style.zIndex = `${nextZIndex}`;\n    elementZIndex.set(el, nextZIndex);\n    this.nextZIndex = nextZIndex + 1;\n    this.squashState();\n  }\n  unregister(el, zIndex) {\n    const {\n      elementZIndex\n    } = this;\n    if (elementZIndex.has(el)) {\n      elementZIndex.delete(el);\n    } else if (zIndex === undefined) {\n      warn('z-index-manager/unregister-element', 'Element not found when unregistering.');\n    }\n    this.squashState();\n  }\n  squashState() {\n    const {\n      elementCount\n    } = this;\n    if (!elementCount) {\n      this.nextZIndex = 2000;\n    }\n    if (this.nextZIndex - elementCount > 2500) this.rearrange();\n  }\n  rearrange() {\n    const elementZIndexPair = Array.from(this.elementZIndex.entries());\n    elementZIndexPair.sort((pair1, pair2) => {\n      return pair1[1] - pair2[1];\n    });\n    this.nextZIndex = 2000;\n    elementZIndexPair.forEach(pair => {\n      const el = pair[0];\n      const zIndex = this.nextZIndex++;\n      if (`${zIndex}` !== el.style.zIndex) el.style.zIndex = `${zIndex}`;\n    });\n  }\n}\nexport default new ZIndexManager();","map":{"version":3,"names":["warn","ZIndexManager","constructor","elementZIndex","Map","nextZIndex","elementCount","size","ensureZIndex","el","zIndex","undefined","style","delete","has","currentZIndex","get","set","squashState","unregister","rearrange","elementZIndexPair","Array","from","entries","sort","pair1","pair2","forEach","pair"],"sources":["/Users/elmo/Documents/GitHub/meetings_vue3/node_modules/vdirs/es/zindexable/z-index-manager.js"],"sourcesContent":["import { warn } from '../utils';\nclass ZIndexManager {\n    constructor() {\n        this.elementZIndex = new Map();\n        this.nextZIndex = 2000;\n    }\n    get elementCount() {\n        return this.elementZIndex.size;\n    }\n    ensureZIndex(el, zIndex) {\n        const { elementZIndex } = this;\n        if (zIndex !== undefined) {\n            el.style.zIndex = `${zIndex}`;\n            elementZIndex.delete(el);\n            return;\n        }\n        const { nextZIndex } = this;\n        if (elementZIndex.has(el)) {\n            const currentZIndex = elementZIndex.get(el);\n            if (currentZIndex + 1 === this.nextZIndex)\n                return;\n        }\n        el.style.zIndex = `${nextZIndex}`;\n        elementZIndex.set(el, nextZIndex);\n        this.nextZIndex = nextZIndex + 1;\n        this.squashState();\n    }\n    unregister(el, zIndex) {\n        const { elementZIndex } = this;\n        if (elementZIndex.has(el)) {\n            elementZIndex.delete(el);\n        }\n        else if (zIndex === undefined) {\n            warn('z-index-manager/unregister-element', 'Element not found when unregistering.');\n        }\n        this.squashState();\n    }\n    squashState() {\n        const { elementCount } = this;\n        if (!elementCount) {\n            this.nextZIndex = 2000;\n        }\n        if (this.nextZIndex - elementCount > 2500)\n            this.rearrange();\n    }\n    rearrange() {\n        const elementZIndexPair = Array.from(this.elementZIndex.entries());\n        elementZIndexPair.sort((pair1, pair2) => {\n            return pair1[1] - pair2[1];\n        });\n        this.nextZIndex = 2000;\n        elementZIndexPair.forEach((pair) => {\n            const el = pair[0];\n            const zIndex = this.nextZIndex++;\n            if (`${zIndex}` !== el.style.zIndex)\n                el.style.zIndex = `${zIndex}`;\n        });\n    }\n}\nexport default new ZIndexManager();\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,UAAU;AAC/B,MAAMC,aAAa,CAAC;EAChBC,WAAW,GAAG;IACV,IAAI,CAACC,aAAa,GAAG,IAAIC,GAAG,EAAE;IAC9B,IAAI,CAACC,UAAU,GAAG,IAAI;EAC1B;EACA,IAAIC,YAAY,GAAG;IACf,OAAO,IAAI,CAACH,aAAa,CAACI,IAAI;EAClC;EACAC,YAAY,CAACC,EAAE,EAAEC,MAAM,EAAE;IACrB,MAAM;MAAEP;IAAc,CAAC,GAAG,IAAI;IAC9B,IAAIO,MAAM,KAAKC,SAAS,EAAE;MACtBF,EAAE,CAACG,KAAK,CAACF,MAAM,GAAI,GAAEA,MAAO,EAAC;MAC7BP,aAAa,CAACU,MAAM,CAACJ,EAAE,CAAC;MACxB;IACJ;IACA,MAAM;MAAEJ;IAAW,CAAC,GAAG,IAAI;IAC3B,IAAIF,aAAa,CAACW,GAAG,CAACL,EAAE,CAAC,EAAE;MACvB,MAAMM,aAAa,GAAGZ,aAAa,CAACa,GAAG,CAACP,EAAE,CAAC;MAC3C,IAAIM,aAAa,GAAG,CAAC,KAAK,IAAI,CAACV,UAAU,EACrC;IACR;IACAI,EAAE,CAACG,KAAK,CAACF,MAAM,GAAI,GAAEL,UAAW,EAAC;IACjCF,aAAa,CAACc,GAAG,CAACR,EAAE,EAAEJ,UAAU,CAAC;IACjC,IAAI,CAACA,UAAU,GAAGA,UAAU,GAAG,CAAC;IAChC,IAAI,CAACa,WAAW,EAAE;EACtB;EACAC,UAAU,CAACV,EAAE,EAAEC,MAAM,EAAE;IACnB,MAAM;MAAEP;IAAc,CAAC,GAAG,IAAI;IAC9B,IAAIA,aAAa,CAACW,GAAG,CAACL,EAAE,CAAC,EAAE;MACvBN,aAAa,CAACU,MAAM,CAACJ,EAAE,CAAC;IAC5B,CAAC,MACI,IAAIC,MAAM,KAAKC,SAAS,EAAE;MAC3BX,IAAI,CAAC,oCAAoC,EAAE,uCAAuC,CAAC;IACvF;IACA,IAAI,CAACkB,WAAW,EAAE;EACtB;EACAA,WAAW,GAAG;IACV,MAAM;MAAEZ;IAAa,CAAC,GAAG,IAAI;IAC7B,IAAI,CAACA,YAAY,EAAE;MACf,IAAI,CAACD,UAAU,GAAG,IAAI;IAC1B;IACA,IAAI,IAAI,CAACA,UAAU,GAAGC,YAAY,GAAG,IAAI,EACrC,IAAI,CAACc,SAAS,EAAE;EACxB;EACAA,SAAS,GAAG;IACR,MAAMC,iBAAiB,GAAGC,KAAK,CAACC,IAAI,CAAC,IAAI,CAACpB,aAAa,CAACqB,OAAO,EAAE,CAAC;IAClEH,iBAAiB,CAACI,IAAI,CAAC,CAACC,KAAK,EAAEC,KAAK,KAAK;MACrC,OAAOD,KAAK,CAAC,CAAC,CAAC,GAAGC,KAAK,CAAC,CAAC,CAAC;IAC9B,CAAC,CAAC;IACF,IAAI,CAACtB,UAAU,GAAG,IAAI;IACtBgB,iBAAiB,CAACO,OAAO,CAAEC,IAAI,IAAK;MAChC,MAAMpB,EAAE,GAAGoB,IAAI,CAAC,CAAC,CAAC;MAClB,MAAMnB,MAAM,GAAG,IAAI,CAACL,UAAU,EAAE;MAChC,IAAK,GAAEK,MAAO,EAAC,KAAKD,EAAE,CAACG,KAAK,CAACF,MAAM,EAC/BD,EAAE,CAACG,KAAK,CAACF,MAAM,GAAI,GAAEA,MAAO,EAAC;IACrC,CAAC,CAAC;EACN;AACJ;AACA,eAAe,IAAIT,aAAa,EAAE"},"metadata":{},"sourceType":"module","externalDependencies":[]}