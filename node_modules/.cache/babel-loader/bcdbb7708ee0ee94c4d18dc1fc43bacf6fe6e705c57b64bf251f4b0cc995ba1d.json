{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { isExpilicitlyNotLoaded, merge, minus, traverseWithCb, TRAVERSE_COMMAND } from './utils';\nexport class SubtreeNotLoadedError extends Error {\n  constructor() {\n    super();\n    this.message = 'SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.';\n  }\n}\nfunction getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {\n  return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);\n}\nfunction getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {\n  const visitedKeys = new Set();\n  uncheckedKeys.forEach(uncheckedKey => {\n    const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);\n    if (uncheckedTreeNode !== undefined) {\n      let nodeCursor = uncheckedTreeNode.parent;\n      while (nodeCursor !== null) {\n        if (nodeCursor.disabled) break;\n        if (visitedKeys.has(nodeCursor.key)) break;else {\n          visitedKeys.add(nodeCursor.key);\n        }\n        nodeCursor = nodeCursor.parent;\n      }\n    }\n  });\n  return visitedKeys;\n}\nfunction getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {\n  const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);\n  const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);\n  const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);\n  const keysToRemove = [];\n  extendedCheckedKeySet.forEach(key => {\n    if (extendedKeySetToUncheck.has(key) || ascendantKeySet.has(key)) {\n      keysToRemove.push(key);\n    }\n  });\n  keysToRemove.forEach(key => extendedCheckedKeySet.delete(key));\n  return extendedCheckedKeySet;\n}\nexport function getCheckedKeys(options, treeMate) {\n  const {\n    checkedKeys,\n    keysToCheck,\n    keysToUncheck,\n    indeterminateKeys,\n    cascade,\n    leafOnly,\n    checkStrategy,\n    allowNotLoaded\n  } = options;\n  if (!cascade) {\n    if (keysToCheck !== undefined) {\n      return {\n        checkedKeys: merge(checkedKeys, keysToCheck),\n        indeterminateKeys: Array.from(indeterminateKeys)\n      };\n    } else if (keysToUncheck !== undefined) {\n      return {\n        checkedKeys: minus(checkedKeys, keysToUncheck),\n        indeterminateKeys: Array.from(indeterminateKeys)\n      };\n    } else {\n      return {\n        checkedKeys: Array.from(checkedKeys),\n        indeterminateKeys: Array.from(indeterminateKeys)\n      };\n    }\n  }\n  const {\n    levelTreeNodeMap\n  } = treeMate;\n  let extendedCheckedKeySet;\n  if (keysToUncheck !== undefined) {\n    extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);\n  } else if (keysToCheck !== undefined) {\n    extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);\n  } else {\n    extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);\n  }\n  const checkStrategyIsParent = checkStrategy === 'parent';\n  const checkStrategyIsChild = checkStrategy === 'child' || leafOnly;\n  const syntheticCheckedKeySet = extendedCheckedKeySet;\n  const syntheticIndeterminateKeySet = new Set();\n  const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys()));\n  // cascade check\n  // 1. if tree is fully loaded, it just works\n  // 2. if the tree is not fully loaded, we assume that keys which is in not\n  //    loaded tree are not in checked keys\n  //    for example:\n  //    a -- b(fully-loaded)   -- c(fully-loaded)\n  //      |- d(partial-loaded) -- ?e(not-loaded)\n  //    in the case, `e` is assumed not to be checked, nor we can't calc `d`'s\n  //    and `a`'s status\n  for (let level = maxLevel; level >= 0; level -= 1) {\n    const levelIsZero = level === 0;\n    // it should exists, nor it is a bug\n    const levelTreeNodes = levelTreeNodeMap.get(level);\n    for (const levelTreeNode of levelTreeNodes) {\n      if (levelTreeNode.isLeaf) continue;\n      const {\n        key: levelTreeNodeKey,\n        shallowLoaded\n      } = levelTreeNode;\n      if (checkStrategyIsChild && shallowLoaded) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        levelTreeNode.children.forEach(v => {\n          if (!v.disabled && !v.isLeaf && v.shallowLoaded && syntheticCheckedKeySet.has(v.key)) {\n            syntheticCheckedKeySet.delete(v.key);\n          }\n        });\n      }\n      if (levelTreeNode.disabled || !shallowLoaded) {\n        continue;\n      }\n      let fullyChecked = true;\n      let partialChecked = false;\n      let allDisabled = true;\n      // it is shallow loaded, so `children` must exist\n      for (const childNode of levelTreeNode.children) {\n        const childKey = childNode.key;\n        if (childNode.disabled) continue;\n        if (allDisabled) allDisabled = false;\n        if (syntheticCheckedKeySet.has(childKey)) {\n          partialChecked = true;\n        } else if (syntheticIndeterminateKeySet.has(childKey)) {\n          partialChecked = true;\n          fullyChecked = false;\n          break;\n        } else {\n          fullyChecked = false;\n          if (partialChecked) {\n            break;\n          }\n        }\n      }\n      if (fullyChecked && !allDisabled) {\n        if (checkStrategyIsParent) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          levelTreeNode.children.forEach(v => {\n            if (!v.disabled && syntheticCheckedKeySet.has(v.key)) {\n              syntheticCheckedKeySet.delete(v.key);\n            }\n          });\n        }\n        syntheticCheckedKeySet.add(levelTreeNodeKey);\n      } else if (partialChecked) {\n        syntheticIndeterminateKeySet.add(levelTreeNodeKey);\n      }\n      if (levelIsZero && checkStrategyIsChild && syntheticCheckedKeySet.has(levelTreeNodeKey)) {\n        syntheticCheckedKeySet.delete(levelTreeNodeKey);\n      }\n    }\n  }\n  return {\n    checkedKeys: Array.from(syntheticCheckedKeySet),\n    indeterminateKeys: Array.from(syntheticIndeterminateKeySet)\n  };\n}\n// unchecking is safe when doing cascade uncheck in async mode\nexport function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {\n  const {\n    treeNodeMap,\n    getChildren\n  } = treeMate;\n  const visitedKeySet = new Set();\n  const extendedKeySet = new Set(checkedKeys);\n  checkedKeys.forEach(checkedKey => {\n    const checkedTreeNode = treeNodeMap.get(checkedKey);\n    if (checkedTreeNode !== undefined) {\n      traverseWithCb(checkedTreeNode, treeNode => {\n        if (treeNode.disabled) {\n          return TRAVERSE_COMMAND.STOP;\n        }\n        const {\n          key\n        } = treeNode;\n        if (visitedKeySet.has(key)) return;\n        visitedKeySet.add(key);\n        // Adding keys before loaded check is okay, since if not valid error\n        // would be thrown\n        extendedKeySet.add(key);\n        if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren)) {\n          if (isUnchecking) {\n            return TRAVERSE_COMMAND.STOP;\n          } else if (!allowNotLoaded) {\n            throw new SubtreeNotLoadedError();\n          }\n        }\n      });\n    }\n  });\n  return extendedKeySet;\n}","map":{"version":3,"names":["isExpilicitlyNotLoaded","merge","minus","traverseWithCb","TRAVERSE_COMMAND","SubtreeNotLoadedError","Error","constructor","message","getExtendedCheckedKeySetAfterCheck","checkKeys","currentCheckedKeys","treeMate","allowNotLoaded","getExtendedCheckedKeySet","concat","getAvailableAscendantNodeSet","uncheckedKeys","visitedKeys","Set","forEach","uncheckedKey","uncheckedTreeNode","treeNodeMap","get","undefined","nodeCursor","parent","disabled","has","key","add","getExtendedCheckedKeySetAfterUncheck","extendedCheckedKeySet","extendedKeySetToUncheck","ascendantKeySet","keysToRemove","push","delete","getCheckedKeys","options","checkedKeys","keysToCheck","keysToUncheck","indeterminateKeys","cascade","leafOnly","checkStrategy","Array","from","levelTreeNodeMap","checkStrategyIsParent","checkStrategyIsChild","syntheticCheckedKeySet","syntheticIndeterminateKeySet","maxLevel","Math","max","apply","keys","level","levelIsZero","levelTreeNodes","levelTreeNode","isLeaf","levelTreeNodeKey","shallowLoaded","children","v","fullyChecked","partialChecked","allDisabled","childNode","childKey","isUnchecking","getChildren","visitedKeySet","extendedKeySet","checkedKey","checkedTreeNode","treeNode","STOP","rawNode"],"sources":["/Users/elmo/GitHub/meetings_vue3/node_modules/treemate/es/check.js"],"sourcesContent":["import { isExpilicitlyNotLoaded, merge, minus, traverseWithCb, TRAVERSE_COMMAND } from './utils';\nexport class SubtreeNotLoadedError extends Error {\n    constructor() {\n        super();\n        this.message =\n            'SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.';\n    }\n}\nfunction getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {\n    return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);\n}\nfunction getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {\n    const visitedKeys = new Set();\n    uncheckedKeys.forEach((uncheckedKey) => {\n        const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);\n        if (uncheckedTreeNode !== undefined) {\n            let nodeCursor = uncheckedTreeNode.parent;\n            while (nodeCursor !== null) {\n                if (nodeCursor.disabled)\n                    break;\n                if (visitedKeys.has(nodeCursor.key))\n                    break;\n                else {\n                    visitedKeys.add(nodeCursor.key);\n                }\n                nodeCursor = nodeCursor.parent;\n            }\n        }\n    });\n    return visitedKeys;\n}\nfunction getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {\n    const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);\n    const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);\n    const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);\n    const keysToRemove = [];\n    extendedCheckedKeySet.forEach((key) => {\n        if (extendedKeySetToUncheck.has(key) || ascendantKeySet.has(key)) {\n            keysToRemove.push(key);\n        }\n    });\n    keysToRemove.forEach((key) => extendedCheckedKeySet.delete(key));\n    return extendedCheckedKeySet;\n}\nexport function getCheckedKeys(options, treeMate) {\n    const { checkedKeys, keysToCheck, keysToUncheck, indeterminateKeys, cascade, leafOnly, checkStrategy, allowNotLoaded } = options;\n    if (!cascade) {\n        if (keysToCheck !== undefined) {\n            return {\n                checkedKeys: merge(checkedKeys, keysToCheck),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n        else if (keysToUncheck !== undefined) {\n            return {\n                checkedKeys: minus(checkedKeys, keysToUncheck),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n        else {\n            return {\n                checkedKeys: Array.from(checkedKeys),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n    }\n    const { levelTreeNodeMap } = treeMate;\n    let extendedCheckedKeySet;\n    if (keysToUncheck !== undefined) {\n        extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);\n    }\n    else if (keysToCheck !== undefined) {\n        extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);\n    }\n    else {\n        extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);\n    }\n    const checkStrategyIsParent = checkStrategy === 'parent';\n    const checkStrategyIsChild = checkStrategy === 'child' || leafOnly;\n    const syntheticCheckedKeySet = extendedCheckedKeySet;\n    const syntheticIndeterminateKeySet = new Set();\n    const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys()));\n    // cascade check\n    // 1. if tree is fully loaded, it just works\n    // 2. if the tree is not fully loaded, we assume that keys which is in not\n    //    loaded tree are not in checked keys\n    //    for example:\n    //    a -- b(fully-loaded)   -- c(fully-loaded)\n    //      |- d(partial-loaded) -- ?e(not-loaded)\n    //    in the case, `e` is assumed not to be checked, nor we can't calc `d`'s\n    //    and `a`'s status\n    for (let level = maxLevel; level >= 0; level -= 1) {\n        const levelIsZero = level === 0;\n        // it should exists, nor it is a bug\n        const levelTreeNodes = levelTreeNodeMap.get(level);\n        for (const levelTreeNode of levelTreeNodes) {\n            if (levelTreeNode.isLeaf)\n                continue;\n            const { key: levelTreeNodeKey, shallowLoaded } = levelTreeNode;\n            if (checkStrategyIsChild && shallowLoaded) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                levelTreeNode.children.forEach((v) => {\n                    if (!v.disabled &&\n                        !v.isLeaf &&\n                        v.shallowLoaded &&\n                        syntheticCheckedKeySet.has(v.key)) {\n                        syntheticCheckedKeySet.delete(v.key);\n                    }\n                });\n            }\n            if (levelTreeNode.disabled || !shallowLoaded) {\n                continue;\n            }\n            let fullyChecked = true;\n            let partialChecked = false;\n            let allDisabled = true;\n            // it is shallow loaded, so `children` must exist\n            for (const childNode of levelTreeNode.children) {\n                const childKey = childNode.key;\n                if (childNode.disabled)\n                    continue;\n                if (allDisabled)\n                    allDisabled = false;\n                if (syntheticCheckedKeySet.has(childKey)) {\n                    partialChecked = true;\n                }\n                else if (syntheticIndeterminateKeySet.has(childKey)) {\n                    partialChecked = true;\n                    fullyChecked = false;\n                    break;\n                }\n                else {\n                    fullyChecked = false;\n                    if (partialChecked) {\n                        break;\n                    }\n                }\n            }\n            if (fullyChecked && !allDisabled) {\n                if (checkStrategyIsParent) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    levelTreeNode.children.forEach((v) => {\n                        if (!v.disabled && syntheticCheckedKeySet.has(v.key)) {\n                            syntheticCheckedKeySet.delete(v.key);\n                        }\n                    });\n                }\n                syntheticCheckedKeySet.add(levelTreeNodeKey);\n            }\n            else if (partialChecked) {\n                syntheticIndeterminateKeySet.add(levelTreeNodeKey);\n            }\n            if (levelIsZero &&\n                checkStrategyIsChild &&\n                syntheticCheckedKeySet.has(levelTreeNodeKey)) {\n                syntheticCheckedKeySet.delete(levelTreeNodeKey);\n            }\n        }\n    }\n    return {\n        checkedKeys: Array.from(syntheticCheckedKeySet),\n        indeterminateKeys: Array.from(syntheticIndeterminateKeySet)\n    };\n}\n// unchecking is safe when doing cascade uncheck in async mode\nexport function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {\n    const { treeNodeMap, getChildren } = treeMate;\n    const visitedKeySet = new Set();\n    const extendedKeySet = new Set(checkedKeys);\n    checkedKeys.forEach((checkedKey) => {\n        const checkedTreeNode = treeNodeMap.get(checkedKey);\n        if (checkedTreeNode !== undefined) {\n            traverseWithCb(checkedTreeNode, (treeNode) => {\n                if (treeNode.disabled) {\n                    return TRAVERSE_COMMAND.STOP;\n                }\n                const { key } = treeNode;\n                if (visitedKeySet.has(key))\n                    return;\n                visitedKeySet.add(key);\n                // Adding keys before loaded check is okay, since if not valid error\n                // would be thrown\n                extendedKeySet.add(key);\n                if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren)) {\n                    if (isUnchecking) {\n                        return TRAVERSE_COMMAND.STOP;\n                    }\n                    else if (!allowNotLoaded) {\n                        throw new SubtreeNotLoadedError();\n                    }\n                }\n            });\n        }\n    });\n    return extendedKeySet;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}