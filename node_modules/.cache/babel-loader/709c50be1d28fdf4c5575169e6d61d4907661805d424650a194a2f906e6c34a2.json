{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nfunction ampCount(selector) {\n  let cnt = 0;\n  for (let i = 0; i < selector.length; ++i) {\n    if (selector[i] === '&') ++cnt;\n  }\n  return cnt;\n}\n/**\n * Don't just use ',' to separate css selector. For example:\n * x:(a, b) {} will be split into 'x:(a' and 'b)', which is not expected.\n * Make sure comma doesn't exist inside parentheses.\n */\nconst separatorRegex = /\\s*,(?![^(]*\\))\\s*/g;\nconst extraSpaceRegex = /\\s+/g;\n/**\n * selector must includes '&'\n * selector is trimmed\n * every part of amp is trimmed\n */\nfunction resolveSelectorWithAmp(amp, selector) {\n  const nextAmp = [];\n  selector.split(separatorRegex).forEach(partialSelector => {\n    let round = ampCount(partialSelector);\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (!round) {\n      amp.forEach(partialAmp => {\n        nextAmp.push(\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        (partialAmp && partialAmp + ' ') + partialSelector);\n      });\n      return;\n    } else if (round === 1) {\n      amp.forEach(partialAmp => {\n        nextAmp.push(partialSelector.replace('&', partialAmp));\n      });\n      return;\n    }\n    let partialNextAmp = [partialSelector];\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    while (round--) {\n      const nextPartialNextAmp = [];\n      partialNextAmp.forEach(selectorItr => {\n        amp.forEach(partialAmp => {\n          nextPartialNextAmp.push(selectorItr.replace('&', partialAmp));\n        });\n      });\n      partialNextAmp = nextPartialNextAmp;\n    }\n    partialNextAmp.forEach(part => nextAmp.push(part));\n  });\n  return nextAmp;\n}\n/**\n * selector mustn't includes '&'\n * selector is trimmed\n */\nfunction resolveSelector(amp, selector) {\n  const nextAmp = [];\n  selector.split(separatorRegex).forEach(partialSelector => {\n    amp.forEach(partialAmp => {\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      nextAmp.push((partialAmp && partialAmp + ' ') + partialSelector);\n    });\n  });\n  return nextAmp;\n}\nexport function parseSelectorPath(selectorPaths) {\n  let amp = [''];\n  selectorPaths.forEach(selector => {\n    // eslint-disable-next-line\n    selector = selector && selector.trim();\n    if (\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    !selector) {\n      /**\n       * if it's a empty selector, do nothing\n       */\n      return;\n    }\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (selector.includes('&')) {\n      amp = resolveSelectorWithAmp(amp, selector);\n    } else {\n      amp = resolveSelector(amp, selector);\n    }\n  });\n  return amp.join(', ').replace(extraSpaceRegex, ' ');\n}","map":{"version":3,"names":["ampCount","selector","cnt","i","length","separatorRegex","extraSpaceRegex","resolveSelectorWithAmp","amp","nextAmp","split","forEach","partialSelector","round","partialAmp","push","replace","partialNextAmp","nextPartialNextAmp","selectorItr","part","resolveSelector","parseSelectorPath","selectorPaths","trim","includes","join"],"sources":["/Users/elmo/Documents/GitHub/meetings_vue3/node_modules/css-render/esm/parse.js"],"sourcesContent":["function ampCount(selector) {\n    let cnt = 0;\n    for (let i = 0; i < selector.length; ++i) {\n        if (selector[i] === '&')\n            ++cnt;\n    }\n    return cnt;\n}\n/**\n * Don't just use ',' to separate css selector. For example:\n * x:(a, b) {} will be split into 'x:(a' and 'b)', which is not expected.\n * Make sure comma doesn't exist inside parentheses.\n */\nconst separatorRegex = /\\s*,(?![^(]*\\))\\s*/g;\nconst extraSpaceRegex = /\\s+/g;\n/**\n * selector must includes '&'\n * selector is trimmed\n * every part of amp is trimmed\n */\nfunction resolveSelectorWithAmp(amp, selector) {\n    const nextAmp = [];\n    selector.split(separatorRegex).forEach(partialSelector => {\n        let round = ampCount(partialSelector);\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if (!round) {\n            amp.forEach(partialAmp => {\n                nextAmp.push(\n                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n                (partialAmp && partialAmp + ' ') + partialSelector);\n            });\n            return;\n        }\n        else if (round === 1) {\n            amp.forEach(partialAmp => {\n                nextAmp.push(partialSelector.replace('&', partialAmp));\n            });\n            return;\n        }\n        let partialNextAmp = [\n            partialSelector\n        ];\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        while (round--) {\n            const nextPartialNextAmp = [];\n            partialNextAmp.forEach(selectorItr => {\n                amp.forEach(partialAmp => {\n                    nextPartialNextAmp.push(selectorItr.replace('&', partialAmp));\n                });\n            });\n            partialNextAmp = nextPartialNextAmp;\n        }\n        partialNextAmp.forEach(part => nextAmp.push(part));\n    });\n    return nextAmp;\n}\n/**\n * selector mustn't includes '&'\n * selector is trimmed\n */\nfunction resolveSelector(amp, selector) {\n    const nextAmp = [];\n    selector.split(separatorRegex).forEach(partialSelector => {\n        amp.forEach(partialAmp => {\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            nextAmp.push(((partialAmp && partialAmp + ' ') + partialSelector));\n        });\n    });\n    return nextAmp;\n}\nexport function parseSelectorPath(selectorPaths) {\n    let amp = [''];\n    selectorPaths.forEach(selector => {\n        // eslint-disable-next-line\n        selector = selector && selector.trim();\n        if (\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        !selector) {\n            /**\n             * if it's a empty selector, do nothing\n             */\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if (selector.includes('&')) {\n            amp = resolveSelectorWithAmp(amp, selector);\n        }\n        else {\n            amp = resolveSelector(amp, selector);\n        }\n    });\n    return amp.join(', ').replace(extraSpaceRegex, ' ');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}