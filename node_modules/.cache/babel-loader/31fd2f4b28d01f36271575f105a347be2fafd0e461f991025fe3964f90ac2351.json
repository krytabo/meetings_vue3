{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { beforeNextFrameOnce } from 'seemly';\nimport { computed, watch, ref } from 'vue';\nimport { formatLength } from '../../_utils';\nimport { getNumberColWidth, getColKey } from './utils';\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function useScroll(props, {\n  mainTableInstRef,\n  mergedCurrentPageRef,\n  bodyWidthRef,\n  scrollPartRef\n}) {\n  let scrollLeft = 0;\n  const leftActiveFixedColKeyRef = ref(null);\n  const leftActiveFixedChildrenColKeysRef = ref([]);\n  const rightActiveFixedColKeyRef = ref(null);\n  const rightActiveFixedChildrenColKeysRef = ref([]);\n  const styleScrollXRef = computed(() => {\n    return formatLength(props.scrollX);\n  });\n  const leftFixedColumnsRef = computed(() => {\n    return props.columns.filter(column => column.fixed === 'left');\n  });\n  const rightFixedColumnsRef = computed(() => {\n    return props.columns.filter(column => column.fixed === 'right');\n  });\n  const fixedColumnLeftMapRef = computed(() => {\n    const columns = {};\n    let left = 0;\n    function traverse(cols) {\n      cols.forEach(col => {\n        const positionInfo = {\n          start: left,\n          end: 0\n        };\n        columns[getColKey(col)] = positionInfo;\n        if ('children' in col) {\n          traverse(col.children);\n          positionInfo.end = left;\n        } else {\n          left += getNumberColWidth(col) || 0;\n          positionInfo.end = left;\n        }\n      });\n    }\n    traverse(leftFixedColumnsRef.value);\n    return columns;\n  });\n  const fixedColumnRightMapRef = computed(() => {\n    const columns = {};\n    let right = 0;\n    function traverse(cols) {\n      for (let i = cols.length - 1; i >= 0; --i) {\n        const col = cols[i];\n        const positionInfo = {\n          start: right,\n          end: 0\n        };\n        columns[getColKey(col)] = positionInfo;\n        if ('children' in col) {\n          traverse(col.children);\n          positionInfo.end = right;\n        } else {\n          right += getNumberColWidth(col) || 0;\n          positionInfo.end = right;\n        }\n      }\n    }\n    traverse(rightFixedColumnsRef.value);\n    return columns;\n  });\n  function deriveActiveLeftFixedColumn() {\n    var _a, _b;\n    // target is header element\n    const {\n      value: leftFixedColumns\n    } = leftFixedColumnsRef;\n    let leftWidth = 0;\n    const {\n      value: fixedColumnLeftMap\n    } = fixedColumnLeftMapRef;\n    let leftActiveFixedColKey = null;\n    for (let i = 0; i < leftFixedColumns.length; ++i) {\n      const key = getColKey(leftFixedColumns[i]);\n      if (scrollLeft > (((_a = fixedColumnLeftMap[key]) === null || _a === void 0 ? void 0 : _a.start) || 0) - leftWidth) {\n        leftActiveFixedColKey = key;\n        leftWidth = ((_b = fixedColumnLeftMap[key]) === null || _b === void 0 ? void 0 : _b.end) || 0;\n      } else {\n        break;\n      }\n    }\n    leftActiveFixedColKeyRef.value = leftActiveFixedColKey;\n  }\n  function deriveActiveLeftFixedChildrenColumns() {\n    leftActiveFixedChildrenColKeysRef.value = [];\n    let activeLeftFixedColumn = props.columns.find(col => getColKey(col) === leftActiveFixedColKeyRef.value);\n    while (activeLeftFixedColumn && 'children' in activeLeftFixedColumn) {\n      const length = activeLeftFixedColumn.children.length;\n      if (length === 0) break;\n      const nextActiveLeftFixedColumn = activeLeftFixedColumn.children[length - 1];\n      leftActiveFixedChildrenColKeysRef.value.push(getColKey(nextActiveLeftFixedColumn));\n      activeLeftFixedColumn = nextActiveLeftFixedColumn;\n    }\n  }\n  function deriveActiveRightFixedColumn() {\n    var _a, _b;\n    // target is header element\n    const {\n      value: rightFixedColumns\n    } = rightFixedColumnsRef;\n    const scrollWidth = Number(props.scrollX);\n    const {\n      value: tableWidth\n    } = bodyWidthRef;\n    if (tableWidth === null) return;\n    let rightWidth = 0;\n    let rightActiveFixedColKey = null;\n    const {\n      value: fixedColumnRightMap\n    } = fixedColumnRightMapRef;\n    for (let i = rightFixedColumns.length - 1; i >= 0; --i) {\n      const key = getColKey(rightFixedColumns[i]);\n      if (Math.round(scrollLeft + (((_a = fixedColumnRightMap[key]) === null || _a === void 0 ? void 0 : _a.start) || 0) + tableWidth - rightWidth) < scrollWidth) {\n        rightActiveFixedColKey = key;\n        rightWidth = ((_b = fixedColumnRightMap[key]) === null || _b === void 0 ? void 0 : _b.end) || 0;\n      } else {\n        break;\n      }\n    }\n    rightActiveFixedColKeyRef.value = rightActiveFixedColKey;\n  }\n  function deriveActiveRightFixedChildrenColumns() {\n    rightActiveFixedChildrenColKeysRef.value = [];\n    let activeRightFixedColumn = props.columns.find(col => getColKey(col) === rightActiveFixedColKeyRef.value);\n    while (activeRightFixedColumn && 'children' in activeRightFixedColumn && activeRightFixedColumn.children.length) {\n      const nextActiveRightFixedColumn = activeRightFixedColumn.children[0];\n      rightActiveFixedChildrenColKeysRef.value.push(getColKey(nextActiveRightFixedColumn));\n      activeRightFixedColumn = nextActiveRightFixedColumn;\n    }\n  }\n  function getScrollElements() {\n    const header = mainTableInstRef.value ? mainTableInstRef.value.getHeaderElement() : null;\n    const body = mainTableInstRef.value ? mainTableInstRef.value.getBodyElement() : null;\n    return {\n      header,\n      body\n    };\n  }\n  function scrollMainTableBodyToTop() {\n    const {\n      body\n    } = getScrollElements();\n    if (body) {\n      body.scrollTop = 0;\n    }\n  }\n  function handleTableHeaderScroll() {\n    if (scrollPartRef.value === 'head') {\n      beforeNextFrameOnce(syncScrollState);\n    }\n  }\n  function handleTableBodyScroll(e) {\n    var _a;\n    (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);\n    if (scrollPartRef.value === 'body') {\n      beforeNextFrameOnce(syncScrollState);\n    }\n  }\n  function syncScrollState() {\n    // We can't simply use props.scrollX to determine whether the table has\n    // need to be sync since user may set column width for each column.\n    // Just let it be, the scroll listener won't be triggered for a basic table.\n    const {\n      header,\n      body\n    } = getScrollElements();\n    if (!body) return;\n    const {\n      value: tableWidth\n    } = bodyWidthRef;\n    if (tableWidth === null) return;\n    const {\n      value: scrollPart\n    } = scrollPartRef;\n    if (props.maxHeight || props.flexHeight) {\n      if (!header) return;\n      // we need to deal with overscroll\n      if (scrollPart === 'head') {\n        scrollLeft = header.scrollLeft;\n        body.scrollLeft = scrollLeft;\n      } else {\n        scrollLeft = body.scrollLeft;\n        header.scrollLeft = scrollLeft;\n      }\n    } else {\n      scrollLeft = body.scrollLeft;\n    }\n    deriveActiveLeftFixedColumn();\n    deriveActiveLeftFixedChildrenColumns();\n    deriveActiveRightFixedColumn();\n    deriveActiveRightFixedChildrenColumns();\n  }\n  function setHeaderScrollLeft(left) {\n    const {\n      header\n    } = getScrollElements();\n    if (!header) return;\n    header.scrollLeft = left;\n    syncScrollState();\n  }\n  watch(mergedCurrentPageRef, () => {\n    scrollMainTableBodyToTop();\n  });\n  return {\n    styleScrollXRef,\n    fixedColumnLeftMapRef,\n    fixedColumnRightMapRef,\n    leftFixedColumnsRef,\n    rightFixedColumnsRef,\n    leftActiveFixedColKeyRef,\n    leftActiveFixedChildrenColKeysRef,\n    rightActiveFixedColKeyRef,\n    rightActiveFixedChildrenColKeysRef,\n    syncScrollState,\n    handleTableBodyScroll,\n    handleTableHeaderScroll,\n    setHeaderScrollLeft\n  };\n}","map":{"version":3,"names":["beforeNextFrameOnce","computed","watch","ref","formatLength","getNumberColWidth","getColKey","useScroll","props","mainTableInstRef","mergedCurrentPageRef","bodyWidthRef","scrollPartRef","scrollLeft","leftActiveFixedColKeyRef","leftActiveFixedChildrenColKeysRef","rightActiveFixedColKeyRef","rightActiveFixedChildrenColKeysRef","styleScrollXRef","scrollX","leftFixedColumnsRef","columns","filter","column","fixed","rightFixedColumnsRef","fixedColumnLeftMapRef","left","traverse","cols","forEach","col","positionInfo","start","end","children","value","fixedColumnRightMapRef","right","i","length","deriveActiveLeftFixedColumn","_a","_b","leftFixedColumns","leftWidth","fixedColumnLeftMap","leftActiveFixedColKey","key","deriveActiveLeftFixedChildrenColumns","activeLeftFixedColumn","find","nextActiveLeftFixedColumn","push","deriveActiveRightFixedColumn","rightFixedColumns","scrollWidth","Number","tableWidth","rightWidth","rightActiveFixedColKey","fixedColumnRightMap","Math","round","deriveActiveRightFixedChildrenColumns","activeRightFixedColumn","nextActiveRightFixedColumn","getScrollElements","header","getHeaderElement","body","getBodyElement","scrollMainTableBodyToTop","scrollTop","handleTableHeaderScroll","syncScrollState","handleTableBodyScroll","e","onScroll","call","scrollPart","maxHeight","flexHeight","setHeaderScrollLeft"],"sources":["/Users/elmo/Documents/GitHub/meetings_vue3/node_modules/naive-ui/es/data-table/src/use-scroll.js"],"sourcesContent":["import { beforeNextFrameOnce } from 'seemly';\nimport { computed, watch, ref } from 'vue';\nimport { formatLength } from '../../_utils';\nimport { getNumberColWidth, getColKey } from './utils';\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function useScroll(props, { mainTableInstRef, mergedCurrentPageRef, bodyWidthRef, scrollPartRef }) {\n    let scrollLeft = 0;\n    const leftActiveFixedColKeyRef = ref(null);\n    const leftActiveFixedChildrenColKeysRef = ref([]);\n    const rightActiveFixedColKeyRef = ref(null);\n    const rightActiveFixedChildrenColKeysRef = ref([]);\n    const styleScrollXRef = computed(() => {\n        return formatLength(props.scrollX);\n    });\n    const leftFixedColumnsRef = computed(() => {\n        return props.columns.filter((column) => column.fixed === 'left');\n    });\n    const rightFixedColumnsRef = computed(() => {\n        return props.columns.filter((column) => column.fixed === 'right');\n    });\n    const fixedColumnLeftMapRef = computed(() => {\n        const columns = {};\n        let left = 0;\n        function traverse(cols) {\n            cols.forEach((col) => {\n                const positionInfo = { start: left, end: 0 };\n                columns[getColKey(col)] = positionInfo;\n                if ('children' in col) {\n                    traverse(col.children);\n                    positionInfo.end = left;\n                }\n                else {\n                    left += getNumberColWidth(col) || 0;\n                    positionInfo.end = left;\n                }\n            });\n        }\n        traverse(leftFixedColumnsRef.value);\n        return columns;\n    });\n    const fixedColumnRightMapRef = computed(() => {\n        const columns = {};\n        let right = 0;\n        function traverse(cols) {\n            for (let i = cols.length - 1; i >= 0; --i) {\n                const col = cols[i];\n                const positionInfo = { start: right, end: 0 };\n                columns[getColKey(col)] = positionInfo;\n                if ('children' in col) {\n                    traverse(col.children);\n                    positionInfo.end = right;\n                }\n                else {\n                    right += getNumberColWidth(col) || 0;\n                    positionInfo.end = right;\n                }\n            }\n        }\n        traverse(rightFixedColumnsRef.value);\n        return columns;\n    });\n    function deriveActiveLeftFixedColumn() {\n        var _a, _b;\n        // target is header element\n        const { value: leftFixedColumns } = leftFixedColumnsRef;\n        let leftWidth = 0;\n        const { value: fixedColumnLeftMap } = fixedColumnLeftMapRef;\n        let leftActiveFixedColKey = null;\n        for (let i = 0; i < leftFixedColumns.length; ++i) {\n            const key = getColKey(leftFixedColumns[i]);\n            if (scrollLeft > (((_a = fixedColumnLeftMap[key]) === null || _a === void 0 ? void 0 : _a.start) || 0) - leftWidth) {\n                leftActiveFixedColKey = key;\n                leftWidth = ((_b = fixedColumnLeftMap[key]) === null || _b === void 0 ? void 0 : _b.end) || 0;\n            }\n            else {\n                break;\n            }\n        }\n        leftActiveFixedColKeyRef.value = leftActiveFixedColKey;\n    }\n    function deriveActiveLeftFixedChildrenColumns() {\n        leftActiveFixedChildrenColKeysRef.value = [];\n        let activeLeftFixedColumn = props.columns.find((col) => getColKey(col) === leftActiveFixedColKeyRef.value);\n        while (activeLeftFixedColumn && 'children' in activeLeftFixedColumn) {\n            const length = activeLeftFixedColumn.children.length;\n            if (length === 0)\n                break;\n            const nextActiveLeftFixedColumn = activeLeftFixedColumn.children[length - 1];\n            leftActiveFixedChildrenColKeysRef.value.push(getColKey(nextActiveLeftFixedColumn));\n            activeLeftFixedColumn = nextActiveLeftFixedColumn;\n        }\n    }\n    function deriveActiveRightFixedColumn() {\n        var _a, _b;\n        // target is header element\n        const { value: rightFixedColumns } = rightFixedColumnsRef;\n        const scrollWidth = Number(props.scrollX);\n        const { value: tableWidth } = bodyWidthRef;\n        if (tableWidth === null)\n            return;\n        let rightWidth = 0;\n        let rightActiveFixedColKey = null;\n        const { value: fixedColumnRightMap } = fixedColumnRightMapRef;\n        for (let i = rightFixedColumns.length - 1; i >= 0; --i) {\n            const key = getColKey(rightFixedColumns[i]);\n            if (Math.round(scrollLeft +\n                (((_a = fixedColumnRightMap[key]) === null || _a === void 0 ? void 0 : _a.start) || 0) +\n                tableWidth -\n                rightWidth) < scrollWidth) {\n                rightActiveFixedColKey = key;\n                rightWidth = ((_b = fixedColumnRightMap[key]) === null || _b === void 0 ? void 0 : _b.end) || 0;\n            }\n            else {\n                break;\n            }\n        }\n        rightActiveFixedColKeyRef.value = rightActiveFixedColKey;\n    }\n    function deriveActiveRightFixedChildrenColumns() {\n        rightActiveFixedChildrenColKeysRef.value = [];\n        let activeRightFixedColumn = props.columns.find((col) => getColKey(col) === rightActiveFixedColKeyRef.value);\n        while (activeRightFixedColumn &&\n            'children' in activeRightFixedColumn &&\n            activeRightFixedColumn.children.length) {\n            const nextActiveRightFixedColumn = activeRightFixedColumn.children[0];\n            rightActiveFixedChildrenColKeysRef.value.push(getColKey(nextActiveRightFixedColumn));\n            activeRightFixedColumn = nextActiveRightFixedColumn;\n        }\n    }\n    function getScrollElements() {\n        const header = mainTableInstRef.value\n            ? mainTableInstRef.value.getHeaderElement()\n            : null;\n        const body = mainTableInstRef.value\n            ? mainTableInstRef.value.getBodyElement()\n            : null;\n        return {\n            header,\n            body\n        };\n    }\n    function scrollMainTableBodyToTop() {\n        const { body } = getScrollElements();\n        if (body) {\n            body.scrollTop = 0;\n        }\n    }\n    function handleTableHeaderScroll() {\n        if (scrollPartRef.value === 'head') {\n            beforeNextFrameOnce(syncScrollState);\n        }\n    }\n    function handleTableBodyScroll(e) {\n        var _a;\n        (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);\n        if (scrollPartRef.value === 'body') {\n            beforeNextFrameOnce(syncScrollState);\n        }\n    }\n    function syncScrollState() {\n        // We can't simply use props.scrollX to determine whether the table has\n        // need to be sync since user may set column width for each column.\n        // Just let it be, the scroll listener won't be triggered for a basic table.\n        const { header, body } = getScrollElements();\n        if (!body)\n            return;\n        const { value: tableWidth } = bodyWidthRef;\n        if (tableWidth === null)\n            return;\n        const { value: scrollPart } = scrollPartRef;\n        if (props.maxHeight || props.flexHeight) {\n            if (!header)\n                return;\n            // we need to deal with overscroll\n            if (scrollPart === 'head') {\n                scrollLeft = header.scrollLeft;\n                body.scrollLeft = scrollLeft;\n            }\n            else {\n                scrollLeft = body.scrollLeft;\n                header.scrollLeft = scrollLeft;\n            }\n        }\n        else {\n            scrollLeft = body.scrollLeft;\n        }\n        deriveActiveLeftFixedColumn();\n        deriveActiveLeftFixedChildrenColumns();\n        deriveActiveRightFixedColumn();\n        deriveActiveRightFixedChildrenColumns();\n    }\n    function setHeaderScrollLeft(left) {\n        const { header } = getScrollElements();\n        if (!header)\n            return;\n        header.scrollLeft = left;\n        syncScrollState();\n    }\n    watch(mergedCurrentPageRef, () => {\n        scrollMainTableBodyToTop();\n    });\n    return {\n        styleScrollXRef,\n        fixedColumnLeftMapRef,\n        fixedColumnRightMapRef,\n        leftFixedColumnsRef,\n        rightFixedColumnsRef,\n        leftActiveFixedColKeyRef,\n        leftActiveFixedChildrenColKeysRef,\n        rightActiveFixedColKeyRef,\n        rightActiveFixedChildrenColKeysRef,\n        syncScrollState,\n        handleTableBodyScroll,\n        handleTableHeaderScroll,\n        setHeaderScrollLeft\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}