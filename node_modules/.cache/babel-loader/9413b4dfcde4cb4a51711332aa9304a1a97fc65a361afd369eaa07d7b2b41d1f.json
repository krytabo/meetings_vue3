{"ast":null,"code":"export const resolveOptionsAndHash = (options = {}) => {\n  var _a;\n  const {\n    root = null\n  } = options;\n  return {\n    hash: `${options.rootMargin || '0px 0px 0px 0px'}-${Array.isArray(options.threshold) ? options.threshold.join(',') : (_a = options.threshold) !== null && _a !== void 0 ? _a : '0'}`,\n    options: Object.assign(Object.assign({}, options), {\n      root: (typeof root === 'string' ? document.querySelector(root) : root) || document.documentElement\n    })\n  };\n};\n// root -> options -> [observer, elements]\nconst observers = new WeakMap();\nconst unobserveHandleMap = new WeakMap();\nconst shouldStartLoadingRefMap = new WeakMap();\nexport const observeIntersection = (el, options, shouldStartLoadingRef) => {\n  if (!el) return () => {};\n  const resolvedOptionsAndHash = resolveOptionsAndHash(options);\n  const {\n    root\n  } = resolvedOptionsAndHash.options;\n  let rootObservers;\n  const _rootObservers = observers.get(root);\n  if (_rootObservers) {\n    rootObservers = _rootObservers;\n  } else {\n    rootObservers = new Map();\n    observers.set(root, rootObservers);\n  }\n  let observer;\n  let observerAndObservedElements;\n  if (rootObservers.has(resolvedOptionsAndHash.hash)) {\n    observerAndObservedElements =\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    rootObservers.get(resolvedOptionsAndHash.hash);\n    if (!observerAndObservedElements[1].has(el)) {\n      observer = observerAndObservedElements[0];\n      observerAndObservedElements[1].add(el);\n      observer.observe(el);\n    }\n  } else {\n    observer = new IntersectionObserver(entries => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting) {\n          const _unobserve = unobserveHandleMap.get(entry.target);\n          const _shouldStartLoadingRef = shouldStartLoadingRefMap.get(entry.target);\n          if (_unobserve) _unobserve();\n          if (_shouldStartLoadingRef) {\n            _shouldStartLoadingRef.value = true;\n          }\n        }\n      });\n    }, resolvedOptionsAndHash.options);\n    observer.observe(el);\n    observerAndObservedElements = [observer, new Set([el])];\n    rootObservers.set(resolvedOptionsAndHash.hash, observerAndObservedElements);\n  }\n  let unobservered = false;\n  const unobserve = () => {\n    if (unobservered) return;\n    unobserveHandleMap.delete(el);\n    shouldStartLoadingRefMap.delete(el);\n    unobservered = true;\n    if (observerAndObservedElements[1].has(el)) {\n      observerAndObservedElements[0].unobserve(el);\n      observerAndObservedElements[1].delete(el);\n    }\n    if (observerAndObservedElements[1].size <= 0) {\n      rootObservers.delete(resolvedOptionsAndHash.hash);\n    }\n    if (!rootObservers.size) {\n      observers.delete(root);\n    }\n  };\n  unobserveHandleMap.set(el, unobserve);\n  shouldStartLoadingRefMap.set(el, shouldStartLoadingRef);\n  return unobserve;\n};","map":{"version":3,"names":["resolveOptionsAndHash","options","_a","root","hash","rootMargin","Array","isArray","threshold","join","Object","assign","document","querySelector","documentElement","observers","WeakMap","unobserveHandleMap","shouldStartLoadingRefMap","observeIntersection","el","shouldStartLoadingRef","resolvedOptionsAndHash","rootObservers","_rootObservers","get","Map","set","observer","observerAndObservedElements","has","add","observe","IntersectionObserver","entries","forEach","entry","isIntersecting","_unobserve","target","_shouldStartLoadingRef","value","Set","unobservered","unobserve","delete","size"],"sources":["/Users/elmo/GitHub/meetings_vue3/node_modules/naive-ui/es/image/src/utils.js"],"sourcesContent":["export const resolveOptionsAndHash = (options = {}) => {\n    var _a;\n    const { root = null } = options;\n    return {\n        hash: `${options.rootMargin || '0px 0px 0px 0px'}-${Array.isArray(options.threshold)\n            ? options.threshold.join(',')\n            : (_a = options.threshold) !== null && _a !== void 0 ? _a : '0'}`,\n        options: Object.assign(Object.assign({}, options), { root: (typeof root === 'string' ? document.querySelector(root) : root) ||\n                document.documentElement })\n    };\n};\n// root -> options -> [observer, elements]\nconst observers = new WeakMap();\nconst unobserveHandleMap = new WeakMap();\nconst shouldStartLoadingRefMap = new WeakMap();\nexport const observeIntersection = (el, options, shouldStartLoadingRef) => {\n    if (!el)\n        return () => { };\n    const resolvedOptionsAndHash = resolveOptionsAndHash(options);\n    const { root } = resolvedOptionsAndHash.options;\n    let rootObservers;\n    const _rootObservers = observers.get(root);\n    if (_rootObservers) {\n        rootObservers = _rootObservers;\n    }\n    else {\n        rootObservers = new Map();\n        observers.set(root, rootObservers);\n    }\n    let observer;\n    let observerAndObservedElements;\n    if (rootObservers.has(resolvedOptionsAndHash.hash)) {\n        observerAndObservedElements =\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            rootObservers.get(resolvedOptionsAndHash.hash);\n        if (!observerAndObservedElements[1].has(el)) {\n            observer = observerAndObservedElements[0];\n            observerAndObservedElements[1].add(el);\n            observer.observe(el);\n        }\n    }\n    else {\n        observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    const _unobserve = unobserveHandleMap.get(entry.target);\n                    const _shouldStartLoadingRef = shouldStartLoadingRefMap.get(entry.target);\n                    if (_unobserve)\n                        _unobserve();\n                    if (_shouldStartLoadingRef) {\n                        _shouldStartLoadingRef.value = true;\n                    }\n                }\n            });\n        }, resolvedOptionsAndHash.options);\n        observer.observe(el);\n        observerAndObservedElements = [observer, new Set([el])];\n        rootObservers.set(resolvedOptionsAndHash.hash, observerAndObservedElements);\n    }\n    let unobservered = false;\n    const unobserve = () => {\n        if (unobservered)\n            return;\n        unobserveHandleMap.delete(el);\n        shouldStartLoadingRefMap.delete(el);\n        unobservered = true;\n        if (observerAndObservedElements[1].has(el)) {\n            observerAndObservedElements[0].unobserve(el);\n            observerAndObservedElements[1].delete(el);\n        }\n        if (observerAndObservedElements[1].size <= 0) {\n            rootObservers.delete(resolvedOptionsAndHash.hash);\n        }\n        if (!rootObservers.size) {\n            observers.delete(root);\n        }\n    };\n    unobserveHandleMap.set(el, unobserve);\n    shouldStartLoadingRefMap.set(el, shouldStartLoadingRef);\n    return unobserve;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}