{"ast":null,"code":"/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nimport { defineComponent, renderSlot, h, onMounted, ref, nextTick } from 'vue';\nimport { useSsrAdapter } from '@css-render/vue3-ssr';\nimport { c, cssrAnchorMetaName } from '../../shared';\nconst hiddenAttr = 'v-hidden';\nconst style = c('[v-hidden]', {\n  display: 'none!important'\n});\nexport default defineComponent({\n  name: 'Overflow',\n  props: {\n    getCounter: Function,\n    getTail: Function,\n    updateCounter: Function,\n    onUpdateOverflow: Function\n  },\n  setup(props, {\n    slots\n  }) {\n    const selfRef = ref(null);\n    const counterRef = ref(null);\n    function deriveCounter() {\n      const {\n        value: self\n      } = selfRef;\n      const {\n        getCounter,\n        getTail\n      } = props;\n      let counter;\n      if (getCounter !== undefined) counter = getCounter();else {\n        counter = counterRef.value;\n      }\n      if (!self || !counter) return;\n      if (counter.hasAttribute(hiddenAttr)) {\n        counter.removeAttribute(hiddenAttr);\n      }\n      const {\n        children\n      } = self;\n      const containerWidth = self.offsetWidth;\n      const childWidths = [];\n      const tail = slots.tail ? getTail === null || getTail === void 0 ? void 0 : getTail() : null;\n      let childWidthSum = tail ? tail.offsetWidth : 0;\n      let overflow = false;\n      const len = self.children.length - (slots.tail ? 1 : 0);\n      for (let i = 0; i < len - 1; ++i) {\n        if (i < 0) continue;\n        const child = children[i];\n        if (overflow) {\n          if (!child.hasAttribute(hiddenAttr)) {\n            child.setAttribute(hiddenAttr, '');\n          }\n          continue;\n        } else if (child.hasAttribute(hiddenAttr)) {\n          child.removeAttribute(hiddenAttr);\n        }\n        const childWidth = child.offsetWidth;\n        childWidthSum += childWidth;\n        childWidths[i] = childWidth;\n        if (childWidthSum > containerWidth) {\n          const {\n            updateCounter\n          } = props;\n          for (let j = i; j >= 0; --j) {\n            const restCount = len - 1 - j;\n            if (updateCounter !== undefined) {\n              updateCounter(restCount);\n            } else {\n              counter.textContent = `${restCount}`;\n            }\n            const counterWidth = counter.offsetWidth;\n            childWidthSum -= childWidths[j];\n            if (childWidthSum + counterWidth <= containerWidth || j === 0) {\n              overflow = true;\n              i = j - 1;\n              if (tail) {\n                // tail too long or 1st element too long\n                // we only consider tail now\n                if (i === -1) {\n                  tail.style.maxWidth = `${containerWidth - counterWidth}px`;\n                  tail.style.boxSizing = 'border-box';\n                } else {\n                  tail.style.maxWidth = '';\n                }\n              }\n              break;\n            }\n          }\n        }\n      }\n      const {\n        onUpdateOverflow\n      } = props;\n      if (!overflow) {\n        if (onUpdateOverflow !== undefined) {\n          onUpdateOverflow(false);\n        }\n        counter.setAttribute(hiddenAttr, '');\n      } else {\n        if (onUpdateOverflow !== undefined) {\n          onUpdateOverflow(true);\n        }\n      }\n    }\n    const ssrAdapter = useSsrAdapter();\n    style.mount({\n      id: 'vueuc/overflow',\n      head: true,\n      anchorMetaName: cssrAnchorMetaName,\n      ssr: ssrAdapter\n    });\n    onMounted(deriveCounter);\n    // besides onMounted, other case should be manually triggered, or we shoud watch items\n    return {\n      selfRef,\n      counterRef,\n      sync: deriveCounter\n    };\n  },\n  render() {\n    const {\n      $slots\n    } = this;\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    nextTick(this.sync);\n    // It shouldn't have border\n    return h('div', {\n      class: 'v-overflow',\n      ref: 'selfRef'\n    }, [renderSlot($slots, 'default'),\n    // $slots.counter should only has 1 element\n    $slots.counter ? $slots.counter() : h('span', {\n      style: {\n        display: 'inline-block'\n      },\n      ref: 'counterRef'\n    }),\n    // $slots.tail should only has 1 element\n    $slots.tail ? $slots.tail() : null]);\n  }\n});","map":{"version":3,"names":["defineComponent","renderSlot","h","onMounted","ref","nextTick","useSsrAdapter","c","cssrAnchorMetaName","hiddenAttr","style","display","name","props","getCounter","Function","getTail","updateCounter","onUpdateOverflow","setup","slots","selfRef","counterRef","deriveCounter","value","self","counter","undefined","hasAttribute","removeAttribute","children","containerWidth","offsetWidth","childWidths","tail","childWidthSum","overflow","len","length","i","child","setAttribute","childWidth","j","restCount","textContent","counterWidth","maxWidth","boxSizing","ssrAdapter","mount","id","head","anchorMetaName","ssr","sync","render","$slots","class"],"sources":["/Users/elmo/GitHub/meetings_vue3/node_modules/vueuc/es/overflow/src/index.js"],"sourcesContent":["/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nimport { defineComponent, renderSlot, h, onMounted, ref, nextTick } from 'vue';\nimport { useSsrAdapter } from '@css-render/vue3-ssr';\nimport { c, cssrAnchorMetaName } from '../../shared';\nconst hiddenAttr = 'v-hidden';\nconst style = c('[v-hidden]', {\n    display: 'none!important'\n});\nexport default defineComponent({\n    name: 'Overflow',\n    props: {\n        getCounter: Function,\n        getTail: Function,\n        updateCounter: Function,\n        onUpdateOverflow: Function\n    },\n    setup(props, { slots }) {\n        const selfRef = ref(null);\n        const counterRef = ref(null);\n        function deriveCounter() {\n            const { value: self } = selfRef;\n            const { getCounter, getTail } = props;\n            let counter;\n            if (getCounter !== undefined)\n                counter = getCounter();\n            else {\n                counter = counterRef.value;\n            }\n            if (!self || !counter)\n                return;\n            if (counter.hasAttribute(hiddenAttr)) {\n                counter.removeAttribute(hiddenAttr);\n            }\n            const { children } = self;\n            const containerWidth = self.offsetWidth;\n            const childWidths = [];\n            const tail = slots.tail ? getTail === null || getTail === void 0 ? void 0 : getTail() : null;\n            let childWidthSum = tail ? tail.offsetWidth : 0;\n            let overflow = false;\n            const len = self.children.length - (slots.tail ? 1 : 0);\n            for (let i = 0; i < len - 1; ++i) {\n                if (i < 0)\n                    continue;\n                const child = children[i];\n                if (overflow) {\n                    if (!child.hasAttribute(hiddenAttr)) {\n                        child.setAttribute(hiddenAttr, '');\n                    }\n                    continue;\n                }\n                else if (child.hasAttribute(hiddenAttr)) {\n                    child.removeAttribute(hiddenAttr);\n                }\n                const childWidth = child.offsetWidth;\n                childWidthSum += childWidth;\n                childWidths[i] = childWidth;\n                if (childWidthSum > containerWidth) {\n                    const { updateCounter } = props;\n                    for (let j = i; j >= 0; --j) {\n                        const restCount = len - 1 - j;\n                        if (updateCounter !== undefined) {\n                            updateCounter(restCount);\n                        }\n                        else {\n                            counter.textContent = `${restCount}`;\n                        }\n                        const counterWidth = counter.offsetWidth;\n                        childWidthSum -= childWidths[j];\n                        if (childWidthSum + counterWidth <= containerWidth || j === 0) {\n                            overflow = true;\n                            i = j - 1;\n                            if (tail) {\n                                // tail too long or 1st element too long\n                                // we only consider tail now\n                                if (i === -1) {\n                                    tail.style.maxWidth = `${containerWidth - counterWidth}px`;\n                                    tail.style.boxSizing = 'border-box';\n                                }\n                                else {\n                                    tail.style.maxWidth = '';\n                                }\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n            const { onUpdateOverflow } = props;\n            if (!overflow) {\n                if (onUpdateOverflow !== undefined) {\n                    onUpdateOverflow(false);\n                }\n                counter.setAttribute(hiddenAttr, '');\n            }\n            else {\n                if (onUpdateOverflow !== undefined) {\n                    onUpdateOverflow(true);\n                }\n            }\n        }\n        const ssrAdapter = useSsrAdapter();\n        style.mount({\n            id: 'vueuc/overflow',\n            head: true,\n            anchorMetaName: cssrAnchorMetaName,\n            ssr: ssrAdapter\n        });\n        onMounted(deriveCounter);\n        // besides onMounted, other case should be manually triggered, or we shoud watch items\n        return {\n            selfRef,\n            counterRef,\n            sync: deriveCounter\n        };\n    },\n    render() {\n        const { $slots } = this;\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        nextTick(this.sync);\n        // It shouldn't have border\n        return h('div', {\n            class: 'v-overflow',\n            ref: 'selfRef'\n        }, [\n            renderSlot($slots, 'default'),\n            // $slots.counter should only has 1 element\n            $slots.counter\n                ? $slots.counter()\n                : h('span', {\n                    style: {\n                        display: 'inline-block'\n                    },\n                    ref: 'counterRef'\n                }),\n            // $slots.tail should only has 1 element\n            $slots.tail ? $slots.tail() : null\n        ]);\n    }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}