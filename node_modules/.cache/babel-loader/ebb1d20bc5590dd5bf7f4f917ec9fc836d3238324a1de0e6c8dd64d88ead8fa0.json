{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { trapOn, trapOff } from './traps';\nimport { getEventTarget } from './utils';\n// currently `once` and `passive` is not supported\nfunction createDelegate() {\n  if (typeof window === 'undefined') {\n    return {\n      on: () => {},\n      off: () => {}\n    };\n  }\n  const propagationStopped = new WeakMap();\n  const immediatePropagationStopped = new WeakMap();\n  function trackPropagation() {\n    propagationStopped.set(this, true);\n  }\n  function trackImmediate() {\n    propagationStopped.set(this, true);\n    immediatePropagationStopped.set(this, true);\n  }\n  function spy(event, propName, fn) {\n    const source = event[propName];\n    event[propName] = function () {\n      fn.apply(event, arguments);\n      return source.apply(event, arguments);\n    };\n    return event;\n  }\n  function unspy(event, propName) {\n    event[propName] = Event.prototype[propName];\n  }\n  const currentTargets = new WeakMap();\n  const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'currentTarget');\n  function getCurrentTarget() {\n    var _a;\n    return (_a = currentTargets.get(this)) !== null && _a !== void 0 ? _a : null;\n  }\n  function defineCurrentTarget(event, getter) {\n    if (currentTargetDescriptor === undefined) return;\n    Object.defineProperty(event, 'currentTarget', {\n      configurable: true,\n      enumerable: true,\n      get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get\n    });\n  }\n  const phaseToTypeToElToHandlers = {\n    bubble: {},\n    capture: {}\n  };\n  const typeToWindowEventHandlers = {};\n  function createUnifiedHandler() {\n    const delegeteHandler = function (e) {\n      const {\n        type,\n        eventPhase,\n        bubbles\n      } = e;\n      const target = getEventTarget(e);\n      if (eventPhase === 2) return;\n      const phase = eventPhase === 1 ? 'capture' : 'bubble';\n      let cursor = target;\n      const path = [];\n      // collecting bubble path\n      while (true) {\n        if (cursor === null) cursor = window;\n        path.push(cursor);\n        if (cursor === window) {\n          break;\n        }\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        cursor = cursor.parentNode || null;\n      }\n      const captureElToHandlers = phaseToTypeToElToHandlers.capture[type];\n      const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type];\n      spy(e, 'stopPropagation', trackPropagation);\n      spy(e, 'stopImmediatePropagation', trackImmediate);\n      defineCurrentTarget(e, getCurrentTarget);\n      if (phase === 'capture') {\n        if (captureElToHandlers === undefined) return;\n        // capture\n        for (let i = path.length - 1; i >= 0; --i) {\n          if (propagationStopped.has(e)) break;\n          const target = path[i];\n          const handlers = captureElToHandlers.get(target);\n          if (handlers !== undefined) {\n            currentTargets.set(e, target);\n            for (const handler of handlers) {\n              if (immediatePropagationStopped.has(e)) break;\n              handler(e);\n            }\n          }\n          if (i === 0 && !bubbles && bubbleElToHandlers !== undefined) {\n            const bubbleHandlers = bubbleElToHandlers.get(target);\n            if (bubbleHandlers !== undefined) {\n              for (const handler of bubbleHandlers) {\n                if (immediatePropagationStopped.has(e)) break;\n                handler(e);\n              }\n            }\n          }\n        }\n      } else if (phase === 'bubble') {\n        if (bubbleElToHandlers === undefined) return;\n        // bubble\n        for (let i = 0; i < path.length; ++i) {\n          if (propagationStopped.has(e)) break;\n          const target = path[i];\n          const handlers = bubbleElToHandlers.get(target);\n          if (handlers !== undefined) {\n            currentTargets.set(e, target);\n            for (const handler of handlers) {\n              if (immediatePropagationStopped.has(e)) break;\n              handler(e);\n            }\n          }\n        }\n      }\n      unspy(e, 'stopPropagation');\n      unspy(e, 'stopImmediatePropagation');\n      defineCurrentTarget(e);\n    };\n    delegeteHandler.displayName = 'evtdUnifiedHandler';\n    return delegeteHandler;\n  }\n  function createUnifiedWindowEventHandler() {\n    const delegateHandler = function (e) {\n      const {\n        type,\n        eventPhase\n      } = e;\n      if (eventPhase !== 2) return;\n      const handlers = typeToWindowEventHandlers[type];\n      if (handlers === undefined) return;\n      handlers.forEach(handler => handler(e));\n    };\n    delegateHandler.displayName = 'evtdUnifiedWindowEventHandler';\n    return delegateHandler;\n  }\n  const unifiedHandler = createUnifiedHandler();\n  const unfiendWindowEventHandler = createUnifiedWindowEventHandler();\n  function ensureElToHandlers(phase, type) {\n    const phaseHandlers = phaseToTypeToElToHandlers[phase];\n    if (phaseHandlers[type] === undefined) {\n      phaseHandlers[type] = new Map();\n      window.addEventListener(type, unifiedHandler, phase === 'capture');\n    }\n    return phaseHandlers[type];\n  }\n  function ensureWindowEventHandlers(type) {\n    const windowEventHandlers = typeToWindowEventHandlers[type];\n    if (windowEventHandlers === undefined) {\n      typeToWindowEventHandlers[type] = new Set();\n      window.addEventListener(type, unfiendWindowEventHandler);\n    }\n    return typeToWindowEventHandlers[type];\n  }\n  function ensureHandlers(elToHandlers, el) {\n    let elHandlers = elToHandlers.get(el);\n    if (elHandlers === undefined) {\n      elToHandlers.set(el, elHandlers = new Set());\n    }\n    return elHandlers;\n  }\n  function handlerExist(el, phase, type, handler) {\n    const elToHandlers = phaseToTypeToElToHandlers[phase][type];\n    // phase ${type} event has handlers\n    if (elToHandlers !== undefined) {\n      const handlers = elToHandlers.get(el);\n      // phase using el with ${type} event has handlers\n      if (handlers !== undefined) {\n        if (handlers.has(handler)) return true;\n      }\n    }\n    return false;\n  }\n  function windowEventHandlerExist(type, handler) {\n    const handlers = typeToWindowEventHandlers[type];\n    if (handlers !== undefined) {\n      if (handlers.has(handler)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function on(type, el, handler, options) {\n    let mergedHandler;\n    if (typeof options === 'object' && options.once === true) {\n      mergedHandler = e => {\n        off(type, el, mergedHandler, options);\n        handler(e);\n      };\n    } else {\n      mergedHandler = handler;\n    }\n    const trapped = trapOn(type, el, mergedHandler, options);\n    if (trapped) return;\n    const phase = options === true || typeof options === 'object' && options.capture === true ? 'capture' : 'bubble';\n    const elToHandlers = ensureElToHandlers(phase, type);\n    const handlers = ensureHandlers(elToHandlers, el);\n    if (!handlers.has(mergedHandler)) handlers.add(mergedHandler);\n    if (el === window) {\n      const windowEventHandlers = ensureWindowEventHandlers(type);\n      if (!windowEventHandlers.has(mergedHandler)) {\n        windowEventHandlers.add(mergedHandler);\n      }\n    }\n  }\n  function off(type, el, handler, options) {\n    const trapped = trapOff(type, el, handler, options);\n    if (trapped) return;\n    const capture = options === true || typeof options === 'object' && options.capture === true;\n    const phase = capture ? 'capture' : 'bubble';\n    const elToHandlers = ensureElToHandlers(phase, type);\n    const handlers = ensureHandlers(elToHandlers, el);\n    if (el === window) {\n      const mirrorPhase = capture ? 'bubble' : 'capture';\n      if (!handlerExist(el, mirrorPhase, type, handler) && windowEventHandlerExist(type, handler)) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const windowEventHandlers = typeToWindowEventHandlers[type];\n        windowEventHandlers.delete(handler);\n        if (windowEventHandlers.size === 0) {\n          window.removeEventListener(type, unfiendWindowEventHandler);\n          typeToWindowEventHandlers[type] = undefined;\n        }\n      }\n    }\n    if (handlers.has(handler)) handlers.delete(handler);\n    if (handlers.size === 0) {\n      elToHandlers.delete(el);\n    }\n    if (elToHandlers.size === 0) {\n      window.removeEventListener(type, unifiedHandler, phase === 'capture');\n      phaseToTypeToElToHandlers[phase][type] = undefined;\n    }\n  }\n  return {\n    on: on,\n    off: off\n  };\n}\nconst {\n  on,\n  off\n} = createDelegate();\nexport { on, off };","map":{"version":3,"names":["trapOn","trapOff","getEventTarget","createDelegate","window","on","off","propagationStopped","WeakMap","immediatePropagationStopped","trackPropagation","set","trackImmediate","spy","event","propName","fn","source","apply","arguments","unspy","Event","prototype","currentTargets","currentTargetDescriptor","Object","getOwnPropertyDescriptor","getCurrentTarget","_a","get","defineCurrentTarget","getter","undefined","defineProperty","configurable","enumerable","phaseToTypeToElToHandlers","bubble","capture","typeToWindowEventHandlers","createUnifiedHandler","delegeteHandler","e","type","eventPhase","bubbles","target","phase","cursor","path","push","parentNode","captureElToHandlers","bubbleElToHandlers","i","length","has","handlers","handler","bubbleHandlers","displayName","createUnifiedWindowEventHandler","delegateHandler","forEach","unifiedHandler","unfiendWindowEventHandler","ensureElToHandlers","phaseHandlers","Map","addEventListener","ensureWindowEventHandlers","windowEventHandlers","Set","ensureHandlers","elToHandlers","el","elHandlers","handlerExist","windowEventHandlerExist","options","mergedHandler","once","trapped","add","mirrorPhase","delete","size","removeEventListener"],"sources":["/Users/elmo/Documents/GitHub/meetings_vue3/node_modules/evtd/es/delegate.js"],"sourcesContent":["import { trapOn, trapOff } from './traps';\nimport { getEventTarget } from './utils';\n// currently `once` and `passive` is not supported\nfunction createDelegate() {\n    if (typeof window === 'undefined') {\n        return {\n            on: () => { },\n            off: () => { }\n        };\n    }\n    const propagationStopped = new WeakMap();\n    const immediatePropagationStopped = new WeakMap();\n    function trackPropagation() {\n        propagationStopped.set(this, true);\n    }\n    function trackImmediate() {\n        propagationStopped.set(this, true);\n        immediatePropagationStopped.set(this, true);\n    }\n    function spy(event, propName, fn) {\n        const source = event[propName];\n        event[propName] = function () {\n            fn.apply(event, arguments);\n            return source.apply(event, arguments);\n        };\n        return event;\n    }\n    function unspy(event, propName) {\n        event[propName] = Event.prototype[propName];\n    }\n    const currentTargets = new WeakMap();\n    const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'currentTarget');\n    function getCurrentTarget() {\n        var _a;\n        return (_a = currentTargets.get(this)) !== null && _a !== void 0 ? _a : null;\n    }\n    function defineCurrentTarget(event, getter) {\n        if (currentTargetDescriptor === undefined)\n            return;\n        Object.defineProperty(event, 'currentTarget', {\n            configurable: true,\n            enumerable: true,\n            get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get\n        });\n    }\n    const phaseToTypeToElToHandlers = {\n        bubble: {},\n        capture: {}\n    };\n    const typeToWindowEventHandlers = {};\n    function createUnifiedHandler() {\n        const delegeteHandler = function (e) {\n            const { type, eventPhase, bubbles } = e;\n            const target = getEventTarget(e);\n            if (eventPhase === 2)\n                return;\n            const phase = eventPhase === 1 ? 'capture' : 'bubble';\n            let cursor = target;\n            const path = [];\n            // collecting bubble path\n            while (true) {\n                if (cursor === null)\n                    cursor = window;\n                path.push(cursor);\n                if (cursor === window) {\n                    break;\n                }\n                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n                cursor = (cursor.parentNode || null);\n            }\n            const captureElToHandlers = phaseToTypeToElToHandlers.capture[type];\n            const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type];\n            spy(e, 'stopPropagation', trackPropagation);\n            spy(e, 'stopImmediatePropagation', trackImmediate);\n            defineCurrentTarget(e, getCurrentTarget);\n            if (phase === 'capture') {\n                if (captureElToHandlers === undefined)\n                    return;\n                // capture\n                for (let i = path.length - 1; i >= 0; --i) {\n                    if (propagationStopped.has(e))\n                        break;\n                    const target = path[i];\n                    const handlers = captureElToHandlers.get(target);\n                    if (handlers !== undefined) {\n                        currentTargets.set(e, target);\n                        for (const handler of handlers) {\n                            if (immediatePropagationStopped.has(e))\n                                break;\n                            handler(e);\n                        }\n                    }\n                    if (i === 0 && !bubbles && bubbleElToHandlers !== undefined) {\n                        const bubbleHandlers = bubbleElToHandlers.get(target);\n                        if (bubbleHandlers !== undefined) {\n                            for (const handler of bubbleHandlers) {\n                                if (immediatePropagationStopped.has(e))\n                                    break;\n                                handler(e);\n                            }\n                        }\n                    }\n                }\n            }\n            else if (phase === 'bubble') {\n                if (bubbleElToHandlers === undefined)\n                    return;\n                // bubble\n                for (let i = 0; i < path.length; ++i) {\n                    if (propagationStopped.has(e))\n                        break;\n                    const target = path[i];\n                    const handlers = bubbleElToHandlers.get(target);\n                    if (handlers !== undefined) {\n                        currentTargets.set(e, target);\n                        for (const handler of handlers) {\n                            if (immediatePropagationStopped.has(e))\n                                break;\n                            handler(e);\n                        }\n                    }\n                }\n            }\n            unspy(e, 'stopPropagation');\n            unspy(e, 'stopImmediatePropagation');\n            defineCurrentTarget(e);\n        };\n        delegeteHandler.displayName = 'evtdUnifiedHandler';\n        return delegeteHandler;\n    }\n    function createUnifiedWindowEventHandler() {\n        const delegateHandler = function (e) {\n            const { type, eventPhase } = e;\n            if (eventPhase !== 2)\n                return;\n            const handlers = typeToWindowEventHandlers[type];\n            if (handlers === undefined)\n                return;\n            handlers.forEach((handler) => handler(e));\n        };\n        delegateHandler.displayName = 'evtdUnifiedWindowEventHandler';\n        return delegateHandler;\n    }\n    const unifiedHandler = createUnifiedHandler();\n    const unfiendWindowEventHandler = createUnifiedWindowEventHandler();\n    function ensureElToHandlers(phase, type) {\n        const phaseHandlers = phaseToTypeToElToHandlers[phase];\n        if (phaseHandlers[type] === undefined) {\n            phaseHandlers[type] = new Map();\n            window.addEventListener(type, unifiedHandler, phase === 'capture');\n        }\n        return phaseHandlers[type];\n    }\n    function ensureWindowEventHandlers(type) {\n        const windowEventHandlers = typeToWindowEventHandlers[type];\n        if (windowEventHandlers === undefined) {\n            typeToWindowEventHandlers[type] = new Set();\n            window.addEventListener(type, unfiendWindowEventHandler);\n        }\n        return typeToWindowEventHandlers[type];\n    }\n    function ensureHandlers(elToHandlers, el) {\n        let elHandlers = elToHandlers.get(el);\n        if (elHandlers === undefined) {\n            elToHandlers.set(el, (elHandlers = new Set()));\n        }\n        return elHandlers;\n    }\n    function handlerExist(el, phase, type, handler) {\n        const elToHandlers = phaseToTypeToElToHandlers[phase][type];\n        // phase ${type} event has handlers\n        if (elToHandlers !== undefined) {\n            const handlers = elToHandlers.get(el);\n            // phase using el with ${type} event has handlers\n            if (handlers !== undefined) {\n                if (handlers.has(handler))\n                    return true;\n            }\n        }\n        return false;\n    }\n    function windowEventHandlerExist(type, handler) {\n        const handlers = typeToWindowEventHandlers[type];\n        if (handlers !== undefined) {\n            if (handlers.has(handler)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function on(type, el, handler, options) {\n        let mergedHandler;\n        if (typeof options === 'object' && options.once === true) {\n            mergedHandler = (e) => {\n                off(type, el, mergedHandler, options);\n                handler(e);\n            };\n        }\n        else {\n            mergedHandler = handler;\n        }\n        const trapped = trapOn(type, el, mergedHandler, options);\n        if (trapped)\n            return;\n        const phase = options === true ||\n            (typeof options === 'object' && options.capture === true)\n            ? 'capture'\n            : 'bubble';\n        const elToHandlers = ensureElToHandlers(phase, type);\n        const handlers = ensureHandlers(elToHandlers, el);\n        if (!handlers.has(mergedHandler))\n            handlers.add(mergedHandler);\n        if (el === window) {\n            const windowEventHandlers = ensureWindowEventHandlers(type);\n            if (!windowEventHandlers.has(mergedHandler)) {\n                windowEventHandlers.add(mergedHandler);\n            }\n        }\n    }\n    function off(type, el, handler, options) {\n        const trapped = trapOff(type, el, handler, options);\n        if (trapped)\n            return;\n        const capture = options === true ||\n            (typeof options === 'object' && options.capture === true);\n        const phase = capture ? 'capture' : 'bubble';\n        const elToHandlers = ensureElToHandlers(phase, type);\n        const handlers = ensureHandlers(elToHandlers, el);\n        if (el === window) {\n            const mirrorPhase = capture ? 'bubble' : 'capture';\n            if (!handlerExist(el, mirrorPhase, type, handler) &&\n                windowEventHandlerExist(type, handler)) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const windowEventHandlers = typeToWindowEventHandlers[type];\n                windowEventHandlers.delete(handler);\n                if (windowEventHandlers.size === 0) {\n                    window.removeEventListener(type, unfiendWindowEventHandler);\n                    typeToWindowEventHandlers[type] = undefined;\n                }\n            }\n        }\n        if (handlers.has(handler))\n            handlers.delete(handler);\n        if (handlers.size === 0) {\n            elToHandlers.delete(el);\n        }\n        if (elToHandlers.size === 0) {\n            window.removeEventListener(type, unifiedHandler, phase === 'capture');\n            phaseToTypeToElToHandlers[phase][type] = undefined;\n        }\n    }\n    return {\n        on: on,\n        off: off\n    };\n}\nconst { on, off } = createDelegate();\nexport { on, off };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}