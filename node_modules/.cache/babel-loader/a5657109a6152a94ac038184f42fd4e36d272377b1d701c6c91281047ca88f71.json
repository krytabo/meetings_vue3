{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { h, ref, defineComponent, computed, provide, watch, toRef, nextTick, withDirectives, vShow, watchEffect, cloneVNode, TransitionGroup } from 'vue';\nimport { VResizeObserver, VXScroll } from 'vueuc';\nimport { throttle } from 'lodash-es';\nimport { useCompitable, onFontsReady, useMergedState } from 'vooks';\nimport { useConfig, useTheme, useThemeClass } from '../../_mixins';\nimport { createKey, call, flatten, warnOnce, resolveWrappedSlot } from '../../_utils';\nimport { tabsLight } from '../styles';\nimport { tabsInjectionKey } from './interface';\nimport Tab from './Tab';\nimport style from './styles/index.cssr';\nexport const tabsProps = Object.assign(Object.assign({}, useTheme.props), {\n  value: [String, Number],\n  defaultValue: [String, Number],\n  trigger: {\n    type: String,\n    default: 'click'\n  },\n  type: {\n    type: String,\n    default: 'bar'\n  },\n  closable: Boolean,\n  justifyContent: String,\n  size: {\n    type: String,\n    default: 'medium'\n  },\n  tabStyle: [String, Object],\n  barWidth: Number,\n  paneClass: String,\n  paneStyle: [String, Object],\n  addable: [Boolean, Object],\n  tabsPadding: {\n    type: Number,\n    default: 0\n  },\n  animated: Boolean,\n  onBeforeLeave: Function,\n  onAdd: Function,\n  'onUpdate:value': [Function, Array],\n  onUpdateValue: [Function, Array],\n  onClose: [Function, Array],\n  // deprecated\n  labelSize: String,\n  activeName: [String, Number],\n  onActiveNameChange: [Function, Array]\n});\nexport default defineComponent({\n  name: 'Tabs',\n  props: tabsProps,\n  setup(props, {\n    slots\n  }) {\n    var _a, _b, _c, _d;\n    if (process.env.NODE_ENV !== 'production') {\n      watchEffect(() => {\n        if (props.labelSize !== undefined) {\n          warnOnce('tabs', '`label-size` is deprecated, please use `size` instead.');\n        }\n        if (props.activeName !== undefined) {\n          warnOnce('tabs', '`active-name` is deprecated, please use `value` instead.');\n        }\n        if (props.onActiveNameChange !== undefined) {\n          warnOnce('tabs', '`on-active-name-change` is deprecated, please use `on-update:value` instead.');\n        }\n      });\n    }\n    const {\n      mergedClsPrefixRef,\n      inlineThemeDisabled\n    } = useConfig(props);\n    const themeRef = useTheme('Tabs', '-tabs', style, tabsLight, props, mergedClsPrefixRef);\n    const tabsElRef = ref(null);\n    const barElRef = ref(null);\n    const scrollWrapperElRef = ref(null);\n    const addTabInstRef = ref(null);\n    const xScrollInstRef = ref(null);\n    const leftReachedRef = ref(true);\n    const rightReachedRef = ref(true);\n    const compitableSizeRef = useCompitable(props, ['labelSize', 'size']);\n    const compitableValueRef = useCompitable(props, ['activeName', 'value']);\n    const uncontrolledValueRef = ref((_b = (_a = compitableValueRef.value) !== null && _a !== void 0 ? _a : props.defaultValue) !== null && _b !== void 0 ? _b : slots.default ? (_d = (_c = flatten(slots.default())[0]) === null || _c === void 0 ? void 0 : _c.props) === null || _d === void 0 ? void 0 : _d.name : null);\n    const mergedValueRef = useMergedState(compitableValueRef, uncontrolledValueRef);\n    const tabChangeIdRef = {\n      id: 0\n    };\n    const tabWrapperStyleRef = computed(() => {\n      if (!props.justifyContent || props.type === 'card') return undefined;\n      return {\n        display: 'flex',\n        justifyContent: props.justifyContent\n      };\n    });\n    watch(mergedValueRef, () => {\n      tabChangeIdRef.id = 0;\n      updateCurrentBarStyle();\n      updateCurrentScrollPosition(true);\n    });\n    function getCurrentEl() {\n      var _a;\n      const {\n        value\n      } = mergedValueRef;\n      if (value === null) return null;\n      const tabEl = (_a = tabsElRef.value) === null || _a === void 0 ? void 0 : _a.querySelector(`[data-name=\"${value}\"]`);\n      return tabEl;\n    }\n    function updateBarStyle(tabEl) {\n      if (props.type === 'card') return;\n      const {\n        value: barEl\n      } = barElRef;\n      if (!barEl) return;\n      if (tabEl) {\n        const disabledClassName = `${mergedClsPrefixRef.value}-tabs-bar--disabled`;\n        const {\n          barWidth\n        } = props;\n        if (tabEl.dataset.disabled === 'true') {\n          barEl.classList.add(disabledClassName);\n        } else {\n          barEl.classList.remove(disabledClassName);\n        }\n        if (typeof barWidth === 'number' && tabEl.offsetWidth >= barWidth) {\n          const offsetDiffLeft = Math.floor((tabEl.offsetWidth - barWidth) / 2) + tabEl.offsetLeft;\n          barEl.style.left = `${offsetDiffLeft}px`;\n          barEl.style.maxWidth = `${barWidth}px`;\n        } else {\n          barEl.style.left = `${tabEl.offsetLeft}px`;\n          barEl.style.maxWidth = `${tabEl.offsetWidth}px`;\n        }\n        barEl.style.width = '8192px';\n        void barEl.offsetWidth;\n      }\n    }\n    function updateCurrentBarStyle() {\n      if (props.type === 'card') return;\n      const tabEl = getCurrentEl();\n      if (tabEl) {\n        updateBarStyle(tabEl);\n      }\n    }\n    function updateCurrentScrollPosition(smooth) {\n      var _a;\n      const scrollWrapperEl = (_a = xScrollInstRef.value) === null || _a === void 0 ? void 0 : _a.$el;\n      if (!scrollWrapperEl) return;\n      const tabEl = getCurrentEl();\n      if (!tabEl) return;\n      const {\n        scrollLeft: scrollWrapperElScrollLeft,\n        offsetWidth: scrollWrapperElOffsetWidth\n      } = scrollWrapperEl;\n      const {\n        offsetLeft: tabElOffsetLeft,\n        offsetWidth: tabElOffsetWidth\n      } = tabEl;\n      if (scrollWrapperElScrollLeft > tabElOffsetLeft) {\n        scrollWrapperEl.scrollTo({\n          top: 0,\n          left: tabElOffsetLeft,\n          behavior: 'smooth'\n        });\n      } else if (tabElOffsetLeft + tabElOffsetWidth > scrollWrapperElScrollLeft + scrollWrapperElOffsetWidth) {\n        scrollWrapperEl.scrollTo({\n          top: 0,\n          left: tabElOffsetLeft + tabElOffsetWidth - scrollWrapperElOffsetWidth,\n          behavior: 'smooth'\n        });\n      }\n    }\n    const tabsPaneWrapperRef = ref(null);\n    let fromHeight = 0;\n    let hangingTransition = null;\n    function onAnimationBeforeLeave(el) {\n      const tabsPaneWrapperEl = tabsPaneWrapperRef.value;\n      if (tabsPaneWrapperEl) {\n        fromHeight = el.getBoundingClientRect().height;\n        const fromHeightPx = `${fromHeight}px`;\n        const applyFromStyle = () => {\n          tabsPaneWrapperEl.style.height = fromHeightPx;\n          tabsPaneWrapperEl.style.maxHeight = fromHeightPx;\n        };\n        if (!hangingTransition) {\n          hangingTransition = applyFromStyle;\n        } else {\n          applyFromStyle();\n          hangingTransition();\n          hangingTransition = null;\n        }\n      }\n    }\n    function onAnimationEnter(el) {\n      const tabsPaneWrapperEl = tabsPaneWrapperRef.value;\n      if (tabsPaneWrapperEl) {\n        const targetHeight = el.getBoundingClientRect().height;\n        const applyTargetStyle = () => {\n          void document.body.offsetHeight;\n          tabsPaneWrapperEl.style.maxHeight = `${targetHeight}px`;\n          tabsPaneWrapperEl.style.height = `${Math.max(fromHeight, targetHeight)}px`;\n        };\n        if (!hangingTransition) {\n          hangingTransition = applyTargetStyle;\n        } else {\n          hangingTransition();\n          hangingTransition = null;\n          applyTargetStyle();\n        }\n      }\n    }\n    function onAnimationAfterEnter() {\n      const tabsPaneWrapperEl = tabsPaneWrapperRef.value;\n      if (tabsPaneWrapperEl) {\n        tabsPaneWrapperEl.style.maxHeight = '';\n        tabsPaneWrapperEl.style.height = '';\n      }\n    }\n    const renderNameListRef = {\n      value: []\n    };\n    const animationDirectionRef = ref('next');\n    function activateTab(panelName) {\n      const currentValue = mergedValueRef.value;\n      let dir = 'next';\n      for (const name of renderNameListRef.value) {\n        if (name === currentValue) {\n          break;\n        }\n        if (name === panelName) {\n          dir = 'prev';\n          break;\n        }\n      }\n      animationDirectionRef.value = dir;\n      doUpdateValue(panelName);\n    }\n    function doUpdateValue(panelName) {\n      const {\n        onActiveNameChange,\n        onUpdateValue,\n        'onUpdate:value': _onUpdateValue\n      } = props;\n      if (onActiveNameChange) {\n        call(onActiveNameChange, panelName);\n      }\n      if (onUpdateValue) call(onUpdateValue, panelName);\n      if (_onUpdateValue) call(_onUpdateValue, panelName);\n      uncontrolledValueRef.value = panelName;\n    }\n    function handleClose(panelName) {\n      const {\n        onClose\n      } = props;\n      if (onClose) call(onClose, panelName);\n    }\n    let firstTimeUpdatePosition = true;\n    function updateBarPositionInstantly() {\n      const {\n        value: barEl\n      } = barElRef;\n      if (!barEl) return;\n      if (!firstTimeUpdatePosition) firstTimeUpdatePosition = false;\n      const disableTransitionClassName = 'transition-disabled';\n      barEl.classList.add(disableTransitionClassName);\n      updateCurrentBarStyle();\n      // here we don't need to force layout after update bar style\n      // since deriveScrollShadow will force layout\n      barEl.classList.remove(disableTransitionClassName);\n    }\n    let memorizedWidth = 0;\n    function _handleNavResize(entry) {\n      var _a, _b;\n      if (entry.contentRect.width === 0 && entry.contentRect.height === 0) {\n        return;\n      }\n      if (memorizedWidth === entry.contentRect.width) {\n        return;\n      }\n      memorizedWidth = entry.contentRect.width;\n      const {\n        type\n      } = props;\n      if (type === 'line' || type === 'bar') {\n        if (firstTimeUpdatePosition || ((_a = props.justifyContent) === null || _a === void 0 ? void 0 : _a.startsWith('space'))) {\n          updateBarPositionInstantly();\n        }\n      }\n      if (type !== 'segment') {\n        deriveScrollShadow((_b = xScrollInstRef.value) === null || _b === void 0 ? void 0 : _b.$el);\n      }\n    }\n    const handleNavResize = throttle(_handleNavResize, 64);\n    watch([() => props.justifyContent, () => props.size], () => {\n      void nextTick(() => {\n        const {\n          type\n        } = props;\n        if (type === 'line' || type === 'bar') {\n          updateBarPositionInstantly();\n        }\n      });\n    });\n    const addTabFixedRef = ref(false);\n    function _handleTabsResize(entry) {\n      var _a;\n      const {\n        target,\n        contentRect: {\n          width\n        }\n      } = entry;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const containerWidth = target.parentElement.offsetWidth;\n      if (!addTabFixedRef.value) {\n        if (containerWidth < width) {\n          addTabFixedRef.value = true;\n        }\n      } else {\n        const {\n          value: addTabInst\n        } = addTabInstRef;\n        if (!addTabInst) return;\n        if (containerWidth - width > addTabInst.$el.offsetWidth) {\n          addTabFixedRef.value = false;\n        }\n      }\n      deriveScrollShadow((_a = xScrollInstRef.value) === null || _a === void 0 ? void 0 : _a.$el);\n    }\n    const handleTabsResize = throttle(_handleTabsResize, 64);\n    function handleAdd() {\n      const {\n        onAdd\n      } = props;\n      if (onAdd) onAdd();\n      void nextTick(() => {\n        const currentEl = getCurrentEl();\n        const {\n          value: xScrollInst\n        } = xScrollInstRef;\n        if (!currentEl || !xScrollInst) return;\n        xScrollInst.scrollTo({\n          left: currentEl.offsetLeft,\n          top: 0,\n          behavior: 'smooth'\n        });\n      });\n    }\n    function deriveScrollShadow(el) {\n      if (!el) return;\n      const {\n        scrollLeft,\n        scrollWidth,\n        offsetWidth\n      } = el;\n      leftReachedRef.value = scrollLeft <= 0;\n      rightReachedRef.value = scrollLeft + offsetWidth >= scrollWidth;\n    }\n    const handleScroll = throttle(e => {\n      deriveScrollShadow(e.target);\n    }, 64);\n    provide(tabsInjectionKey, {\n      triggerRef: toRef(props, 'trigger'),\n      tabStyleRef: toRef(props, 'tabStyle'),\n      paneClassRef: toRef(props, 'paneClass'),\n      paneStyleRef: toRef(props, 'paneStyle'),\n      mergedClsPrefixRef,\n      typeRef: toRef(props, 'type'),\n      closableRef: toRef(props, 'closable'),\n      valueRef: mergedValueRef,\n      tabChangeIdRef,\n      onBeforeLeaveRef: toRef(props, 'onBeforeLeave'),\n      activateTab,\n      handleClose,\n      handleAdd\n    });\n    onFontsReady(() => {\n      updateCurrentBarStyle();\n      updateCurrentScrollPosition(true);\n    });\n    // avoid useless rerender\n    watchEffect(() => {\n      const {\n        value: el\n      } = scrollWrapperElRef;\n      if (!el) return;\n      const {\n        value: clsPrefix\n      } = mergedClsPrefixRef;\n      const shadowBeforeClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-before`;\n      const shadowAfterClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-after`;\n      if (leftReachedRef.value) {\n        el.classList.remove(shadowBeforeClass);\n      } else {\n        el.classList.add(shadowBeforeClass);\n      }\n      if (rightReachedRef.value) {\n        el.classList.remove(shadowAfterClass);\n      } else {\n        el.classList.add(shadowAfterClass);\n      }\n    });\n    const tabsRailElRef = ref(null);\n    watch(mergedValueRef, () => {\n      if (props.type === 'segment') {\n        const tabsRailEl = tabsRailElRef.value;\n        if (tabsRailEl) {\n          void nextTick(() => {\n            tabsRailEl.classList.add('transition-disabled');\n            void tabsRailEl.offsetWidth;\n            tabsRailEl.classList.remove('transition-disabled');\n          });\n        }\n      }\n    });\n    const exposedMethods = {\n      syncBarPosition: () => {\n        updateCurrentBarStyle();\n      }\n    };\n    const cssVarsRef = computed(() => {\n      const {\n        value: size\n      } = compitableSizeRef;\n      const {\n        type\n      } = props;\n      const typeSuffix = {\n        card: 'Card',\n        bar: 'Bar',\n        line: 'Line',\n        segment: 'Segment'\n      }[type];\n      const sizeType = `${size}${typeSuffix}`;\n      const {\n        self: {\n          barColor,\n          closeIconColor,\n          closeIconColorHover,\n          closeIconColorPressed,\n          tabColor,\n          tabBorderColor,\n          paneTextColor,\n          tabFontWeight,\n          tabBorderRadius,\n          tabFontWeightActive,\n          colorSegment,\n          fontWeightStrong,\n          tabColorSegment,\n          closeSize,\n          closeIconSize,\n          closeColorHover,\n          closeColorPressed,\n          closeBorderRadius,\n          [createKey('panePadding', size)]: panePadding,\n          [createKey('tabPadding', sizeType)]: tabPadding,\n          [createKey('tabGap', sizeType)]: tabGap,\n          [createKey('tabTextColor', type)]: tabTextColor,\n          [createKey('tabTextColorActive', type)]: tabTextColorActive,\n          [createKey('tabTextColorHover', type)]: tabTextColorHover,\n          [createKey('tabTextColorDisabled', type)]: tabTextColorDisabled,\n          [createKey('tabFontSize', size)]: tabFontSize\n        },\n        common: {\n          cubicBezierEaseInOut\n        }\n      } = themeRef.value;\n      return {\n        '--n-bezier': cubicBezierEaseInOut,\n        '--n-color-segment': colorSegment,\n        '--n-bar-color': barColor,\n        '--n-tab-font-size': tabFontSize,\n        '--n-tab-text-color': tabTextColor,\n        '--n-tab-text-color-active': tabTextColorActive,\n        '--n-tab-text-color-disabled': tabTextColorDisabled,\n        '--n-tab-text-color-hover': tabTextColorHover,\n        '--n-pane-text-color': paneTextColor,\n        '--n-tab-border-color': tabBorderColor,\n        '--n-tab-border-radius': tabBorderRadius,\n        '--n-close-size': closeSize,\n        '--n-close-icon-size': closeIconSize,\n        '--n-close-color-hover': closeColorHover,\n        '--n-close-color-pressed': closeColorPressed,\n        '--n-close-border-radius': closeBorderRadius,\n        '--n-close-icon-color': closeIconColor,\n        '--n-close-icon-color-hover': closeIconColorHover,\n        '--n-close-icon-color-pressed': closeIconColorPressed,\n        '--n-tab-color': tabColor,\n        '--n-tab-font-weight': tabFontWeight,\n        '--n-tab-font-weight-active': tabFontWeightActive,\n        '--n-tab-padding': tabPadding,\n        '--n-tab-gap': tabGap,\n        '--n-pane-padding': panePadding,\n        '--n-font-weight-strong': fontWeightStrong,\n        '--n-tab-color-segment': tabColorSegment\n      };\n    });\n    const themeClassHandle = inlineThemeDisabled ? useThemeClass('tabs', computed(() => {\n      return `${compitableSizeRef.value[0]}${props.type[0]}`;\n    }), cssVarsRef, props) : undefined;\n    return Object.assign({\n      mergedClsPrefix: mergedClsPrefixRef,\n      mergedValue: mergedValueRef,\n      renderedNames: new Set(),\n      tabsRailElRef,\n      tabsPaneWrapperRef,\n      tabsElRef,\n      barElRef,\n      addTabInstRef,\n      xScrollInstRef,\n      scrollWrapperElRef,\n      addTabFixed: addTabFixedRef,\n      tabWrapperStyle: tabWrapperStyleRef,\n      handleNavResize,\n      mergedSize: compitableSizeRef,\n      handleScroll,\n      handleTabsResize,\n      cssVars: inlineThemeDisabled ? undefined : cssVarsRef,\n      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,\n      animationDirection: animationDirectionRef,\n      renderNameListRef,\n      onAnimationBeforeLeave,\n      onAnimationEnter,\n      onAnimationAfterEnter,\n      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender\n    }, exposedMethods);\n  },\n  render() {\n    const {\n      mergedClsPrefix,\n      type,\n      addTabFixed,\n      addable,\n      mergedSize,\n      renderNameListRef,\n      onRender,\n      $slots: {\n        default: defaultSlot,\n        prefix: prefixSlot,\n        suffix: suffixSlot\n      }\n    } = this;\n    onRender === null || onRender === void 0 ? void 0 : onRender();\n    const tabPaneChildren = defaultSlot ? flatten(defaultSlot()).filter(v => {\n      return v.type.__TAB_PANE__ === true;\n    }) : [];\n    const tabChildren = defaultSlot ? flatten(defaultSlot()).filter(v => {\n      return v.type.__TAB__ === true;\n    }) : [];\n    const showPane = !tabChildren.length;\n    const isCard = type === 'card';\n    const isSegment = type === 'segment';\n    const mergedJustifyContent = !isCard && !isSegment && this.justifyContent;\n    renderNameListRef.value = [];\n    return h(\"div\", {\n      class: [`${mergedClsPrefix}-tabs`, this.themeClass, `${mergedClsPrefix}-tabs--${type}-type`, `${mergedClsPrefix}-tabs--${mergedSize}-size`, mergedJustifyContent && `${mergedClsPrefix}-tabs--flex`],\n      style: this.cssVars\n    }, h(\"div\", {\n      class: [\n      // the class should be applied here since it's possible\n      // to make tabs nested in tabs, style may influence each\n      // other. adding a class will make it easy to write the\n      // style.\n      `${mergedClsPrefix}-tabs-nav--${type}-type`, `${mergedClsPrefix}-tabs-nav`]\n    }, resolveWrappedSlot(prefixSlot, children => children && h(\"div\", {\n      class: `${mergedClsPrefix}-tabs-nav__prefix`\n    }, children)), isSegment ? h(\"div\", {\n      class: `${mergedClsPrefix}-tabs-rail`,\n      ref: \"tabsRailElRef\"\n    }, showPane ? tabPaneChildren.map((tabPaneVNode, index) => {\n      renderNameListRef.value.push(tabPaneVNode.props.name);\n      return h(Tab, Object.assign({}, tabPaneVNode.props, {\n        internalCreatedByPane: true,\n        internalLeftPadded: index !== 0\n      }), tabPaneVNode.children ? {\n        default: tabPaneVNode.children.tab\n      } : undefined);\n    }) : tabChildren.map((tabVNode, index) => {\n      renderNameListRef.value.push(tabVNode.props.name);\n      if (index === 0) {\n        return tabVNode;\n      } else {\n        return createLeftPaddedTabVNode(tabVNode);\n      }\n    })) : h(VResizeObserver, {\n      onResize: this.handleNavResize\n    }, {\n      default: () => h(\"div\", {\n        class: `${mergedClsPrefix}-tabs-nav-scroll-wrapper`,\n        ref: \"scrollWrapperElRef\"\n      }, h(VXScroll, {\n        ref: \"xScrollInstRef\",\n        onScroll: this.handleScroll\n      }, {\n        default: () => {\n          const rawWrappedTabs = h(\"div\", {\n            style: this.tabWrapperStyle,\n            class: `${mergedClsPrefix}-tabs-wrapper`\n          }, mergedJustifyContent ? null : h(\"div\", {\n            class: `${mergedClsPrefix}-tabs-scroll-padding`,\n            style: {\n              width: `${this.tabsPadding}px`\n            }\n          }), showPane ? tabPaneChildren.map((tabPaneVNode, index) => {\n            renderNameListRef.value.push(tabPaneVNode.props.name);\n            return justifyTabDynamicProps(h(Tab, Object.assign({}, tabPaneVNode.props, {\n              internalCreatedByPane: true,\n              internalLeftPadded: index !== 0 && (!mergedJustifyContent || mergedJustifyContent === 'center' || mergedJustifyContent === 'start' || mergedJustifyContent === 'end')\n            }), tabPaneVNode.children ? {\n              default: tabPaneVNode.children.tab\n            } : undefined));\n          }) : tabChildren.map((tabVNode, index) => {\n            renderNameListRef.value.push(tabVNode.props.name);\n            if (index !== 0 && !mergedJustifyContent) {\n              return justifyTabDynamicProps(createLeftPaddedTabVNode(tabVNode));\n            } else {\n              return justifyTabDynamicProps(tabVNode);\n            }\n          }), !addTabFixed && addable && isCard ? createAddTag(addable, (showPane ? tabPaneChildren.length : tabChildren.length) !== 0) : null, mergedJustifyContent ? null : h(\"div\", {\n            class: `${mergedClsPrefix}-tabs-scroll-padding`,\n            style: {\n              width: `${this.tabsPadding}px`\n            }\n          }));\n          let wrappedTabs = rawWrappedTabs;\n          if (isCard && addable) {\n            wrappedTabs = h(VResizeObserver, {\n              onResize: this.handleTabsResize\n            }, {\n              default: () => rawWrappedTabs\n            });\n          }\n          return h(\"div\", {\n            ref: \"tabsElRef\",\n            class: `${mergedClsPrefix}-tabs-nav-scroll-content`\n          }, wrappedTabs, isCard ? h(\"div\", {\n            class: `${mergedClsPrefix}-tabs-pad`\n          }) : null, isCard ? null : h(\"div\", {\n            ref: \"barElRef\",\n            class: `${mergedClsPrefix}-tabs-bar`\n          }));\n        }\n      }))\n    }), addTabFixed && addable && isCard ? createAddTag(addable, true) : null, resolveWrappedSlot(suffixSlot, children => children && h(\"div\", {\n      class: `${mergedClsPrefix}-tabs-nav__suffix`\n    }, children))), showPane && (this.animated ? h(\"div\", {\n      ref: \"tabsPaneWrapperRef\",\n      class: `${mergedClsPrefix}-tabs-pane-wrapper`\n    }, filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames, this.onAnimationBeforeLeave, this.onAnimationEnter, this.onAnimationAfterEnter, this.animationDirection)) : filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames)));\n  }\n});\nfunction filterMapTabPanes(tabPaneVNodes, value, renderedNames, onBeforeLeave, onEnter, onAfterEnter, animationDirection) {\n  const children = [];\n  tabPaneVNodes.forEach(vNode => {\n    const {\n      name,\n      displayDirective,\n      'display-directive': _displayDirective\n    } = vNode.props;\n    const matchDisplayDirective = directive => displayDirective === directive || _displayDirective === directive;\n    const show = value === name;\n    if (vNode.key !== undefined) {\n      vNode.key = name;\n    }\n    if (show || matchDisplayDirective('show') || matchDisplayDirective('show:lazy') && renderedNames.has(name)) {\n      if (!renderedNames.has(name)) {\n        renderedNames.add(name);\n      }\n      const useVShow = !matchDisplayDirective('if');\n      children.push(useVShow ? withDirectives(vNode, [[vShow, show]]) : vNode);\n    }\n  });\n  if (!animationDirection) {\n    return children;\n  }\n  return h(TransitionGroup, {\n    name: `${animationDirection}-transition`,\n    onBeforeLeave: onBeforeLeave,\n    onEnter: onEnter,\n    onAfterEnter: onAfterEnter\n  }, {\n    default: () => children\n  });\n}\nfunction createAddTag(addable, internalLeftPadded) {\n  return h(Tab, {\n    ref: \"addTabInstRef\",\n    key: \"__addable\",\n    name: \"__addable\",\n    internalCreatedByPane: true,\n    internalAddable: true,\n    internalLeftPadded: internalLeftPadded,\n    disabled: typeof addable === 'object' && addable.disabled\n  });\n}\nfunction createLeftPaddedTabVNode(tabVNode) {\n  const modifiedVNode = cloneVNode(tabVNode);\n  if (modifiedVNode.props) {\n    modifiedVNode.props.internalLeftPadded = true;\n  } else {\n    modifiedVNode.props = {\n      internalLeftPadded: true\n    };\n  }\n  return modifiedVNode;\n}\nfunction justifyTabDynamicProps(tabVNode) {\n  if (Array.isArray(tabVNode.dynamicProps)) {\n    if (!tabVNode.dynamicProps.includes('internalLeftPadded')) {\n      tabVNode.dynamicProps.push('internalLeftPadded');\n    }\n  } else {\n    tabVNode.dynamicProps = ['internalLeftPadded'];\n  }\n  return tabVNode;\n}","map":{"version":3,"names":["h","ref","defineComponent","computed","provide","watch","toRef","nextTick","withDirectives","vShow","watchEffect","cloneVNode","TransitionGroup","VResizeObserver","VXScroll","throttle","useCompitable","onFontsReady","useMergedState","useConfig","useTheme","useThemeClass","createKey","call","flatten","warnOnce","resolveWrappedSlot","tabsLight","tabsInjectionKey","Tab","style","tabsProps","Object","assign","props","value","String","Number","defaultValue","trigger","type","default","closable","Boolean","justifyContent","size","tabStyle","barWidth","paneClass","paneStyle","addable","tabsPadding","animated","onBeforeLeave","Function","onAdd","Array","onUpdateValue","onClose","labelSize","activeName","onActiveNameChange","name","setup","slots","_a","_b","_c","_d","process","env","NODE_ENV","undefined","mergedClsPrefixRef","inlineThemeDisabled","themeRef","tabsElRef","barElRef","scrollWrapperElRef","addTabInstRef","xScrollInstRef","leftReachedRef","rightReachedRef","compitableSizeRef","compitableValueRef","uncontrolledValueRef","mergedValueRef","tabChangeIdRef","id","tabWrapperStyleRef","display","updateCurrentBarStyle","updateCurrentScrollPosition","getCurrentEl","tabEl","querySelector","updateBarStyle","barEl","disabledClassName","dataset","disabled","classList","add","remove","offsetWidth","offsetDiffLeft","Math","floor","offsetLeft","left","maxWidth","width","smooth","scrollWrapperEl","$el","scrollLeft","scrollWrapperElScrollLeft","scrollWrapperElOffsetWidth","tabElOffsetLeft","tabElOffsetWidth","scrollTo","top","behavior","tabsPaneWrapperRef","fromHeight","hangingTransition","onAnimationBeforeLeave","el","tabsPaneWrapperEl","getBoundingClientRect","height","fromHeightPx","applyFromStyle","maxHeight","onAnimationEnter","targetHeight","applyTargetStyle","document","body","offsetHeight","max","onAnimationAfterEnter","renderNameListRef","animationDirectionRef","activateTab","panelName","currentValue","dir","doUpdateValue","_onUpdateValue","handleClose","firstTimeUpdatePosition","updateBarPositionInstantly","disableTransitionClassName","memorizedWidth","_handleNavResize","entry","contentRect","startsWith","deriveScrollShadow","handleNavResize","addTabFixedRef","_handleTabsResize","target","containerWidth","parentElement","addTabInst","handleTabsResize","handleAdd","currentEl","xScrollInst","scrollWidth","handleScroll","e","triggerRef","tabStyleRef","paneClassRef","paneStyleRef","typeRef","closableRef","valueRef","onBeforeLeaveRef","clsPrefix","shadowBeforeClass","shadowAfterClass","tabsRailElRef","tabsRailEl","exposedMethods","syncBarPosition","cssVarsRef","typeSuffix","card","bar","line","segment","sizeType","self","barColor","closeIconColor","closeIconColorHover","closeIconColorPressed","tabColor","tabBorderColor","paneTextColor","tabFontWeight","tabBorderRadius","tabFontWeightActive","colorSegment","fontWeightStrong","tabColorSegment","closeSize","closeIconSize","closeColorHover","closeColorPressed","closeBorderRadius","panePadding","tabPadding","tabGap","tabTextColor","tabTextColorActive","tabTextColorHover","tabTextColorDisabled","tabFontSize","common","cubicBezierEaseInOut","themeClassHandle","mergedClsPrefix","mergedValue","renderedNames","Set","addTabFixed","tabWrapperStyle","mergedSize","cssVars","themeClass","animationDirection","onRender","render","$slots","defaultSlot","prefix","prefixSlot","suffix","suffixSlot","tabPaneChildren","filter","v","__TAB_PANE__","tabChildren","__TAB__","showPane","length","isCard","isSegment","mergedJustifyContent","class","children","map","tabPaneVNode","index","push","internalCreatedByPane","internalLeftPadded","tab","tabVNode","createLeftPaddedTabVNode","onResize","onScroll","rawWrappedTabs","justifyTabDynamicProps","createAddTag","wrappedTabs","filterMapTabPanes","tabPaneVNodes","onEnter","onAfterEnter","forEach","vNode","displayDirective","_displayDirective","matchDisplayDirective","directive","show","key","has","useVShow","internalAddable","modifiedVNode","isArray","dynamicProps","includes"],"sources":["/Users/elmo/Documents/GitHub/meetings_vue3/node_modules/naive-ui/es/tabs/src/Tabs.js"],"sourcesContent":["import { h, ref, defineComponent, computed, provide, watch, toRef, nextTick, withDirectives, vShow, watchEffect, cloneVNode, TransitionGroup } from 'vue';\nimport { VResizeObserver, VXScroll } from 'vueuc';\nimport { throttle } from 'lodash-es';\nimport { useCompitable, onFontsReady, useMergedState } from 'vooks';\nimport { useConfig, useTheme, useThemeClass } from '../../_mixins';\nimport { createKey, call, flatten, warnOnce, resolveWrappedSlot } from '../../_utils';\nimport { tabsLight } from '../styles';\nimport { tabsInjectionKey } from './interface';\nimport Tab from './Tab';\nimport style from './styles/index.cssr';\nexport const tabsProps = Object.assign(Object.assign({}, useTheme.props), { value: [String, Number], defaultValue: [String, Number], trigger: {\n        type: String,\n        default: 'click'\n    }, type: {\n        type: String,\n        default: 'bar'\n    }, closable: Boolean, justifyContent: String, size: {\n        type: String,\n        default: 'medium'\n    }, tabStyle: [String, Object], barWidth: Number, paneClass: String, paneStyle: [String, Object], addable: [Boolean, Object], tabsPadding: {\n        type: Number,\n        default: 0\n    }, animated: Boolean, onBeforeLeave: Function, onAdd: Function, 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array], onClose: [Function, Array], \n    // deprecated\n    labelSize: String, activeName: [String, Number], onActiveNameChange: [Function, Array] });\nexport default defineComponent({\n    name: 'Tabs',\n    props: tabsProps,\n    setup(props, { slots }) {\n        var _a, _b, _c, _d;\n        if (process.env.NODE_ENV !== 'production') {\n            watchEffect(() => {\n                if (props.labelSize !== undefined) {\n                    warnOnce('tabs', '`label-size` is deprecated, please use `size` instead.');\n                }\n                if (props.activeName !== undefined) {\n                    warnOnce('tabs', '`active-name` is deprecated, please use `value` instead.');\n                }\n                if (props.onActiveNameChange !== undefined) {\n                    warnOnce('tabs', '`on-active-name-change` is deprecated, please use `on-update:value` instead.');\n                }\n            });\n        }\n        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);\n        const themeRef = useTheme('Tabs', '-tabs', style, tabsLight, props, mergedClsPrefixRef);\n        const tabsElRef = ref(null);\n        const barElRef = ref(null);\n        const scrollWrapperElRef = ref(null);\n        const addTabInstRef = ref(null);\n        const xScrollInstRef = ref(null);\n        const leftReachedRef = ref(true);\n        const rightReachedRef = ref(true);\n        const compitableSizeRef = useCompitable(props, ['labelSize', 'size']);\n        const compitableValueRef = useCompitable(props, ['activeName', 'value']);\n        const uncontrolledValueRef = ref((_b = (_a = compitableValueRef.value) !== null && _a !== void 0 ? _a : props.defaultValue) !== null && _b !== void 0 ? _b : (slots.default\n            ? (_d = (_c = flatten(slots.default())[0]) === null || _c === void 0 ? void 0 : _c.props) === null || _d === void 0 ? void 0 : _d.name\n            : null));\n        const mergedValueRef = useMergedState(compitableValueRef, uncontrolledValueRef);\n        const tabChangeIdRef = { id: 0 };\n        const tabWrapperStyleRef = computed(() => {\n            if (!props.justifyContent || props.type === 'card')\n                return undefined;\n            return {\n                display: 'flex',\n                justifyContent: props.justifyContent\n            };\n        });\n        watch(mergedValueRef, () => {\n            tabChangeIdRef.id = 0;\n            updateCurrentBarStyle();\n            updateCurrentScrollPosition(true);\n        });\n        function getCurrentEl() {\n            var _a;\n            const { value } = mergedValueRef;\n            if (value === null)\n                return null;\n            const tabEl = (_a = tabsElRef.value) === null || _a === void 0 ? void 0 : _a.querySelector(`[data-name=\"${value}\"]`);\n            return tabEl;\n        }\n        function updateBarStyle(tabEl) {\n            if (props.type === 'card')\n                return;\n            const { value: barEl } = barElRef;\n            if (!barEl)\n                return;\n            if (tabEl) {\n                const disabledClassName = `${mergedClsPrefixRef.value}-tabs-bar--disabled`;\n                const { barWidth } = props;\n                if (tabEl.dataset.disabled === 'true') {\n                    barEl.classList.add(disabledClassName);\n                }\n                else {\n                    barEl.classList.remove(disabledClassName);\n                }\n                if (typeof barWidth === 'number' && tabEl.offsetWidth >= barWidth) {\n                    const offsetDiffLeft = Math.floor((tabEl.offsetWidth - barWidth) / 2) + tabEl.offsetLeft;\n                    barEl.style.left = `${offsetDiffLeft}px`;\n                    barEl.style.maxWidth = `${barWidth}px`;\n                }\n                else {\n                    barEl.style.left = `${tabEl.offsetLeft}px`;\n                    barEl.style.maxWidth = `${tabEl.offsetWidth}px`;\n                }\n                barEl.style.width = '8192px';\n                void barEl.offsetWidth;\n            }\n        }\n        function updateCurrentBarStyle() {\n            if (props.type === 'card')\n                return;\n            const tabEl = getCurrentEl();\n            if (tabEl) {\n                updateBarStyle(tabEl);\n            }\n        }\n        function updateCurrentScrollPosition(smooth) {\n            var _a;\n            const scrollWrapperEl = (_a = xScrollInstRef.value) === null || _a === void 0 ? void 0 : _a.$el;\n            if (!scrollWrapperEl)\n                return;\n            const tabEl = getCurrentEl();\n            if (!tabEl)\n                return;\n            const { scrollLeft: scrollWrapperElScrollLeft, offsetWidth: scrollWrapperElOffsetWidth } = scrollWrapperEl;\n            const { offsetLeft: tabElOffsetLeft, offsetWidth: tabElOffsetWidth } = tabEl;\n            if (scrollWrapperElScrollLeft > tabElOffsetLeft) {\n                scrollWrapperEl.scrollTo({\n                    top: 0,\n                    left: tabElOffsetLeft,\n                    behavior: 'smooth'\n                });\n            }\n            else if (tabElOffsetLeft + tabElOffsetWidth >\n                scrollWrapperElScrollLeft + scrollWrapperElOffsetWidth) {\n                scrollWrapperEl.scrollTo({\n                    top: 0,\n                    left: tabElOffsetLeft + tabElOffsetWidth - scrollWrapperElOffsetWidth,\n                    behavior: 'smooth'\n                });\n            }\n        }\n        const tabsPaneWrapperRef = ref(null);\n        let fromHeight = 0;\n        let hangingTransition = null;\n        function onAnimationBeforeLeave(el) {\n            const tabsPaneWrapperEl = tabsPaneWrapperRef.value;\n            if (tabsPaneWrapperEl) {\n                fromHeight = el.getBoundingClientRect().height;\n                const fromHeightPx = `${fromHeight}px`;\n                const applyFromStyle = () => {\n                    tabsPaneWrapperEl.style.height = fromHeightPx;\n                    tabsPaneWrapperEl.style.maxHeight = fromHeightPx;\n                };\n                if (!hangingTransition) {\n                    hangingTransition = applyFromStyle;\n                }\n                else {\n                    applyFromStyle();\n                    hangingTransition();\n                    hangingTransition = null;\n                }\n            }\n        }\n        function onAnimationEnter(el) {\n            const tabsPaneWrapperEl = tabsPaneWrapperRef.value;\n            if (tabsPaneWrapperEl) {\n                const targetHeight = el.getBoundingClientRect().height;\n                const applyTargetStyle = () => {\n                    void document.body.offsetHeight;\n                    tabsPaneWrapperEl.style.maxHeight = `${targetHeight}px`;\n                    tabsPaneWrapperEl.style.height = `${Math.max(fromHeight, targetHeight)}px`;\n                };\n                if (!hangingTransition) {\n                    hangingTransition = applyTargetStyle;\n                }\n                else {\n                    hangingTransition();\n                    hangingTransition = null;\n                    applyTargetStyle();\n                }\n            }\n        }\n        function onAnimationAfterEnter() {\n            const tabsPaneWrapperEl = tabsPaneWrapperRef.value;\n            if (tabsPaneWrapperEl) {\n                tabsPaneWrapperEl.style.maxHeight = '';\n                tabsPaneWrapperEl.style.height = '';\n            }\n        }\n        const renderNameListRef = { value: [] };\n        const animationDirectionRef = ref('next');\n        function activateTab(panelName) {\n            const currentValue = mergedValueRef.value;\n            let dir = 'next';\n            for (const name of renderNameListRef.value) {\n                if (name === currentValue) {\n                    break;\n                }\n                if (name === panelName) {\n                    dir = 'prev';\n                    break;\n                }\n            }\n            animationDirectionRef.value = dir;\n            doUpdateValue(panelName);\n        }\n        function doUpdateValue(panelName) {\n            const { onActiveNameChange, onUpdateValue, 'onUpdate:value': _onUpdateValue } = props;\n            if (onActiveNameChange) {\n                call(onActiveNameChange, panelName);\n            }\n            if (onUpdateValue)\n                call(onUpdateValue, panelName);\n            if (_onUpdateValue)\n                call(_onUpdateValue, panelName);\n            uncontrolledValueRef.value = panelName;\n        }\n        function handleClose(panelName) {\n            const { onClose } = props;\n            if (onClose)\n                call(onClose, panelName);\n        }\n        let firstTimeUpdatePosition = true;\n        function updateBarPositionInstantly() {\n            const { value: barEl } = barElRef;\n            if (!barEl)\n                return;\n            if (!firstTimeUpdatePosition)\n                firstTimeUpdatePosition = false;\n            const disableTransitionClassName = 'transition-disabled';\n            barEl.classList.add(disableTransitionClassName);\n            updateCurrentBarStyle();\n            // here we don't need to force layout after update bar style\n            // since deriveScrollShadow will force layout\n            barEl.classList.remove(disableTransitionClassName);\n        }\n        let memorizedWidth = 0;\n        function _handleNavResize(entry) {\n            var _a, _b;\n            if (entry.contentRect.width === 0 && entry.contentRect.height === 0) {\n                return;\n            }\n            if (memorizedWidth === entry.contentRect.width) {\n                return;\n            }\n            memorizedWidth = entry.contentRect.width;\n            const { type } = props;\n            if (type === 'line' || type === 'bar') {\n                if (firstTimeUpdatePosition ||\n                    ((_a = props.justifyContent) === null || _a === void 0 ? void 0 : _a.startsWith('space'))) {\n                    updateBarPositionInstantly();\n                }\n            }\n            if (type !== 'segment') {\n                deriveScrollShadow((_b = xScrollInstRef.value) === null || _b === void 0 ? void 0 : _b.$el);\n            }\n        }\n        const handleNavResize = throttle(_handleNavResize, 64);\n        watch([() => props.justifyContent, () => props.size], () => {\n            void nextTick(() => {\n                const { type } = props;\n                if (type === 'line' || type === 'bar') {\n                    updateBarPositionInstantly();\n                }\n            });\n        });\n        const addTabFixedRef = ref(false);\n        function _handleTabsResize(entry) {\n            var _a;\n            const { target, contentRect: { width } } = entry;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const containerWidth = target.parentElement.offsetWidth;\n            if (!addTabFixedRef.value) {\n                if (containerWidth < width) {\n                    addTabFixedRef.value = true;\n                }\n            }\n            else {\n                const { value: addTabInst } = addTabInstRef;\n                if (!addTabInst)\n                    return;\n                if (containerWidth - width > addTabInst.$el.offsetWidth) {\n                    addTabFixedRef.value = false;\n                }\n            }\n            deriveScrollShadow((_a = xScrollInstRef.value) === null || _a === void 0 ? void 0 : _a.$el);\n        }\n        const handleTabsResize = throttle(_handleTabsResize, 64);\n        function handleAdd() {\n            const { onAdd } = props;\n            if (onAdd)\n                onAdd();\n            void nextTick(() => {\n                const currentEl = getCurrentEl();\n                const { value: xScrollInst } = xScrollInstRef;\n                if (!currentEl || !xScrollInst)\n                    return;\n                xScrollInst.scrollTo({\n                    left: currentEl.offsetLeft,\n                    top: 0,\n                    behavior: 'smooth'\n                });\n            });\n        }\n        function deriveScrollShadow(el) {\n            if (!el)\n                return;\n            const { scrollLeft, scrollWidth, offsetWidth } = el;\n            leftReachedRef.value = scrollLeft <= 0;\n            rightReachedRef.value = scrollLeft + offsetWidth >= scrollWidth;\n        }\n        const handleScroll = throttle((e) => {\n            deriveScrollShadow(e.target);\n        }, 64);\n        provide(tabsInjectionKey, {\n            triggerRef: toRef(props, 'trigger'),\n            tabStyleRef: toRef(props, 'tabStyle'),\n            paneClassRef: toRef(props, 'paneClass'),\n            paneStyleRef: toRef(props, 'paneStyle'),\n            mergedClsPrefixRef,\n            typeRef: toRef(props, 'type'),\n            closableRef: toRef(props, 'closable'),\n            valueRef: mergedValueRef,\n            tabChangeIdRef,\n            onBeforeLeaveRef: toRef(props, 'onBeforeLeave'),\n            activateTab,\n            handleClose,\n            handleAdd\n        });\n        onFontsReady(() => {\n            updateCurrentBarStyle();\n            updateCurrentScrollPosition(true);\n        });\n        // avoid useless rerender\n        watchEffect(() => {\n            const { value: el } = scrollWrapperElRef;\n            if (!el)\n                return;\n            const { value: clsPrefix } = mergedClsPrefixRef;\n            const shadowBeforeClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-before`;\n            const shadowAfterClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-after`;\n            if (leftReachedRef.value) {\n                el.classList.remove(shadowBeforeClass);\n            }\n            else {\n                el.classList.add(shadowBeforeClass);\n            }\n            if (rightReachedRef.value) {\n                el.classList.remove(shadowAfterClass);\n            }\n            else {\n                el.classList.add(shadowAfterClass);\n            }\n        });\n        const tabsRailElRef = ref(null);\n        watch(mergedValueRef, () => {\n            if (props.type === 'segment') {\n                const tabsRailEl = tabsRailElRef.value;\n                if (tabsRailEl) {\n                    void nextTick(() => {\n                        tabsRailEl.classList.add('transition-disabled');\n                        void tabsRailEl.offsetWidth;\n                        tabsRailEl.classList.remove('transition-disabled');\n                    });\n                }\n            }\n        });\n        const exposedMethods = {\n            syncBarPosition: () => {\n                updateCurrentBarStyle();\n            }\n        };\n        const cssVarsRef = computed(() => {\n            const { value: size } = compitableSizeRef;\n            const { type } = props;\n            const typeSuffix = {\n                card: 'Card',\n                bar: 'Bar',\n                line: 'Line',\n                segment: 'Segment'\n            }[type];\n            const sizeType = `${size}${typeSuffix}`;\n            const { self: { barColor, closeIconColor, closeIconColorHover, closeIconColorPressed, tabColor, tabBorderColor, paneTextColor, tabFontWeight, tabBorderRadius, tabFontWeightActive, colorSegment, fontWeightStrong, tabColorSegment, closeSize, closeIconSize, closeColorHover, closeColorPressed, closeBorderRadius, [createKey('panePadding', size)]: panePadding, [createKey('tabPadding', sizeType)]: tabPadding, [createKey('tabGap', sizeType)]: tabGap, [createKey('tabTextColor', type)]: tabTextColor, [createKey('tabTextColorActive', type)]: tabTextColorActive, [createKey('tabTextColorHover', type)]: tabTextColorHover, [createKey('tabTextColorDisabled', type)]: tabTextColorDisabled, [createKey('tabFontSize', size)]: tabFontSize }, common: { cubicBezierEaseInOut } } = themeRef.value;\n            return {\n                '--n-bezier': cubicBezierEaseInOut,\n                '--n-color-segment': colorSegment,\n                '--n-bar-color': barColor,\n                '--n-tab-font-size': tabFontSize,\n                '--n-tab-text-color': tabTextColor,\n                '--n-tab-text-color-active': tabTextColorActive,\n                '--n-tab-text-color-disabled': tabTextColorDisabled,\n                '--n-tab-text-color-hover': tabTextColorHover,\n                '--n-pane-text-color': paneTextColor,\n                '--n-tab-border-color': tabBorderColor,\n                '--n-tab-border-radius': tabBorderRadius,\n                '--n-close-size': closeSize,\n                '--n-close-icon-size': closeIconSize,\n                '--n-close-color-hover': closeColorHover,\n                '--n-close-color-pressed': closeColorPressed,\n                '--n-close-border-radius': closeBorderRadius,\n                '--n-close-icon-color': closeIconColor,\n                '--n-close-icon-color-hover': closeIconColorHover,\n                '--n-close-icon-color-pressed': closeIconColorPressed,\n                '--n-tab-color': tabColor,\n                '--n-tab-font-weight': tabFontWeight,\n                '--n-tab-font-weight-active': tabFontWeightActive,\n                '--n-tab-padding': tabPadding,\n                '--n-tab-gap': tabGap,\n                '--n-pane-padding': panePadding,\n                '--n-font-weight-strong': fontWeightStrong,\n                '--n-tab-color-segment': tabColorSegment\n            };\n        });\n        const themeClassHandle = inlineThemeDisabled\n            ? useThemeClass('tabs', computed(() => {\n                return `${compitableSizeRef.value[0]}${props.type[0]}`;\n            }), cssVarsRef, props)\n            : undefined;\n        return Object.assign({ mergedClsPrefix: mergedClsPrefixRef, mergedValue: mergedValueRef, renderedNames: new Set(), tabsRailElRef,\n            tabsPaneWrapperRef,\n            tabsElRef,\n            barElRef,\n            addTabInstRef,\n            xScrollInstRef,\n            scrollWrapperElRef, addTabFixed: addTabFixedRef, tabWrapperStyle: tabWrapperStyleRef, handleNavResize, mergedSize: compitableSizeRef, handleScroll,\n            handleTabsResize, cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, animationDirection: animationDirectionRef, renderNameListRef,\n            onAnimationBeforeLeave,\n            onAnimationEnter,\n            onAnimationAfterEnter, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender }, exposedMethods);\n    },\n    render() {\n        const { mergedClsPrefix, type, addTabFixed, addable, mergedSize, renderNameListRef, onRender, $slots: { default: defaultSlot, prefix: prefixSlot, suffix: suffixSlot } } = this;\n        onRender === null || onRender === void 0 ? void 0 : onRender();\n        const tabPaneChildren = defaultSlot\n            ? flatten(defaultSlot()).filter((v) => {\n                return v.type.__TAB_PANE__ === true;\n            })\n            : [];\n        const tabChildren = defaultSlot\n            ? flatten(defaultSlot()).filter((v) => {\n                return v.type.__TAB__ === true;\n            })\n            : [];\n        const showPane = !tabChildren.length;\n        const isCard = type === 'card';\n        const isSegment = type === 'segment';\n        const mergedJustifyContent = !isCard && !isSegment && this.justifyContent;\n        renderNameListRef.value = [];\n        return (h(\"div\", { class: [\n                `${mergedClsPrefix}-tabs`,\n                this.themeClass,\n                `${mergedClsPrefix}-tabs--${type}-type`,\n                `${mergedClsPrefix}-tabs--${mergedSize}-size`,\n                mergedJustifyContent && `${mergedClsPrefix}-tabs--flex`\n            ], style: this.cssVars },\n            h(\"div\", { class: [\n                    // the class should be applied here since it's possible\n                    // to make tabs nested in tabs, style may influence each\n                    // other. adding a class will make it easy to write the\n                    // style.\n                    `${mergedClsPrefix}-tabs-nav--${type}-type`,\n                    `${mergedClsPrefix}-tabs-nav`\n                ] },\n                resolveWrappedSlot(prefixSlot, (children) => children && (h(\"div\", { class: `${mergedClsPrefix}-tabs-nav__prefix` }, children))),\n                isSegment ? (h(\"div\", { class: `${mergedClsPrefix}-tabs-rail`, ref: \"tabsRailElRef\" }, showPane\n                    ? tabPaneChildren.map((tabPaneVNode, index) => {\n                        renderNameListRef.value.push(tabPaneVNode.props.name);\n                        return (h(Tab, Object.assign({}, tabPaneVNode.props, { internalCreatedByPane: true, internalLeftPadded: index !== 0 }), tabPaneVNode.children\n                            ? {\n                                default: tabPaneVNode.children.tab\n                            }\n                            : undefined));\n                    })\n                    : tabChildren.map((tabVNode, index) => {\n                        renderNameListRef.value.push(tabVNode.props.name);\n                        if (index === 0) {\n                            return tabVNode;\n                        }\n                        else {\n                            return createLeftPaddedTabVNode(tabVNode);\n                        }\n                    }))) : (h(VResizeObserver, { onResize: this.handleNavResize }, {\n                    default: () => (h(\"div\", { class: `${mergedClsPrefix}-tabs-nav-scroll-wrapper`, ref: \"scrollWrapperElRef\" },\n                        h(VXScroll, { ref: \"xScrollInstRef\", onScroll: this.handleScroll }, {\n                            default: () => {\n                                const rawWrappedTabs = (h(\"div\", { style: this.tabWrapperStyle, class: `${mergedClsPrefix}-tabs-wrapper` },\n                                    mergedJustifyContent ? null : (h(\"div\", { class: `${mergedClsPrefix}-tabs-scroll-padding`, style: { width: `${this.tabsPadding}px` } })),\n                                    showPane\n                                        ? tabPaneChildren.map((tabPaneVNode, index) => {\n                                            renderNameListRef.value.push(tabPaneVNode.props.name);\n                                            return justifyTabDynamicProps(h(Tab, Object.assign({}, tabPaneVNode.props, { internalCreatedByPane: true, internalLeftPadded: index !== 0 &&\n                                                    (!mergedJustifyContent ||\n                                                        mergedJustifyContent ===\n                                                            'center' ||\n                                                        mergedJustifyContent ===\n                                                            'start' ||\n                                                        mergedJustifyContent === 'end') }), tabPaneVNode.children\n                                                ? {\n                                                    default: tabPaneVNode.children.tab\n                                                }\n                                                : undefined));\n                                        })\n                                        : tabChildren.map((tabVNode, index) => {\n                                            renderNameListRef.value.push(tabVNode.props.name);\n                                            if (index !== 0 &&\n                                                !mergedJustifyContent) {\n                                                return justifyTabDynamicProps(createLeftPaddedTabVNode(tabVNode));\n                                            }\n                                            else {\n                                                return justifyTabDynamicProps(tabVNode);\n                                            }\n                                        }),\n                                    !addTabFixed && addable && isCard\n                                        ? createAddTag(addable, (showPane\n                                            ? tabPaneChildren.length\n                                            : tabChildren.length) !== 0)\n                                        : null,\n                                    mergedJustifyContent ? null : (h(\"div\", { class: `${mergedClsPrefix}-tabs-scroll-padding`, style: { width: `${this.tabsPadding}px` } }))));\n                                let wrappedTabs = rawWrappedTabs;\n                                if (isCard && addable) {\n                                    wrappedTabs = (h(VResizeObserver, { onResize: this.handleTabsResize }, {\n                                        default: () => rawWrappedTabs\n                                    }));\n                                }\n                                return (h(\"div\", { ref: \"tabsElRef\", class: `${mergedClsPrefix}-tabs-nav-scroll-content` },\n                                    wrappedTabs,\n                                    isCard ? (h(\"div\", { class: `${mergedClsPrefix}-tabs-pad` })) : null,\n                                    isCard ? null : (h(\"div\", { ref: \"barElRef\", class: `${mergedClsPrefix}-tabs-bar` }))));\n                            }\n                        })))\n                })),\n                addTabFixed && addable && isCard\n                    ? createAddTag(addable, true)\n                    : null,\n                resolveWrappedSlot(suffixSlot, (children) => children && (h(\"div\", { class: `${mergedClsPrefix}-tabs-nav__suffix` }, children)))),\n            showPane &&\n                (this.animated ? (h(\"div\", { ref: \"tabsPaneWrapperRef\", class: `${mergedClsPrefix}-tabs-pane-wrapper` }, filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames, this.onAnimationBeforeLeave, this.onAnimationEnter, this.onAnimationAfterEnter, this.animationDirection))) : (filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames)))));\n    }\n});\nfunction filterMapTabPanes(tabPaneVNodes, value, renderedNames, onBeforeLeave, onEnter, onAfterEnter, animationDirection) {\n    const children = [];\n    tabPaneVNodes.forEach((vNode) => {\n        const { name, displayDirective, 'display-directive': _displayDirective } = vNode.props;\n        const matchDisplayDirective = (directive) => displayDirective === directive || _displayDirective === directive;\n        const show = value === name;\n        if (vNode.key !== undefined) {\n            vNode.key = name;\n        }\n        if (show ||\n            matchDisplayDirective('show') ||\n            (matchDisplayDirective('show:lazy') && renderedNames.has(name))) {\n            if (!renderedNames.has(name)) {\n                renderedNames.add(name);\n            }\n            const useVShow = !matchDisplayDirective('if');\n            children.push(useVShow ? withDirectives(vNode, [[vShow, show]]) : vNode);\n        }\n    });\n    if (!animationDirection) {\n        return children;\n    }\n    return (h(TransitionGroup, { name: `${animationDirection}-transition`, onBeforeLeave: onBeforeLeave, onEnter: onEnter, onAfterEnter: onAfterEnter }, { default: () => children }));\n}\nfunction createAddTag(addable, internalLeftPadded) {\n    return (h(Tab, { ref: \"addTabInstRef\", key: \"__addable\", name: \"__addable\", internalCreatedByPane: true, internalAddable: true, internalLeftPadded: internalLeftPadded, disabled: typeof addable === 'object' && addable.disabled }));\n}\nfunction createLeftPaddedTabVNode(tabVNode) {\n    const modifiedVNode = cloneVNode(tabVNode);\n    if (modifiedVNode.props) {\n        modifiedVNode.props.internalLeftPadded = true;\n    }\n    else {\n        modifiedVNode.props = {\n            internalLeftPadded: true\n        };\n    }\n    return modifiedVNode;\n}\nfunction justifyTabDynamicProps(tabVNode) {\n    if (Array.isArray(tabVNode.dynamicProps)) {\n        if (!tabVNode.dynamicProps.includes('internalLeftPadded')) {\n            tabVNode.dynamicProps.push('internalLeftPadded');\n        }\n    }\n    else {\n        tabVNode.dynamicProps = ['internalLeftPadded'];\n    }\n    return tabVNode;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}