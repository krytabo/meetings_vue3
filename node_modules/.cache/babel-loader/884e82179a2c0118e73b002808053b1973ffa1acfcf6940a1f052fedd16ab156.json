{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { h, ref, toRef, computed, defineComponent, provide, watch, nextTick, watchEffect, inject } from 'vue';\nimport { createTreeMate, flatten, createIndexGetter } from 'treemate';\nimport { useMergedState } from 'vooks';\nimport { VVirtualList } from 'vueuc';\nimport { getPadding } from 'seemly';\nimport { treeSelectInjectionKey } from '../../tree-select/src/interface';\nimport { useConfig, useTheme, useThemeClass, useRtl } from '../../_mixins';\nimport { call, createDataKey, resolveSlot, warn, warnOnce } from '../../_utils';\nimport { NxScrollbar } from '../../_internal';\nimport { treeLight } from '../styles';\nimport NTreeNode from './TreeNode';\nimport { keysWithFilter, emptyImage, filterTree, isNodeDisabled } from './utils';\nimport { useKeyboard } from './keyboard';\nimport { treeInjectionKey } from './interface';\nimport MotionWrapper from './MotionWrapper';\nimport { defaultAllowDrop } from './dnd';\nimport style from './styles/index.cssr';\nimport { NEmpty } from '../../empty';\n// TODO:\n// During expanding, some node are mis-applied with :active style\n// Async dnd has bug\nconst ITEM_SIZE = 30; // 24 + 3 + 3\nexport function createTreeMateOptions(keyField, childrenField, disabledField) {\n  return {\n    getIsGroup() {\n      return false;\n    },\n    getKey(node) {\n      return node[keyField];\n    },\n    getChildren(node) {\n      return node[childrenField];\n    },\n    getDisabled(node) {\n      return !!(node[disabledField] || node.checkboxDisabled);\n    }\n  };\n}\nexport const treeSharedProps = {\n  allowCheckingNotLoaded: Boolean,\n  filter: Function,\n  defaultExpandAll: Boolean,\n  expandedKeys: Array,\n  keyField: {\n    type: String,\n    default: 'key'\n  },\n  labelField: {\n    type: String,\n    default: 'label'\n  },\n  childrenField: {\n    type: String,\n    default: 'children'\n  },\n  disabledField: {\n    type: String,\n    default: 'disabled'\n  },\n  defaultExpandedKeys: {\n    type: Array,\n    default: () => []\n  },\n  indeterminateKeys: Array,\n  renderSwitcherIcon: Function,\n  onUpdateIndeterminateKeys: [Function, Array],\n  'onUpdate:indeterminateKeys': [Function, Array],\n  onUpdateExpandedKeys: [Function, Array],\n  'onUpdate:expandedKeys': [Function, Array]\n};\nexport const treeProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), {\n  accordion: Boolean,\n  showIrrelevantNodes: {\n    type: Boolean,\n    default: true\n  },\n  data: {\n    type: Array,\n    default: () => []\n  },\n  expandOnDragenter: {\n    type: Boolean,\n    default: true\n  },\n  expandOnClick: Boolean,\n  checkOnClick: {\n    type: [Boolean, Function],\n    default: false\n  },\n  cancelable: {\n    type: Boolean,\n    default: true\n  },\n  checkable: Boolean,\n  draggable: Boolean,\n  blockNode: Boolean,\n  blockLine: Boolean,\n  disabled: Boolean,\n  checkedKeys: Array,\n  defaultCheckedKeys: {\n    type: Array,\n    default: () => []\n  },\n  selectedKeys: Array,\n  defaultSelectedKeys: {\n    type: Array,\n    default: () => []\n  },\n  multiple: Boolean,\n  pattern: {\n    type: String,\n    default: ''\n  },\n  onLoad: Function,\n  cascade: Boolean,\n  selectable: {\n    type: Boolean,\n    default: true\n  },\n  indent: {\n    type: Number,\n    default: 16\n  },\n  allowDrop: {\n    type: Function,\n    default: defaultAllowDrop\n  },\n  animated: {\n    type: Boolean,\n    default: true\n  },\n  checkboxPlacement: {\n    type: String,\n    default: 'left'\n  },\n  virtualScroll: Boolean,\n  watchProps: Array,\n  renderLabel: Function,\n  renderPrefix: Function,\n  renderSuffix: Function,\n  nodeProps: Function,\n  keyboard: {\n    type: Boolean,\n    default: true\n  },\n  onDragenter: [Function, Array],\n  onDragleave: [Function, Array],\n  onDragend: [Function, Array],\n  onDragstart: [Function, Array],\n  onDragover: [Function, Array],\n  onDrop: [Function, Array],\n  onUpdateCheckedKeys: [Function, Array],\n  'onUpdate:checkedKeys': [Function, Array],\n  onUpdateSelectedKeys: [Function, Array],\n  'onUpdate:selectedKeys': [Function, Array]\n}), treeSharedProps), {\n  // internal props for tree-select\n  internalTreeSelect: Boolean,\n  internalScrollable: Boolean,\n  internalScrollablePadding: String,\n  // use it to display\n  internalRenderEmpty: Function,\n  internalHighlightKeySet: Object,\n  internalUnifySelectCheck: Boolean,\n  internalCheckboxFocusable: {\n    type: Boolean,\n    default: true\n  },\n  internalFocusable: {\n    // Make tree-select take over keyboard operations\n    type: Boolean,\n    default: true\n  },\n  checkStrategy: {\n    type: String,\n    default: 'all'\n  },\n  /**\n   * @deprecated\n   */\n  leafOnly: Boolean\n});\nexport default defineComponent({\n  name: 'Tree',\n  props: treeProps,\n  setup(props) {\n    if (process.env.NODE_ENV !== 'production') {\n      watchEffect(() => {\n        if (props.leafOnly) {\n          warnOnce('tree', '`leaf-only` is deprecated, please use `check-strategy=\"child\"` instead');\n        }\n      });\n    }\n    const {\n      mergedClsPrefixRef,\n      inlineThemeDisabled,\n      mergedRtlRef\n    } = useConfig(props);\n    const rtlEnabledRef = useRtl('Tree', mergedRtlRef, mergedClsPrefixRef);\n    const themeRef = useTheme('Tree', '-tree', style, treeLight, props, mergedClsPrefixRef);\n    const selfElRef = ref(null);\n    const scrollbarInstRef = ref(null);\n    const virtualListInstRef = ref(null);\n    function getScrollContainer() {\n      var _a;\n      return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.listElRef;\n    }\n    function getScrollContent() {\n      var _a;\n      return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.itemsElRef;\n    }\n    const filteredTreeInfoRef = computed(() => {\n      const {\n        pattern\n      } = props;\n      if (!pattern) {\n        return {\n          filteredTree: props.data,\n          highlightKeySet: null,\n          expandedKeys: undefined\n        };\n      }\n      if (!pattern.length || !mergedFilterRef.value) {\n        return {\n          filteredTree: props.data,\n          highlightKeySet: null,\n          expandedKeys: undefined\n        };\n      }\n      return filterTree(props.data, mergedFilterRef.value, pattern, props.keyField, props.childrenField);\n    });\n    // We don't expect data source to change so we just determine it once\n    const displayTreeMateRef = computed(() => createTreeMate(props.showIrrelevantNodes ? props.data : filteredTreeInfoRef.value.filteredTree, createTreeMateOptions(props.keyField, props.childrenField, props.disabledField)));\n    const treeSelectInjection = inject(treeSelectInjectionKey, null);\n    const dataTreeMateRef = props.internalTreeSelect ? treeSelectInjection.dataTreeMate : displayTreeMateRef;\n    const {\n      watchProps\n    } = props;\n    const uncontrolledCheckedKeysRef = ref([]);\n    if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultCheckedKeys')) {\n      watchEffect(() => {\n        uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;\n      });\n    } else {\n      uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;\n    }\n    const controlledCheckedKeysRef = toRef(props, 'checkedKeys');\n    const mergedCheckedKeysRef = useMergedState(controlledCheckedKeysRef, uncontrolledCheckedKeysRef);\n    const checkedStatusRef = computed(() => {\n      const value = dataTreeMateRef.value.getCheckedKeys(mergedCheckedKeysRef.value, {\n        cascade: props.cascade,\n        allowNotLoaded: props.allowCheckingNotLoaded\n      });\n      return value;\n    });\n    const mergedCheckStrategyRef = computed(() => props.leafOnly ? 'child' : props.checkStrategy);\n    const displayedCheckedKeysRef = computed(() => {\n      return checkedStatusRef.value.checkedKeys;\n    });\n    const displayedIndeterminateKeysRef = computed(() => {\n      const {\n        indeterminateKeys\n      } = props;\n      if (indeterminateKeys !== undefined) return indeterminateKeys;\n      return checkedStatusRef.value.indeterminateKeys;\n    });\n    const uncontrolledSelectedKeysRef = ref([]);\n    if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultSelectedKeys')) {\n      watchEffect(() => {\n        uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;\n      });\n    } else {\n      uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;\n    }\n    const controlledSelectedKeysRef = toRef(props, 'selectedKeys');\n    const mergedSelectedKeysRef = useMergedState(controlledSelectedKeysRef, uncontrolledSelectedKeysRef);\n    const uncontrolledExpandedKeysRef = ref([]);\n    const initUncontrolledExpandedKeys = keys => {\n      uncontrolledExpandedKeysRef.value = props.defaultExpandAll ? dataTreeMateRef.value.getNonLeafKeys() : keys === undefined ? props.defaultExpandedKeys : keys;\n    };\n    if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultExpandedKeys')) {\n      // if watching defaultExpandedKeys, we use access props.defaultExpandedKeys inside initiator\n      watchEffect(() => initUncontrolledExpandedKeys(undefined));\n    } else {\n      // We by default watchEffect since if defaultExpandAll is true, we should remain tree expand if data changes\n      watchEffect(() => initUncontrolledExpandedKeys(props.defaultExpandedKeys));\n    }\n    const controlledExpandedKeysRef = toRef(props, 'expandedKeys');\n    const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);\n    const fNodesRef = computed(() => displayTreeMateRef.value.getFlattenedNodes(mergedExpandedKeysRef.value));\n    const {\n      pendingNodeKeyRef,\n      handleKeydown\n    } = useKeyboard({\n      props,\n      mergedSelectedKeysRef,\n      fNodesRef,\n      mergedExpandedKeysRef,\n      handleSelect,\n      handleSwitcherClick\n    });\n    let expandTimerId = null;\n    let nodeKeyToBeExpanded = null;\n    const uncontrolledHighlightKeySetRef = ref(new Set());\n    const controlledHighlightKeySetRef = computed(() => {\n      return props.internalHighlightKeySet || filteredTreeInfoRef.value.highlightKeySet;\n    });\n    const mergedHighlightKeySetRef = useMergedState(controlledHighlightKeySetRef, uncontrolledHighlightKeySetRef);\n    const loadingKeysRef = ref(new Set());\n    const expandedNonLoadingKeysRef = computed(() => {\n      return mergedExpandedKeysRef.value.filter(key => !loadingKeysRef.value.has(key));\n    });\n    let dragStartX = 0;\n    const draggingNodeRef = ref(null);\n    const droppingNodeRef = ref(null);\n    const droppingMouseNodeRef = ref(null);\n    const droppingPositionRef = ref(null);\n    const droppingOffsetLevelRef = ref(0);\n    const droppingNodeParentRef = computed(() => {\n      const {\n        value: droppingNode\n      } = droppingNodeRef;\n      if (!droppingNode) return null;\n      // May avoid overlap between line mark of first child & rect mark of parent\n      // if (droppingNode.isFirstChild && droppingPositionRef.value === 'before') {\n      //   return null\n      // }\n      return droppingNode.parent;\n    });\n    const mergedFilterRef = computed(() => {\n      const {\n        filter\n      } = props;\n      if (filter) return filter;\n      const {\n        labelField\n      } = props;\n      return (pattern, node) => {\n        if (!pattern.length) return true;\n        const label = node[labelField];\n        if (typeof label === 'string') {\n          return label.toLowerCase().includes(pattern.toLowerCase());\n        }\n        return false;\n      };\n    });\n    // shallow watch data\n    watch(toRef(props, 'data'), () => {\n      loadingKeysRef.value.clear();\n      pendingNodeKeyRef.value = null;\n      resetDndState();\n    }, {\n      deep: false\n    });\n    let expandAnimationDisabled = false;\n    const disableExpandAnimationForOneTick = () => {\n      expandAnimationDisabled = true;\n      void nextTick(() => {\n        expandAnimationDisabled = false;\n      });\n    };\n    let memoizedExpandedKeys;\n    watch(toRef(props, 'pattern'), (value, oldValue) => {\n      if (props.showIrrelevantNodes) {\n        memoizedExpandedKeys = undefined;\n        if (value) {\n          const {\n            expandedKeys: expandedKeysAfterChange,\n            highlightKeySet\n          } = keysWithFilter(props.data, props.pattern, props.keyField, props.childrenField, mergedFilterRef.value);\n          uncontrolledHighlightKeySetRef.value = highlightKeySet;\n          disableExpandAnimationForOneTick();\n          doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange));\n        } else {\n          uncontrolledHighlightKeySetRef.value = new Set();\n        }\n      } else {\n        if (!value.length) {\n          if (memoizedExpandedKeys !== undefined) {\n            disableExpandAnimationForOneTick();\n            doUpdateExpandedKeys(memoizedExpandedKeys, getOptionsByKeys(memoizedExpandedKeys));\n          }\n        } else {\n          if (!oldValue.length) {\n            memoizedExpandedKeys = mergedExpandedKeysRef.value;\n          }\n          const {\n            expandedKeys\n          } = filteredTreeInfoRef.value;\n          if (expandedKeys !== undefined) {\n            disableExpandAnimationForOneTick();\n            doUpdateExpandedKeys(expandedKeys, getOptionsByKeys(expandedKeys));\n          }\n        }\n      }\n    });\n    function triggerLoading(node) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const {\n          onLoad\n        } = props;\n        if (!onLoad) {\n          if (process.env.NODE_ENV !== 'production') {\n            warn('tree', 'There is unloaded node in data but props.onLoad is not specified.');\n          }\n          return yield Promise.resolve();\n        }\n        const {\n          value: loadingKeys\n        } = loadingKeysRef;\n        return yield new Promise(resolve => {\n          if (!loadingKeys.has(node.key)) {\n            loadingKeys.add(node.key);\n            onLoad(node.rawNode).then(() => {\n              loadingKeys.delete(node.key);\n              resolve();\n            }).catch(loadError => {\n              console.error(loadError);\n              resetDragExpandState();\n            });\n          }\n        });\n      });\n    }\n    watchEffect(() => {\n      var _a;\n      const {\n        value: displayTreeMate\n      } = displayTreeMateRef;\n      if (!displayTreeMate) return;\n      const {\n        getNode\n      } = displayTreeMate;\n      (_a = mergedExpandedKeysRef.value) === null || _a === void 0 ? void 0 : _a.forEach(key => {\n        const node = getNode(key);\n        if (node && !node.shallowLoaded) {\n          void triggerLoading(node);\n        }\n      });\n    });\n    // animation in progress\n    const aipRef = ref(false);\n    // animation flattened nodes\n    const afNodesRef = ref([]);\n    // Note: Since the virtual list depends on min height, if there's a node\n    // whose height starts from 0, the virtual list will have a wrong height\n    // during animation. This will seldom cause wired scrollbar status. It is\n    // fixable and need some changes in vueuc, I've no time so I just leave it\n    // here. Maybe the bug won't be fixed during the life time of the project.\n    watch(expandedNonLoadingKeysRef, (value, prevValue) => {\n      if (!props.animated || expandAnimationDisabled) {\n        void nextTick(syncScrollbar);\n        return;\n      }\n      const prevVSet = new Set(prevValue);\n      let addedKey = null;\n      let removedKey = null;\n      for (const expandedKey of value) {\n        if (!prevVSet.has(expandedKey)) {\n          if (addedKey !== null) return; // multi expand, not triggered by click\n          addedKey = expandedKey;\n        }\n      }\n      const currentVSet = new Set(value);\n      for (const expandedKey of prevValue) {\n        if (!currentVSet.has(expandedKey)) {\n          if (removedKey !== null) return; // multi collapse, not triggered by click\n          removedKey = expandedKey;\n        }\n      }\n      if (addedKey === null && removedKey === null) {\n        // 1. multi action, not triggered by click\n        // 2. no action, don't know what happened\n        return;\n      }\n      const {\n        virtualScroll\n      } = props;\n      const viewportHeight = (virtualScroll ? virtualListInstRef.value.listElRef : selfElRef.value).offsetHeight;\n      const viewportItemCount = Math.ceil(viewportHeight / ITEM_SIZE) + 1;\n      // play add animation\n      let baseExpandedKeys;\n      if (addedKey !== null) {\n        baseExpandedKeys = prevValue;\n      }\n      if (removedKey !== null) {\n        if (baseExpandedKeys === undefined) {\n          baseExpandedKeys = value;\n        } else {\n          baseExpandedKeys = baseExpandedKeys.filter(key => key !== removedKey);\n        }\n      }\n      aipRef.value = true;\n      afNodesRef.value = displayTreeMateRef.value.getFlattenedNodes(baseExpandedKeys);\n      if (addedKey !== null) {\n        const expandedNodeIndex = afNodesRef.value.findIndex(node => node.key === addedKey);\n        if (~expandedNodeIndex) {\n          const children =\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          afNodesRef.value[expandedNodeIndex].children;\n          // sometimes user will pass leaf keys in\n          if (children) {\n            const expandedChildren = flatten(children, value);\n            afNodesRef.value.splice(expandedNodeIndex + 1, 0, {\n              __motion: true,\n              mode: 'expand',\n              height: virtualScroll ? expandedChildren.length * ITEM_SIZE : undefined,\n              nodes: virtualScroll ? expandedChildren.slice(0, viewportItemCount) : expandedChildren\n            });\n          }\n        }\n      }\n      if (removedKey !== null) {\n        const collapsedNodeIndex = afNodesRef.value.findIndex(node => node.key === removedKey);\n        if (~collapsedNodeIndex) {\n          const collapsedNodeChildren = afNodesRef.value[collapsedNodeIndex].children;\n          // Sometime the whole tree is change, remove a key doesn't mean it is collapsed,\n          // but maybe children removed\n          if (!collapsedNodeChildren) return;\n          // play remove animation\n          aipRef.value = true;\n          const collapsedChildren = flatten(collapsedNodeChildren, value);\n          afNodesRef.value.splice(collapsedNodeIndex + 1, 0, {\n            __motion: true,\n            mode: 'collapse',\n            height: virtualScroll ? collapsedChildren.length * ITEM_SIZE : undefined,\n            nodes: virtualScroll ? collapsedChildren.slice(0, viewportItemCount) : collapsedChildren\n          });\n        }\n      }\n    });\n    const getFIndexRef = computed(() => {\n      return createIndexGetter(fNodesRef.value);\n    });\n    const mergedFNodesRef = computed(() => {\n      if (aipRef.value) return afNodesRef.value;else return fNodesRef.value;\n    });\n    function syncScrollbar() {\n      const {\n        value: scrollbarInst\n      } = scrollbarInstRef;\n      if (scrollbarInst) scrollbarInst.sync();\n    }\n    function handleAfterEnter() {\n      aipRef.value = false;\n      if (props.virtualScroll) {\n        // If virtual scroll, we won't listen to resize during animation, so\n        // resize callback of virtual list won't be called and as a result\n        // scrollbar won't sync. We need to sync scrollbar manually.\n        void nextTick(syncScrollbar);\n      }\n    }\n    function getOptionsByKeys(keys) {\n      const {\n        getNode\n      } = dataTreeMateRef.value;\n      return keys.map(key => {\n        var _a;\n        return ((_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode) || null;\n      });\n    }\n    function doUpdateExpandedKeys(value, option) {\n      const {\n        'onUpdate:expandedKeys': _onUpdateExpandedKeys,\n        onUpdateExpandedKeys\n      } = props;\n      uncontrolledExpandedKeysRef.value = value;\n      if (_onUpdateExpandedKeys) {\n        call(_onUpdateExpandedKeys, value, option);\n      }\n      if (onUpdateExpandedKeys) {\n        call(onUpdateExpandedKeys, value, option);\n      }\n    }\n    function doUpdateCheckedKeys(value, option) {\n      const {\n        'onUpdate:checkedKeys': _onUpdateCheckedKeys,\n        onUpdateCheckedKeys\n      } = props;\n      uncontrolledCheckedKeysRef.value = value;\n      if (onUpdateCheckedKeys) {\n        call(onUpdateCheckedKeys, value, option);\n      }\n      if (_onUpdateCheckedKeys) {\n        call(_onUpdateCheckedKeys, value, option);\n      }\n    }\n    function doUpdateIndeterminateKeys(value, option) {\n      const {\n        'onUpdate:indeterminateKeys': _onUpdateIndeterminateKeys,\n        onUpdateIndeterminateKeys\n      } = props;\n      if (_onUpdateIndeterminateKeys) {\n        call(_onUpdateIndeterminateKeys, value, option);\n      }\n      if (onUpdateIndeterminateKeys) {\n        call(onUpdateIndeterminateKeys, value, option);\n      }\n    }\n    function doUpdateSelectedKeys(value, option) {\n      const {\n        'onUpdate:selectedKeys': _onUpdateSelectedKeys,\n        onUpdateSelectedKeys\n      } = props;\n      uncontrolledSelectedKeysRef.value = value;\n      if (onUpdateSelectedKeys) {\n        call(onUpdateSelectedKeys, value, option);\n      }\n      if (_onUpdateSelectedKeys) {\n        call(_onUpdateSelectedKeys, value, option);\n      }\n    }\n    // Drag & Drop\n    function doDragEnter(info) {\n      const {\n        onDragenter\n      } = props;\n      if (onDragenter) call(onDragenter, info);\n    }\n    function doDragLeave(info) {\n      const {\n        onDragleave\n      } = props;\n      if (onDragleave) call(onDragleave, info);\n    }\n    function doDragEnd(info) {\n      const {\n        onDragend\n      } = props;\n      if (onDragend) call(onDragend, info);\n    }\n    function doDragStart(info) {\n      const {\n        onDragstart\n      } = props;\n      if (onDragstart) call(onDragstart, info);\n    }\n    function doDragOver(info) {\n      const {\n        onDragover\n      } = props;\n      if (onDragover) call(onDragover, info);\n    }\n    function doDrop(info) {\n      const {\n        onDrop\n      } = props;\n      if (onDrop) call(onDrop, info);\n    }\n    function resetDndState() {\n      resetDragState();\n      resetDropState();\n    }\n    function resetDragState() {\n      draggingNodeRef.value = null;\n    }\n    function resetDropState() {\n      droppingOffsetLevelRef.value = 0;\n      droppingNodeRef.value = null;\n      droppingMouseNodeRef.value = null;\n      droppingPositionRef.value = null;\n      resetDragExpandState();\n    }\n    function resetDragExpandState() {\n      if (expandTimerId) {\n        window.clearTimeout(expandTimerId);\n        expandTimerId = null;\n      }\n      nodeKeyToBeExpanded = null;\n    }\n    function handleCheck(node, checked) {\n      // We don't guard for leaf only since we have done it in view layer\n      if (props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      if (props.internalUnifySelectCheck && !props.multiple) {\n        handleSelect(node);\n        return;\n      }\n      const {\n        checkedKeys,\n        indeterminateKeys\n      } = dataTreeMateRef.value[checked ? 'check' : 'uncheck'](node.key, displayedCheckedKeysRef.value, {\n        cascade: props.cascade,\n        checkStrategy: mergedCheckStrategyRef.value,\n        allowNotLoaded: props.allowCheckingNotLoaded\n      });\n      doUpdateCheckedKeys(checkedKeys, getOptionsByKeys(checkedKeys));\n      doUpdateIndeterminateKeys(indeterminateKeys, getOptionsByKeys(indeterminateKeys));\n    }\n    function toggleExpand(node) {\n      if (props.disabled) return;\n      const {\n        key\n      } = node;\n      const {\n        value: mergedExpandedKeys\n      } = mergedExpandedKeysRef;\n      const index = mergedExpandedKeys.findIndex(expandNodeId => expandNodeId === key);\n      if (~index) {\n        const expandedKeysAfterChange = Array.from(mergedExpandedKeys);\n        expandedKeysAfterChange.splice(index, 1);\n        doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange));\n      } else {\n        const nodeToBeExpanded = displayTreeMateRef.value.getNode(key);\n        if (!nodeToBeExpanded || nodeToBeExpanded.isLeaf) {\n          return;\n        }\n        let nextKeys;\n        if (props.accordion) {\n          const siblingKeySet = new Set(node.siblings.map(({\n            key\n          }) => key));\n          nextKeys = mergedExpandedKeys.filter(expandedKey => {\n            return !siblingKeySet.has(expandedKey);\n          });\n          nextKeys.push(key);\n        } else {\n          nextKeys = mergedExpandedKeys.concat(key);\n        }\n        doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys));\n      }\n    }\n    function handleSwitcherClick(node) {\n      if (props.disabled || aipRef.value) return;\n      toggleExpand(node);\n    }\n    function handleSelect(node) {\n      if (props.disabled || !props.selectable) {\n        return;\n      }\n      pendingNodeKeyRef.value = node.key;\n      if (props.internalUnifySelectCheck) {\n        const {\n          value: {\n            checkedKeys,\n            indeterminateKeys\n          }\n        } = checkedStatusRef;\n        if (props.multiple) {\n          handleCheck(node, !(checkedKeys.includes(node.key) || indeterminateKeys.includes(node.key)));\n        } else {\n          doUpdateCheckedKeys([node.key], getOptionsByKeys([node.key]));\n        }\n      }\n      if (props.multiple) {\n        const selectedKeys = Array.from(mergedSelectedKeysRef.value);\n        const index = selectedKeys.findIndex(key => key === node.key);\n        if (~index) {\n          if (props.cancelable) {\n            selectedKeys.splice(index, 1);\n          }\n        } else if (!~index) {\n          selectedKeys.push(node.key);\n        }\n        doUpdateSelectedKeys(selectedKeys, getOptionsByKeys(selectedKeys));\n      } else {\n        const selectedKeys = mergedSelectedKeysRef.value;\n        if (selectedKeys.includes(node.key)) {\n          if (props.cancelable) {\n            doUpdateSelectedKeys([], []);\n          }\n        } else {\n          doUpdateSelectedKeys([node.key], getOptionsByKeys([node.key]));\n        }\n      }\n    }\n    function expandDragEnterNode(node) {\n      if (expandTimerId) {\n        window.clearTimeout(expandTimerId);\n        expandTimerId = null;\n      }\n      // Don't expand leaf node.\n      if (node.isLeaf) return;\n      nodeKeyToBeExpanded = node.key;\n      const expand = () => {\n        if (nodeKeyToBeExpanded !== node.key) return;\n        const {\n          value: droppingMouseNode\n        } = droppingMouseNodeRef;\n        if (droppingMouseNode && droppingMouseNode.key === node.key && !mergedExpandedKeysRef.value.includes(node.key)) {\n          const nextKeys = mergedExpandedKeysRef.value.concat(node.key);\n          doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys));\n        }\n        expandTimerId = null;\n        nodeKeyToBeExpanded = null;\n      };\n      if (!node.shallowLoaded) {\n        expandTimerId = window.setTimeout(() => {\n          void triggerLoading(node).then(() => {\n            expand();\n          });\n        }, 1000);\n      } else {\n        expandTimerId = window.setTimeout(() => {\n          expand();\n        }, 1000);\n      }\n    }\n    // Dnd\n    function handleDragEnter({\n      event,\n      node\n    }) {\n      // node should be a tmNode\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      handleDragOver({\n        event,\n        node\n      }, false);\n      doDragEnter({\n        event,\n        node: node.rawNode\n      });\n    }\n    function handleDragLeave({\n      event,\n      node\n    }) {\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      doDragLeave({\n        event,\n        node: node.rawNode\n      });\n    }\n    function handleDragLeaveTree(e) {\n      if (e.target !== e.currentTarget) return;\n      resetDropState();\n    }\n    // Dragend is ok, we don't need to add global listener to reset drag status\n    function handleDragEnd({\n      event,\n      node\n    }) {\n      resetDndState();\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      doDragEnd({\n        event,\n        node: node.rawNode\n      });\n    }\n    function handleDragStart({\n      event,\n      node\n    }) {\n      var _a;\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      // Most of time, the image will block user's view\n      emptyImage && ((_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.setDragImage(emptyImage, 0, 0));\n      dragStartX = event.clientX;\n      draggingNodeRef.value = node;\n      doDragStart({\n        event,\n        node: node.rawNode\n      });\n    }\n    function handleDragOver({\n      event,\n      node\n    }, emit = true) {\n      var _a;\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      const {\n        value: draggingNode\n      } = draggingNodeRef;\n      if (!draggingNode) return;\n      const {\n        allowDrop,\n        indent\n      } = props;\n      if (emit) doDragOver({\n        event,\n        node: node.rawNode\n      });\n      // Update dropping node\n      const el = event.currentTarget;\n      const {\n        height: elOffsetHeight,\n        top: elClientTop\n      } = el.getBoundingClientRect();\n      const eventOffsetY = event.clientY - elClientTop;\n      let mousePosition;\n      const allowDropInside = allowDrop({\n        node: node.rawNode,\n        dropPosition: 'inside',\n        phase: 'drag'\n      });\n      if (allowDropInside) {\n        if (eventOffsetY <= 8) {\n          mousePosition = 'before';\n        } else if (eventOffsetY >= elOffsetHeight - 8) {\n          mousePosition = 'after';\n        } else {\n          mousePosition = 'inside';\n        }\n      } else {\n        if (eventOffsetY <= elOffsetHeight / 2) {\n          mousePosition = 'before';\n        } else {\n          mousePosition = 'after';\n        }\n      }\n      const {\n        value: getFindex\n      } = getFIndexRef;\n      /** determine the drop position and drop node */\n      /** the dropping node needn't to be the mouse hovering node! */\n      /**\n       * if there is something i've learned from implementing a complex\n       * drag & drop. that is never write unit test before you really figure\n       * out what behavior is exactly you want.\n       */\n      let finalDropNode;\n      let finalDropPosition;\n      const hoverNodeFIndex = getFindex(node.key);\n      if (hoverNodeFIndex === null) {\n        resetDropState();\n        return;\n      }\n      let mouseAtExpandedNonLeafNode = false;\n      if (mousePosition === 'inside') {\n        finalDropNode = node;\n        finalDropPosition = 'inside';\n      } else {\n        if (mousePosition === 'before') {\n          if (node.isFirstChild) {\n            finalDropNode = node;\n            finalDropPosition = 'before';\n          } else {\n            finalDropNode = fNodesRef.value[hoverNodeFIndex - 1];\n            finalDropPosition = 'after';\n          }\n        } else {\n          finalDropNode = node;\n          finalDropPosition = 'after';\n        }\n      }\n      // If the node is non-leaf and it is expanded, we don't allow it to\n      // drop after it and change it to drop before its next view sibling\n      if (!finalDropNode.isLeaf && mergedExpandedKeysRef.value.includes(finalDropNode.key)) {\n        mouseAtExpandedNonLeafNode = true;\n        if (finalDropPosition === 'after') {\n          finalDropNode = fNodesRef.value[hoverNodeFIndex + 1];\n          if (!finalDropNode) {\n            // maybe there is no next view sibling when non-leaf node has no\n            // children and it is the last node in the tree\n            finalDropNode = node;\n            finalDropPosition = 'inside';\n          } else {\n            finalDropPosition = 'before';\n          }\n        }\n      }\n      const droppingMouseNode = finalDropNode;\n      droppingMouseNodeRef.value = droppingMouseNode;\n      // This is a speacial case, user is dragging a last child itself, so we\n      // only view it as they are trying to drop after it.\n      // There are some relevant codes in bailout 1's child branch.\n      // Also, the expand bailout should have a high priority. If it's non-leaf\n      // node and expanded, keep its origin drop position\n      if (!mouseAtExpandedNonLeafNode && draggingNode.isLastChild && draggingNode.key === finalDropNode.key) {\n        finalDropPosition = 'after';\n      }\n      if (finalDropPosition === 'after') {\n        let offset = dragStartX - event.clientX; // drag left => > 0\n        let offsetLevel = 0;\n        while (offset >= indent / 2 &&\n        // divide by 2 to make it easier to trigger\n        finalDropNode.parent !== null && finalDropNode.isLastChild && offsetLevel < 1) {\n          offset -= indent;\n          offsetLevel += 1;\n          finalDropNode = finalDropNode.parent;\n        }\n        droppingOffsetLevelRef.value = offsetLevel;\n      } else {\n        droppingOffsetLevelRef.value = 0;\n      }\n      // Bailout 1\n      // Drag self into self\n      // Drag it into direct parent\n      if (draggingNode.contains(finalDropNode) || finalDropPosition === 'inside' && ((_a = draggingNode.parent) === null || _a === void 0 ? void 0 : _a.key) === finalDropNode.key) {\n        if (draggingNode.key === droppingMouseNode.key && draggingNode.key === finalDropNode.key) {\n          // This is special case that we want ui to show a mark to guide user\n          // to start dragging. Nor they will think nothing happens.\n          // However this is an invalid drop, we need to guard it inside\n          // handleDrop\n        } else {\n          resetDropState();\n          return;\n        }\n      }\n      // Bailout 3\n      if (!allowDrop({\n        node: finalDropNode.rawNode,\n        dropPosition: finalDropPosition,\n        phase: 'drag'\n      })) {\n        resetDropState();\n        return;\n      }\n      if (draggingNode.key === finalDropNode.key) {\n        // don't expand when drag on itself\n        resetDragExpandState();\n      } else {\n        if (nodeKeyToBeExpanded !== finalDropNode.key) {\n          if (finalDropPosition === 'inside') {\n            if (props.expandOnDragenter) {\n              expandDragEnterNode(finalDropNode);\n              // Bailout 4\n              // not try to loading\n              if (!finalDropNode.shallowLoaded && nodeKeyToBeExpanded !== finalDropNode.key) {\n                resetDndState();\n                return;\n              }\n            } else {\n              // Bailout 5\n              // never expands on drag\n              if (!finalDropNode.shallowLoaded) {\n                resetDndState();\n                return;\n              }\n            }\n          } else {\n            resetDragExpandState();\n          }\n        } else {\n          if (finalDropPosition !== 'inside') {\n            resetDragExpandState();\n          }\n        }\n      }\n      droppingPositionRef.value = finalDropPosition;\n      droppingNodeRef.value = finalDropNode;\n    }\n    function handleDrop({\n      event,\n      node,\n      dropPosition\n    }) {\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      const {\n        value: draggingNode\n      } = draggingNodeRef;\n      const {\n        value: droppingNode\n      } = droppingNodeRef;\n      const {\n        value: droppingPosition\n      } = droppingPositionRef;\n      if (!draggingNode || !droppingNode || !droppingPosition) {\n        return;\n      }\n      // Bailout 1\n      if (!props.allowDrop({\n        node: droppingNode.rawNode,\n        dropPosition: droppingPosition,\n        phase: 'drag'\n      })) {\n        return;\n      }\n      // Bailout 2\n      // This is a special case to guard since we want ui to show the status\n      // but not to emit a event\n      if (draggingNode.key === droppingNode.key) {\n        return;\n      }\n      // Bailout 3\n      // insert before its next node\n      // insert after its prev node\n      if (droppingPosition === 'before') {\n        const nextNode = draggingNode.getNext({\n          includeDisabled: true\n        });\n        if (nextNode) {\n          if (nextNode.key === droppingNode.key) {\n            resetDropState();\n            return;\n          }\n        }\n      }\n      if (droppingPosition === 'after') {\n        const prevNode = draggingNode.getPrev({\n          includeDisabled: true\n        });\n        if (prevNode) {\n          if (prevNode.key === droppingNode.key) {\n            resetDropState();\n            return;\n          }\n        }\n      }\n      doDrop({\n        event,\n        node: droppingNode.rawNode,\n        dragNode: draggingNode.rawNode,\n        dropPosition\n      });\n      resetDndState();\n    }\n    function handleScroll() {\n      syncScrollbar();\n    }\n    function handleResize() {\n      syncScrollbar();\n    }\n    function handleFocusout(e) {\n      var _a;\n      if (props.virtualScroll || props.internalScrollable) {\n        const {\n          value: scrollbarInst\n        } = scrollbarInstRef;\n        if ((_a = scrollbarInst === null || scrollbarInst === void 0 ? void 0 : scrollbarInst.containerRef) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) {\n          return;\n        }\n        pendingNodeKeyRef.value = null;\n      } else {\n        const {\n          value: selfEl\n        } = selfElRef;\n        if (selfEl === null || selfEl === void 0 ? void 0 : selfEl.contains(e.relatedTarget)) return;\n        pendingNodeKeyRef.value = null;\n      }\n    }\n    watch(pendingNodeKeyRef, value => {\n      var _a, _b;\n      if (value === null) return;\n      if (props.virtualScroll) {\n        (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({\n          key: value\n        });\n      } else if (props.internalScrollable) {\n        const {\n          value: scrollbarInst\n        } = scrollbarInstRef;\n        if (scrollbarInst === null) return;\n        const targetEl = (_b = scrollbarInst.contentRef) === null || _b === void 0 ? void 0 : _b.querySelector(`[data-key=\"${createDataKey(value)}\"]`);\n        if (!targetEl) return;\n        scrollbarInst.scrollTo({\n          el: targetEl\n        });\n      }\n    });\n    provide(treeInjectionKey, {\n      loadingKeysRef,\n      highlightKeySetRef: mergedHighlightKeySetRef,\n      displayedCheckedKeysRef,\n      displayedIndeterminateKeysRef,\n      mergedSelectedKeysRef,\n      mergedExpandedKeysRef,\n      mergedThemeRef: themeRef,\n      mergedCheckStrategyRef,\n      nodePropsRef: toRef(props, 'nodeProps'),\n      disabledRef: toRef(props, 'disabled'),\n      checkableRef: toRef(props, 'checkable'),\n      selectableRef: toRef(props, 'selectable'),\n      expandOnClickRef: toRef(props, 'expandOnClick'),\n      onLoadRef: toRef(props, 'onLoad'),\n      draggableRef: toRef(props, 'draggable'),\n      blockLineRef: toRef(props, 'blockLine'),\n      indentRef: toRef(props, 'indent'),\n      cascadeRef: toRef(props, 'cascade'),\n      checkOnClickRef: toRef(props, 'checkOnClick'),\n      checkboxPlacementRef: props.checkboxPlacement,\n      droppingMouseNodeRef,\n      droppingNodeParentRef,\n      draggingNodeRef,\n      droppingPositionRef,\n      droppingOffsetLevelRef,\n      fNodesRef,\n      pendingNodeKeyRef,\n      disabledFieldRef: toRef(props, 'disabledField'),\n      internalScrollableRef: toRef(props, 'internalScrollable'),\n      internalCheckboxFocusableRef: toRef(props, 'internalCheckboxFocusable'),\n      internalTreeSelect: props.internalTreeSelect,\n      renderLabelRef: toRef(props, 'renderLabel'),\n      renderPrefixRef: toRef(props, 'renderPrefix'),\n      renderSuffixRef: toRef(props, 'renderSuffix'),\n      renderSwitcherIconRef: toRef(props, 'renderSwitcherIcon'),\n      labelFieldRef: toRef(props, 'labelField'),\n      multipleRef: toRef(props, 'multiple'),\n      handleSwitcherClick,\n      handleDragEnd,\n      handleDragEnter,\n      handleDragLeave,\n      handleDragStart,\n      handleDrop,\n      handleDragOver,\n      handleSelect,\n      handleCheck\n    });\n    function scrollTo(options) {\n      var _a;\n      (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(options);\n    }\n    const exposedMethods = {\n      handleKeydown,\n      scrollTo\n    };\n    const cssVarsRef = computed(() => {\n      const {\n        common: {\n          cubicBezierEaseInOut\n        },\n        self: {\n          fontSize,\n          nodeBorderRadius,\n          nodeColorHover,\n          nodeColorPressed,\n          nodeColorActive,\n          arrowColor,\n          loadingColor,\n          nodeTextColor,\n          nodeTextColorDisabled,\n          dropMarkColor\n        }\n      } = themeRef.value;\n      return {\n        '--n-arrow-color': arrowColor,\n        '--n-loading-color': loadingColor,\n        '--n-bezier': cubicBezierEaseInOut,\n        '--n-font-size': fontSize,\n        '--n-node-border-radius': nodeBorderRadius,\n        '--n-node-color-active': nodeColorActive,\n        '--n-node-color-hover': nodeColorHover,\n        '--n-node-color-pressed': nodeColorPressed,\n        '--n-node-text-color': nodeTextColor,\n        '--n-node-text-color-disabled': nodeTextColorDisabled,\n        '--n-drop-mark-color': dropMarkColor\n      };\n    });\n    const themeClassHandle = inlineThemeDisabled ? useThemeClass('tree', undefined, cssVarsRef, props) : undefined;\n    return {\n      mergedClsPrefix: mergedClsPrefixRef,\n      mergedTheme: themeRef,\n      rtlEnabled: rtlEnabledRef,\n      fNodes: mergedFNodesRef,\n      aip: aipRef,\n      selfElRef,\n      virtualListInstRef,\n      scrollbarInstRef,\n      handleFocusout,\n      handleDragLeaveTree,\n      handleScroll,\n      getScrollContainer,\n      getScrollContent,\n      handleAfterEnter,\n      handleResize,\n      handleKeydown: exposedMethods.handleKeydown,\n      scrollTo: exposedMethods.scrollTo,\n      cssVars: inlineThemeDisabled ? undefined : cssVarsRef,\n      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,\n      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender\n    };\n  },\n  render() {\n    var _a;\n    const {\n      fNodes,\n      internalRenderEmpty\n    } = this;\n    if (!fNodes.length && internalRenderEmpty) {\n      return internalRenderEmpty();\n    }\n    const {\n      mergedClsPrefix,\n      blockNode,\n      blockLine,\n      draggable,\n      disabled,\n      internalFocusable,\n      checkable,\n      handleKeydown,\n      rtlEnabled,\n      handleFocusout\n    } = this;\n    const mergedFocusable = internalFocusable && !disabled;\n    const tabindex = mergedFocusable ? '0' : undefined;\n    const treeClass = [`${mergedClsPrefix}-tree`, rtlEnabled && `${mergedClsPrefix}-tree--rtl`, checkable && `${mergedClsPrefix}-tree--checkable`, (blockLine || blockNode) && `${mergedClsPrefix}-tree--block-node`, blockLine && `${mergedClsPrefix}-tree--block-line`];\n    const createNode = tmNode => {\n      return '__motion' in tmNode ? h(MotionWrapper, {\n        height: tmNode.height,\n        nodes: tmNode.nodes,\n        clsPrefix: mergedClsPrefix,\n        mode: tmNode.mode,\n        onAfterEnter: this.handleAfterEnter\n      }) : h(NTreeNode, {\n        key: tmNode.key,\n        tmNode: tmNode,\n        clsPrefix: mergedClsPrefix\n      });\n    };\n    if (this.virtualScroll) {\n      const {\n        mergedTheme,\n        internalScrollablePadding\n      } = this;\n      const padding = getPadding(internalScrollablePadding || '0');\n      return h(NxScrollbar, {\n        ref: \"scrollbarInstRef\",\n        onDragleave: draggable ? this.handleDragLeaveTree : undefined,\n        container: this.getScrollContainer,\n        content: this.getScrollContent,\n        class: treeClass,\n        theme: mergedTheme.peers.Scrollbar,\n        themeOverrides: mergedTheme.peerOverrides.Scrollbar,\n        tabindex: tabindex,\n        onKeydown: mergedFocusable ? handleKeydown : undefined,\n        onFocusout: mergedFocusable ? handleFocusout : undefined\n      }, {\n        default: () => {\n          var _a;\n          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n          return h(VVirtualList, {\n            ref: \"virtualListInstRef\",\n            items: this.fNodes,\n            itemSize: ITEM_SIZE,\n            ignoreItemResize: this.aip,\n            paddingTop: padding.top,\n            paddingBottom: padding.bottom,\n            class: this.themeClass,\n            style: [this.cssVars, {\n              paddingLeft: padding.left,\n              paddingRight: padding.right\n            }],\n            onScroll: this.handleScroll,\n            onResize: this.handleResize,\n            showScrollbar: false,\n            itemResizable: true\n          }, {\n            default: ({\n              item\n            }) => createNode(item)\n          });\n        }\n      });\n    }\n    const {\n      internalScrollable\n    } = this;\n    treeClass.push(this.themeClass);\n    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n    if (internalScrollable) {\n      return h(NxScrollbar, {\n        class: treeClass,\n        tabindex: tabindex,\n        onKeydown: mergedFocusable ? handleKeydown : undefined,\n        onFocusout: mergedFocusable ? handleFocusout : undefined,\n        style: this.cssVars,\n        contentStyle: {\n          padding: this.internalScrollablePadding\n        }\n      }, {\n        default: () => h(\"div\", {\n          onDragleave: draggable ? this.handleDragLeaveTree : undefined,\n          ref: \"selfElRef\"\n        }, this.fNodes.map(createNode))\n      });\n    } else {\n      return h(\"div\", {\n        class: treeClass,\n        tabindex: tabindex,\n        ref: \"selfElRef\",\n        style: this.cssVars,\n        onKeydown: mergedFocusable ? handleKeydown : undefined,\n        onFocusout: mergedFocusable ? handleFocusout : undefined,\n        onDragleave: draggable ? this.handleDragLeaveTree : undefined\n      }, !fNodes.length ? resolveSlot(this.$slots.empty, () => [h(NEmpty, {\n        class: `${mergedClsPrefix}-tree__empty`,\n        theme: this.mergedTheme.peers.Empty,\n        themeOverrides: this.mergedTheme.peerOverrides.Empty\n      })]) : fNodes.map(createNode));\n    }\n  }\n});","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","h","ref","toRef","computed","defineComponent","provide","watch","nextTick","watchEffect","inject","createTreeMate","flatten","createIndexGetter","useMergedState","VVirtualList","getPadding","treeSelectInjectionKey","useConfig","useTheme","useThemeClass","useRtl","call","createDataKey","resolveSlot","warn","warnOnce","NxScrollbar","treeLight","NTreeNode","keysWithFilter","emptyImage","filterTree","isNodeDisabled","useKeyboard","treeInjectionKey","MotionWrapper","defaultAllowDrop","style","NEmpty","ITEM_SIZE","createTreeMateOptions","keyField","childrenField","disabledField","getIsGroup","getKey","node","getChildren","getDisabled","checkboxDisabled","treeSharedProps","allowCheckingNotLoaded","Boolean","filter","Function","defaultExpandAll","expandedKeys","Array","type","String","default","labelField","defaultExpandedKeys","indeterminateKeys","renderSwitcherIcon","onUpdateIndeterminateKeys","onUpdateExpandedKeys","treeProps","Object","assign","props","accordion","showIrrelevantNodes","data","expandOnDragenter","expandOnClick","checkOnClick","cancelable","checkable","draggable","blockNode","blockLine","disabled","checkedKeys","defaultCheckedKeys","selectedKeys","defaultSelectedKeys","multiple","pattern","onLoad","cascade","selectable","indent","Number","allowDrop","animated","checkboxPlacement","virtualScroll","watchProps","renderLabel","renderPrefix","renderSuffix","nodeProps","keyboard","onDragenter","onDragleave","onDragend","onDragstart","onDragover","onDrop","onUpdateCheckedKeys","onUpdateSelectedKeys","internalTreeSelect","internalScrollable","internalScrollablePadding","internalRenderEmpty","internalHighlightKeySet","internalUnifySelectCheck","internalCheckboxFocusable","internalFocusable","checkStrategy","leafOnly","name","setup","process","env","NODE_ENV","mergedClsPrefixRef","inlineThemeDisabled","mergedRtlRef","rtlEnabledRef","themeRef","selfElRef","scrollbarInstRef","virtualListInstRef","getScrollContainer","_a","listElRef","getScrollContent","itemsElRef","filteredTreeInfoRef","filteredTree","highlightKeySet","undefined","length","mergedFilterRef","displayTreeMateRef","treeSelectInjection","dataTreeMateRef","dataTreeMate","uncontrolledCheckedKeysRef","includes","controlledCheckedKeysRef","mergedCheckedKeysRef","checkedStatusRef","getCheckedKeys","allowNotLoaded","mergedCheckStrategyRef","displayedCheckedKeysRef","displayedIndeterminateKeysRef","uncontrolledSelectedKeysRef","controlledSelectedKeysRef","mergedSelectedKeysRef","uncontrolledExpandedKeysRef","initUncontrolledExpandedKeys","keys","getNonLeafKeys","controlledExpandedKeysRef","mergedExpandedKeysRef","fNodesRef","getFlattenedNodes","pendingNodeKeyRef","handleKeydown","handleSelect","handleSwitcherClick","expandTimerId","nodeKeyToBeExpanded","uncontrolledHighlightKeySetRef","Set","controlledHighlightKeySetRef","mergedHighlightKeySetRef","loadingKeysRef","expandedNonLoadingKeysRef","key","has","dragStartX","draggingNodeRef","droppingNodeRef","droppingMouseNodeRef","droppingPositionRef","droppingOffsetLevelRef","droppingNodeParentRef","droppingNode","parent","label","toLowerCase","clear","resetDndState","deep","expandAnimationDisabled","disableExpandAnimationForOneTick","memoizedExpandedKeys","oldValue","expandedKeysAfterChange","doUpdateExpandedKeys","getOptionsByKeys","triggerLoading","loadingKeys","add","rawNode","delete","catch","loadError","console","error","resetDragExpandState","displayTreeMate","getNode","forEach","shallowLoaded","aipRef","afNodesRef","prevValue","syncScrollbar","prevVSet","addedKey","removedKey","expandedKey","currentVSet","viewportHeight","offsetHeight","viewportItemCount","Math","ceil","baseExpandedKeys","expandedNodeIndex","findIndex","children","expandedChildren","splice","__motion","mode","height","nodes","slice","collapsedNodeIndex","collapsedNodeChildren","collapsedChildren","getFIndexRef","mergedFNodesRef","scrollbarInst","sync","handleAfterEnter","map","option","_onUpdateExpandedKeys","doUpdateCheckedKeys","_onUpdateCheckedKeys","doUpdateIndeterminateKeys","_onUpdateIndeterminateKeys","doUpdateSelectedKeys","_onUpdateSelectedKeys","doDragEnter","info","doDragLeave","doDragEnd","doDragStart","doDragOver","doDrop","resetDragState","resetDropState","window","clearTimeout","handleCheck","checked","toggleExpand","mergedExpandedKeys","index","expandNodeId","from","nodeToBeExpanded","isLeaf","nextKeys","siblingKeySet","siblings","push","concat","expandDragEnterNode","expand","droppingMouseNode","setTimeout","handleDragEnter","event","handleDragOver","handleDragLeave","handleDragLeaveTree","target","currentTarget","handleDragEnd","handleDragStart","dataTransfer","setDragImage","clientX","emit","draggingNode","el","elOffsetHeight","top","elClientTop","getBoundingClientRect","eventOffsetY","clientY","mousePosition","allowDropInside","dropPosition","phase","getFindex","finalDropNode","finalDropPosition","hoverNodeFIndex","mouseAtExpandedNonLeafNode","isFirstChild","isLastChild","offset","offsetLevel","contains","handleDrop","droppingPosition","nextNode","getNext","includeDisabled","prevNode","getPrev","dragNode","handleScroll","handleResize","handleFocusout","containerRef","relatedTarget","selfEl","_b","scrollTo","targetEl","contentRef","querySelector","highlightKeySetRef","mergedThemeRef","nodePropsRef","disabledRef","checkableRef","selectableRef","expandOnClickRef","onLoadRef","draggableRef","blockLineRef","indentRef","cascadeRef","checkOnClickRef","checkboxPlacementRef","disabledFieldRef","internalScrollableRef","internalCheckboxFocusableRef","renderLabelRef","renderPrefixRef","renderSuffixRef","renderSwitcherIconRef","labelFieldRef","multipleRef","options","exposedMethods","cssVarsRef","common","cubicBezierEaseInOut","self","fontSize","nodeBorderRadius","nodeColorHover","nodeColorPressed","nodeColorActive","arrowColor","loadingColor","nodeTextColor","nodeTextColorDisabled","dropMarkColor","themeClassHandle","mergedClsPrefix","mergedTheme","rtlEnabled","fNodes","aip","cssVars","themeClass","onRender","render","mergedFocusable","tabindex","treeClass","createNode","tmNode","clsPrefix","onAfterEnter","padding","container","content","class","theme","peers","Scrollbar","themeOverrides","peerOverrides","onKeydown","onFocusout","items","itemSize","ignoreItemResize","paddingTop","paddingBottom","bottom","paddingLeft","left","paddingRight","right","onScroll","onResize","showScrollbar","itemResizable","item","contentStyle","$slots","empty","Empty"],"sources":["/Users/krystal/Documents/GitHub/meetings_vue3/node_modules/naive-ui/es/tree/src/Tree.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { h, ref, toRef, computed, defineComponent, provide, watch, nextTick, watchEffect, inject } from 'vue';\nimport { createTreeMate, flatten, createIndexGetter } from 'treemate';\nimport { useMergedState } from 'vooks';\nimport { VVirtualList } from 'vueuc';\nimport { getPadding } from 'seemly';\nimport { treeSelectInjectionKey } from '../../tree-select/src/interface';\nimport { useConfig, useTheme, useThemeClass, useRtl } from '../../_mixins';\nimport { call, createDataKey, resolveSlot, warn, warnOnce } from '../../_utils';\nimport { NxScrollbar } from '../../_internal';\nimport { treeLight } from '../styles';\nimport NTreeNode from './TreeNode';\nimport { keysWithFilter, emptyImage, filterTree, isNodeDisabled } from './utils';\nimport { useKeyboard } from './keyboard';\nimport { treeInjectionKey } from './interface';\nimport MotionWrapper from './MotionWrapper';\nimport { defaultAllowDrop } from './dnd';\nimport style from './styles/index.cssr';\nimport { NEmpty } from '../../empty';\n// TODO:\n// During expanding, some node are mis-applied with :active style\n// Async dnd has bug\nconst ITEM_SIZE = 30; // 24 + 3 + 3\nexport function createTreeMateOptions(keyField, childrenField, disabledField) {\n    return {\n        getIsGroup() {\n            return false;\n        },\n        getKey(node) {\n            return node[keyField];\n        },\n        getChildren(node) {\n            return node[childrenField];\n        },\n        getDisabled(node) {\n            return !!(node[disabledField] || node.checkboxDisabled);\n        }\n    };\n}\nexport const treeSharedProps = {\n    allowCheckingNotLoaded: Boolean,\n    filter: Function,\n    defaultExpandAll: Boolean,\n    expandedKeys: Array,\n    keyField: {\n        type: String,\n        default: 'key'\n    },\n    labelField: {\n        type: String,\n        default: 'label'\n    },\n    childrenField: {\n        type: String,\n        default: 'children'\n    },\n    disabledField: {\n        type: String,\n        default: 'disabled'\n    },\n    defaultExpandedKeys: {\n        type: Array,\n        default: () => []\n    },\n    indeterminateKeys: Array,\n    renderSwitcherIcon: Function,\n    onUpdateIndeterminateKeys: [Function, Array],\n    'onUpdate:indeterminateKeys': [Function, Array],\n    onUpdateExpandedKeys: [Function, Array],\n    'onUpdate:expandedKeys': [Function, Array]\n};\nexport const treeProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), { accordion: Boolean, showIrrelevantNodes: { type: Boolean, default: true }, data: {\n        type: Array,\n        default: () => []\n    }, expandOnDragenter: {\n        type: Boolean,\n        default: true\n    }, expandOnClick: Boolean, checkOnClick: {\n        type: [Boolean, Function],\n        default: false\n    }, cancelable: {\n        type: Boolean,\n        default: true\n    }, checkable: Boolean, draggable: Boolean, blockNode: Boolean, blockLine: Boolean, disabled: Boolean, checkedKeys: Array, defaultCheckedKeys: {\n        type: Array,\n        default: () => []\n    }, selectedKeys: Array, defaultSelectedKeys: {\n        type: Array,\n        default: () => []\n    }, multiple: Boolean, pattern: {\n        type: String,\n        default: ''\n    }, onLoad: Function, cascade: Boolean, selectable: {\n        type: Boolean,\n        default: true\n    }, indent: {\n        type: Number,\n        default: 16\n    }, allowDrop: {\n        type: Function,\n        default: defaultAllowDrop\n    }, animated: {\n        type: Boolean,\n        default: true\n    }, checkboxPlacement: {\n        type: String,\n        default: 'left'\n    }, virtualScroll: Boolean, watchProps: Array, renderLabel: Function, renderPrefix: Function, renderSuffix: Function, nodeProps: Function, keyboard: {\n        type: Boolean,\n        default: true\n    }, onDragenter: [Function, Array], onDragleave: [Function, Array], onDragend: [Function, Array], onDragstart: [Function, Array], onDragover: [Function, Array], onDrop: [Function, Array], onUpdateCheckedKeys: [Function, Array], 'onUpdate:checkedKeys': [Function, Array], onUpdateSelectedKeys: [Function, Array], 'onUpdate:selectedKeys': [Function, Array] }), treeSharedProps), { \n    // internal props for tree-select\n    internalTreeSelect: Boolean, internalScrollable: Boolean, internalScrollablePadding: String, \n    // use it to display\n    internalRenderEmpty: Function, internalHighlightKeySet: Object, internalUnifySelectCheck: Boolean, internalCheckboxFocusable: {\n        type: Boolean,\n        default: true\n    }, internalFocusable: {\n        // Make tree-select take over keyboard operations\n        type: Boolean,\n        default: true\n    }, checkStrategy: {\n        type: String,\n        default: 'all'\n    }, \n    /**\n     * @deprecated\n     */\n    leafOnly: Boolean });\nexport default defineComponent({\n    name: 'Tree',\n    props: treeProps,\n    setup(props) {\n        if (process.env.NODE_ENV !== 'production') {\n            watchEffect(() => {\n                if (props.leafOnly) {\n                    warnOnce('tree', '`leaf-only` is deprecated, please use `check-strategy=\"child\"` instead');\n                }\n            });\n        }\n        const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);\n        const rtlEnabledRef = useRtl('Tree', mergedRtlRef, mergedClsPrefixRef);\n        const themeRef = useTheme('Tree', '-tree', style, treeLight, props, mergedClsPrefixRef);\n        const selfElRef = ref(null);\n        const scrollbarInstRef = ref(null);\n        const virtualListInstRef = ref(null);\n        function getScrollContainer() {\n            var _a;\n            return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.listElRef;\n        }\n        function getScrollContent() {\n            var _a;\n            return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.itemsElRef;\n        }\n        const filteredTreeInfoRef = computed(() => {\n            const { pattern } = props;\n            if (!pattern) {\n                return {\n                    filteredTree: props.data,\n                    highlightKeySet: null,\n                    expandedKeys: undefined\n                };\n            }\n            if (!pattern.length || !mergedFilterRef.value) {\n                return {\n                    filteredTree: props.data,\n                    highlightKeySet: null,\n                    expandedKeys: undefined\n                };\n            }\n            return filterTree(props.data, mergedFilterRef.value, pattern, props.keyField, props.childrenField);\n        });\n        // We don't expect data source to change so we just determine it once\n        const displayTreeMateRef = computed(() => createTreeMate(props.showIrrelevantNodes\n            ? props.data\n            : filteredTreeInfoRef.value.filteredTree, createTreeMateOptions(props.keyField, props.childrenField, props.disabledField)));\n        const treeSelectInjection = inject(treeSelectInjectionKey, null);\n        const dataTreeMateRef = props.internalTreeSelect\n            ? treeSelectInjection.dataTreeMate\n            : displayTreeMateRef;\n        const { watchProps } = props;\n        const uncontrolledCheckedKeysRef = ref([]);\n        if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultCheckedKeys')) {\n            watchEffect(() => {\n                uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;\n            });\n        }\n        else {\n            uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;\n        }\n        const controlledCheckedKeysRef = toRef(props, 'checkedKeys');\n        const mergedCheckedKeysRef = useMergedState(controlledCheckedKeysRef, uncontrolledCheckedKeysRef);\n        const checkedStatusRef = computed(() => {\n            const value = dataTreeMateRef.value.getCheckedKeys(mergedCheckedKeysRef.value, {\n                cascade: props.cascade,\n                allowNotLoaded: props.allowCheckingNotLoaded\n            });\n            return value;\n        });\n        const mergedCheckStrategyRef = computed(() => props.leafOnly ? 'child' : props.checkStrategy);\n        const displayedCheckedKeysRef = computed(() => {\n            return checkedStatusRef.value.checkedKeys;\n        });\n        const displayedIndeterminateKeysRef = computed(() => {\n            const { indeterminateKeys } = props;\n            if (indeterminateKeys !== undefined)\n                return indeterminateKeys;\n            return checkedStatusRef.value.indeterminateKeys;\n        });\n        const uncontrolledSelectedKeysRef = ref([]);\n        if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultSelectedKeys')) {\n            watchEffect(() => {\n                uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;\n            });\n        }\n        else {\n            uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;\n        }\n        const controlledSelectedKeysRef = toRef(props, 'selectedKeys');\n        const mergedSelectedKeysRef = useMergedState(controlledSelectedKeysRef, uncontrolledSelectedKeysRef);\n        const uncontrolledExpandedKeysRef = ref([]);\n        const initUncontrolledExpandedKeys = (keys) => {\n            uncontrolledExpandedKeysRef.value = props.defaultExpandAll\n                ? dataTreeMateRef.value.getNonLeafKeys()\n                : keys === undefined\n                    ? props.defaultExpandedKeys\n                    : keys;\n        };\n        if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultExpandedKeys')) {\n            // if watching defaultExpandedKeys, we use access props.defaultExpandedKeys inside initiator\n            watchEffect(() => initUncontrolledExpandedKeys(undefined));\n        }\n        else {\n            // We by default watchEffect since if defaultExpandAll is true, we should remain tree expand if data changes\n            watchEffect(() => initUncontrolledExpandedKeys(props.defaultExpandedKeys));\n        }\n        const controlledExpandedKeysRef = toRef(props, 'expandedKeys');\n        const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);\n        const fNodesRef = computed(() => displayTreeMateRef.value.getFlattenedNodes(mergedExpandedKeysRef.value));\n        const { pendingNodeKeyRef, handleKeydown } = useKeyboard({\n            props,\n            mergedSelectedKeysRef,\n            fNodesRef,\n            mergedExpandedKeysRef,\n            handleSelect,\n            handleSwitcherClick\n        });\n        let expandTimerId = null;\n        let nodeKeyToBeExpanded = null;\n        const uncontrolledHighlightKeySetRef = ref(new Set());\n        const controlledHighlightKeySetRef = computed(() => {\n            return (props.internalHighlightKeySet ||\n                filteredTreeInfoRef.value.highlightKeySet);\n        });\n        const mergedHighlightKeySetRef = useMergedState(controlledHighlightKeySetRef, uncontrolledHighlightKeySetRef);\n        const loadingKeysRef = ref(new Set());\n        const expandedNonLoadingKeysRef = computed(() => {\n            return mergedExpandedKeysRef.value.filter((key) => !loadingKeysRef.value.has(key));\n        });\n        let dragStartX = 0;\n        const draggingNodeRef = ref(null);\n        const droppingNodeRef = ref(null);\n        const droppingMouseNodeRef = ref(null);\n        const droppingPositionRef = ref(null);\n        const droppingOffsetLevelRef = ref(0);\n        const droppingNodeParentRef = computed(() => {\n            const { value: droppingNode } = droppingNodeRef;\n            if (!droppingNode)\n                return null;\n            // May avoid overlap between line mark of first child & rect mark of parent\n            // if (droppingNode.isFirstChild && droppingPositionRef.value === 'before') {\n            //   return null\n            // }\n            return droppingNode.parent;\n        });\n        const mergedFilterRef = computed(() => {\n            const { filter } = props;\n            if (filter)\n                return filter;\n            const { labelField } = props;\n            return (pattern, node) => {\n                if (!pattern.length)\n                    return true;\n                const label = node[labelField];\n                if (typeof label === 'string') {\n                    return label.toLowerCase().includes(pattern.toLowerCase());\n                }\n                return false;\n            };\n        });\n        // shallow watch data\n        watch(toRef(props, 'data'), () => {\n            loadingKeysRef.value.clear();\n            pendingNodeKeyRef.value = null;\n            resetDndState();\n        }, {\n            deep: false\n        });\n        let expandAnimationDisabled = false;\n        const disableExpandAnimationForOneTick = () => {\n            expandAnimationDisabled = true;\n            void nextTick(() => {\n                expandAnimationDisabled = false;\n            });\n        };\n        let memoizedExpandedKeys;\n        watch(toRef(props, 'pattern'), (value, oldValue) => {\n            if (props.showIrrelevantNodes) {\n                memoizedExpandedKeys = undefined;\n                if (value) {\n                    const { expandedKeys: expandedKeysAfterChange, highlightKeySet } = keysWithFilter(props.data, props.pattern, props.keyField, props.childrenField, mergedFilterRef.value);\n                    uncontrolledHighlightKeySetRef.value = highlightKeySet;\n                    disableExpandAnimationForOneTick();\n                    doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange));\n                }\n                else {\n                    uncontrolledHighlightKeySetRef.value = new Set();\n                }\n            }\n            else {\n                if (!value.length) {\n                    if (memoizedExpandedKeys !== undefined) {\n                        disableExpandAnimationForOneTick();\n                        doUpdateExpandedKeys(memoizedExpandedKeys, getOptionsByKeys(memoizedExpandedKeys));\n                    }\n                }\n                else {\n                    if (!oldValue.length) {\n                        memoizedExpandedKeys = mergedExpandedKeysRef.value;\n                    }\n                    const { expandedKeys } = filteredTreeInfoRef.value;\n                    if (expandedKeys !== undefined) {\n                        disableExpandAnimationForOneTick();\n                        doUpdateExpandedKeys(expandedKeys, getOptionsByKeys(expandedKeys));\n                    }\n                }\n            }\n        });\n        function triggerLoading(node) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const { onLoad } = props;\n                if (!onLoad) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        warn('tree', 'There is unloaded node in data but props.onLoad is not specified.');\n                    }\n                    return yield Promise.resolve();\n                }\n                const { value: loadingKeys } = loadingKeysRef;\n                return yield new Promise((resolve) => {\n                    if (!loadingKeys.has(node.key)) {\n                        loadingKeys.add(node.key);\n                        onLoad(node.rawNode)\n                            .then(() => {\n                            loadingKeys.delete(node.key);\n                            resolve();\n                        })\n                            .catch((loadError) => {\n                            console.error(loadError);\n                            resetDragExpandState();\n                        });\n                    }\n                });\n            });\n        }\n        watchEffect(() => {\n            var _a;\n            const { value: displayTreeMate } = displayTreeMateRef;\n            if (!displayTreeMate)\n                return;\n            const { getNode } = displayTreeMate;\n            (_a = mergedExpandedKeysRef.value) === null || _a === void 0 ? void 0 : _a.forEach((key) => {\n                const node = getNode(key);\n                if (node && !node.shallowLoaded) {\n                    void triggerLoading(node);\n                }\n            });\n        });\n        // animation in progress\n        const aipRef = ref(false);\n        // animation flattened nodes\n        const afNodesRef = ref([]);\n        // Note: Since the virtual list depends on min height, if there's a node\n        // whose height starts from 0, the virtual list will have a wrong height\n        // during animation. This will seldom cause wired scrollbar status. It is\n        // fixable and need some changes in vueuc, I've no time so I just leave it\n        // here. Maybe the bug won't be fixed during the life time of the project.\n        watch(expandedNonLoadingKeysRef, (value, prevValue) => {\n            if (!props.animated || expandAnimationDisabled) {\n                void nextTick(syncScrollbar);\n                return;\n            }\n            const prevVSet = new Set(prevValue);\n            let addedKey = null;\n            let removedKey = null;\n            for (const expandedKey of value) {\n                if (!prevVSet.has(expandedKey)) {\n                    if (addedKey !== null)\n                        return; // multi expand, not triggered by click\n                    addedKey = expandedKey;\n                }\n            }\n            const currentVSet = new Set(value);\n            for (const expandedKey of prevValue) {\n                if (!currentVSet.has(expandedKey)) {\n                    if (removedKey !== null)\n                        return; // multi collapse, not triggered by click\n                    removedKey = expandedKey;\n                }\n            }\n            if (addedKey === null && removedKey === null) {\n                // 1. multi action, not triggered by click\n                // 2. no action, don't know what happened\n                return;\n            }\n            const { virtualScroll } = props;\n            const viewportHeight = (virtualScroll ? virtualListInstRef.value.listElRef : selfElRef.value).offsetHeight;\n            const viewportItemCount = Math.ceil(viewportHeight / ITEM_SIZE) + 1;\n            // play add animation\n            let baseExpandedKeys;\n            if (addedKey !== null) {\n                baseExpandedKeys = prevValue;\n            }\n            if (removedKey !== null) {\n                if (baseExpandedKeys === undefined) {\n                    baseExpandedKeys = value;\n                }\n                else {\n                    baseExpandedKeys = baseExpandedKeys.filter((key) => key !== removedKey);\n                }\n            }\n            aipRef.value = true;\n            afNodesRef.value =\n                displayTreeMateRef.value.getFlattenedNodes(baseExpandedKeys);\n            if (addedKey !== null) {\n                const expandedNodeIndex = afNodesRef.value.findIndex((node) => node.key === addedKey);\n                if (~expandedNodeIndex) {\n                    const children = // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                     afNodesRef.value[expandedNodeIndex].children;\n                    // sometimes user will pass leaf keys in\n                    if (children) {\n                        const expandedChildren = flatten(children, value);\n                        afNodesRef.value.splice(expandedNodeIndex + 1, 0, {\n                            __motion: true,\n                            mode: 'expand',\n                            height: virtualScroll\n                                ? expandedChildren.length * ITEM_SIZE\n                                : undefined,\n                            nodes: virtualScroll\n                                ? expandedChildren.slice(0, viewportItemCount)\n                                : expandedChildren\n                        });\n                    }\n                }\n            }\n            if (removedKey !== null) {\n                const collapsedNodeIndex = afNodesRef.value.findIndex((node) => node.key === removedKey);\n                if (~collapsedNodeIndex) {\n                    const collapsedNodeChildren = afNodesRef.value[collapsedNodeIndex].children;\n                    // Sometime the whole tree is change, remove a key doesn't mean it is collapsed,\n                    // but maybe children removed\n                    if (!collapsedNodeChildren)\n                        return;\n                    // play remove animation\n                    aipRef.value = true;\n                    const collapsedChildren = flatten(collapsedNodeChildren, value);\n                    afNodesRef.value.splice(collapsedNodeIndex + 1, 0, {\n                        __motion: true,\n                        mode: 'collapse',\n                        height: virtualScroll\n                            ? collapsedChildren.length * ITEM_SIZE\n                            : undefined,\n                        nodes: virtualScroll\n                            ? collapsedChildren.slice(0, viewportItemCount)\n                            : collapsedChildren\n                    });\n                }\n            }\n        });\n        const getFIndexRef = computed(() => {\n            return createIndexGetter(fNodesRef.value);\n        });\n        const mergedFNodesRef = computed(() => {\n            if (aipRef.value)\n                return afNodesRef.value;\n            else\n                return fNodesRef.value;\n        });\n        function syncScrollbar() {\n            const { value: scrollbarInst } = scrollbarInstRef;\n            if (scrollbarInst)\n                scrollbarInst.sync();\n        }\n        function handleAfterEnter() {\n            aipRef.value = false;\n            if (props.virtualScroll) {\n                // If virtual scroll, we won't listen to resize during animation, so\n                // resize callback of virtual list won't be called and as a result\n                // scrollbar won't sync. We need to sync scrollbar manually.\n                void nextTick(syncScrollbar);\n            }\n        }\n        function getOptionsByKeys(keys) {\n            const { getNode } = dataTreeMateRef.value;\n            return keys.map((key) => { var _a; return ((_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode) || null; });\n        }\n        function doUpdateExpandedKeys(value, option) {\n            const { 'onUpdate:expandedKeys': _onUpdateExpandedKeys, onUpdateExpandedKeys } = props;\n            uncontrolledExpandedKeysRef.value = value;\n            if (_onUpdateExpandedKeys) {\n                call(_onUpdateExpandedKeys, value, option);\n            }\n            if (onUpdateExpandedKeys) {\n                call(onUpdateExpandedKeys, value, option);\n            }\n        }\n        function doUpdateCheckedKeys(value, option) {\n            const { 'onUpdate:checkedKeys': _onUpdateCheckedKeys, onUpdateCheckedKeys } = props;\n            uncontrolledCheckedKeysRef.value = value;\n            if (onUpdateCheckedKeys) {\n                call(onUpdateCheckedKeys, value, option);\n            }\n            if (_onUpdateCheckedKeys) {\n                call(_onUpdateCheckedKeys, value, option);\n            }\n        }\n        function doUpdateIndeterminateKeys(value, option) {\n            const { 'onUpdate:indeterminateKeys': _onUpdateIndeterminateKeys, onUpdateIndeterminateKeys } = props;\n            if (_onUpdateIndeterminateKeys) {\n                call(_onUpdateIndeterminateKeys, value, option);\n            }\n            if (onUpdateIndeterminateKeys) {\n                call(onUpdateIndeterminateKeys, value, option);\n            }\n        }\n        function doUpdateSelectedKeys(value, option) {\n            const { 'onUpdate:selectedKeys': _onUpdateSelectedKeys, onUpdateSelectedKeys } = props;\n            uncontrolledSelectedKeysRef.value = value;\n            if (onUpdateSelectedKeys) {\n                call(onUpdateSelectedKeys, value, option);\n            }\n            if (_onUpdateSelectedKeys) {\n                call(_onUpdateSelectedKeys, value, option);\n            }\n        }\n        // Drag & Drop\n        function doDragEnter(info) {\n            const { onDragenter } = props;\n            if (onDragenter)\n                call(onDragenter, info);\n        }\n        function doDragLeave(info) {\n            const { onDragleave } = props;\n            if (onDragleave)\n                call(onDragleave, info);\n        }\n        function doDragEnd(info) {\n            const { onDragend } = props;\n            if (onDragend)\n                call(onDragend, info);\n        }\n        function doDragStart(info) {\n            const { onDragstart } = props;\n            if (onDragstart)\n                call(onDragstart, info);\n        }\n        function doDragOver(info) {\n            const { onDragover } = props;\n            if (onDragover)\n                call(onDragover, info);\n        }\n        function doDrop(info) {\n            const { onDrop } = props;\n            if (onDrop)\n                call(onDrop, info);\n        }\n        function resetDndState() {\n            resetDragState();\n            resetDropState();\n        }\n        function resetDragState() {\n            draggingNodeRef.value = null;\n        }\n        function resetDropState() {\n            droppingOffsetLevelRef.value = 0;\n            droppingNodeRef.value = null;\n            droppingMouseNodeRef.value = null;\n            droppingPositionRef.value = null;\n            resetDragExpandState();\n        }\n        function resetDragExpandState() {\n            if (expandTimerId) {\n                window.clearTimeout(expandTimerId);\n                expandTimerId = null;\n            }\n            nodeKeyToBeExpanded = null;\n        }\n        function handleCheck(node, checked) {\n            // We don't guard for leaf only since we have done it in view layer\n            if (props.disabled || isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            if (props.internalUnifySelectCheck && !props.multiple) {\n                handleSelect(node);\n                return;\n            }\n            const { checkedKeys, indeterminateKeys } = dataTreeMateRef.value[checked ? 'check' : 'uncheck'](node.key, displayedCheckedKeysRef.value, {\n                cascade: props.cascade,\n                checkStrategy: mergedCheckStrategyRef.value,\n                allowNotLoaded: props.allowCheckingNotLoaded\n            });\n            doUpdateCheckedKeys(checkedKeys, getOptionsByKeys(checkedKeys));\n            doUpdateIndeterminateKeys(indeterminateKeys, getOptionsByKeys(indeterminateKeys));\n        }\n        function toggleExpand(node) {\n            if (props.disabled)\n                return;\n            const { key } = node;\n            const { value: mergedExpandedKeys } = mergedExpandedKeysRef;\n            const index = mergedExpandedKeys.findIndex((expandNodeId) => expandNodeId === key);\n            if (~index) {\n                const expandedKeysAfterChange = Array.from(mergedExpandedKeys);\n                expandedKeysAfterChange.splice(index, 1);\n                doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange));\n            }\n            else {\n                const nodeToBeExpanded = displayTreeMateRef.value.getNode(key);\n                if (!nodeToBeExpanded || nodeToBeExpanded.isLeaf) {\n                    return;\n                }\n                let nextKeys;\n                if (props.accordion) {\n                    const siblingKeySet = new Set(node.siblings.map(({ key }) => key));\n                    nextKeys = mergedExpandedKeys.filter((expandedKey) => {\n                        return !siblingKeySet.has(expandedKey);\n                    });\n                    nextKeys.push(key);\n                }\n                else {\n                    nextKeys = mergedExpandedKeys.concat(key);\n                }\n                doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys));\n            }\n        }\n        function handleSwitcherClick(node) {\n            if (props.disabled || aipRef.value)\n                return;\n            toggleExpand(node);\n        }\n        function handleSelect(node) {\n            if (props.disabled || !props.selectable) {\n                return;\n            }\n            pendingNodeKeyRef.value = node.key;\n            if (props.internalUnifySelectCheck) {\n                const { value: { checkedKeys, indeterminateKeys } } = checkedStatusRef;\n                if (props.multiple) {\n                    handleCheck(node, !(checkedKeys.includes(node.key) ||\n                        indeterminateKeys.includes(node.key)));\n                }\n                else {\n                    doUpdateCheckedKeys([node.key], getOptionsByKeys([node.key]));\n                }\n            }\n            if (props.multiple) {\n                const selectedKeys = Array.from(mergedSelectedKeysRef.value);\n                const index = selectedKeys.findIndex((key) => key === node.key);\n                if (~index) {\n                    if (props.cancelable) {\n                        selectedKeys.splice(index, 1);\n                    }\n                }\n                else if (!~index) {\n                    selectedKeys.push(node.key);\n                }\n                doUpdateSelectedKeys(selectedKeys, getOptionsByKeys(selectedKeys));\n            }\n            else {\n                const selectedKeys = mergedSelectedKeysRef.value;\n                if (selectedKeys.includes(node.key)) {\n                    if (props.cancelable) {\n                        doUpdateSelectedKeys([], []);\n                    }\n                }\n                else {\n                    doUpdateSelectedKeys([node.key], getOptionsByKeys([node.key]));\n                }\n            }\n        }\n        function expandDragEnterNode(node) {\n            if (expandTimerId) {\n                window.clearTimeout(expandTimerId);\n                expandTimerId = null;\n            }\n            // Don't expand leaf node.\n            if (node.isLeaf)\n                return;\n            nodeKeyToBeExpanded = node.key;\n            const expand = () => {\n                if (nodeKeyToBeExpanded !== node.key)\n                    return;\n                const { value: droppingMouseNode } = droppingMouseNodeRef;\n                if (droppingMouseNode &&\n                    droppingMouseNode.key === node.key &&\n                    !mergedExpandedKeysRef.value.includes(node.key)) {\n                    const nextKeys = mergedExpandedKeysRef.value.concat(node.key);\n                    doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys));\n                }\n                expandTimerId = null;\n                nodeKeyToBeExpanded = null;\n            };\n            if (!node.shallowLoaded) {\n                expandTimerId = window.setTimeout(() => {\n                    void triggerLoading(node).then(() => {\n                        expand();\n                    });\n                }, 1000);\n            }\n            else {\n                expandTimerId = window.setTimeout(() => {\n                    expand();\n                }, 1000);\n            }\n        }\n        // Dnd\n        function handleDragEnter({ event, node }) {\n            // node should be a tmNode\n            if (!props.draggable ||\n                props.disabled ||\n                isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            handleDragOver({ event, node }, false);\n            doDragEnter({ event, node: node.rawNode });\n        }\n        function handleDragLeave({ event, node }) {\n            if (!props.draggable ||\n                props.disabled ||\n                isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            doDragLeave({ event, node: node.rawNode });\n        }\n        function handleDragLeaveTree(e) {\n            if (e.target !== e.currentTarget)\n                return;\n            resetDropState();\n        }\n        // Dragend is ok, we don't need to add global listener to reset drag status\n        function handleDragEnd({ event, node }) {\n            resetDndState();\n            if (!props.draggable ||\n                props.disabled ||\n                isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            doDragEnd({ event, node: node.rawNode });\n        }\n        function handleDragStart({ event, node }) {\n            var _a;\n            if (!props.draggable ||\n                props.disabled ||\n                isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            // Most of time, the image will block user's view\n            emptyImage && ((_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.setDragImage(emptyImage, 0, 0));\n            dragStartX = event.clientX;\n            draggingNodeRef.value = node;\n            doDragStart({ event, node: node.rawNode });\n        }\n        function handleDragOver({ event, node }, emit = true) {\n            var _a;\n            if (!props.draggable ||\n                props.disabled ||\n                isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            const { value: draggingNode } = draggingNodeRef;\n            if (!draggingNode)\n                return;\n            const { allowDrop, indent } = props;\n            if (emit)\n                doDragOver({ event, node: node.rawNode });\n            // Update dropping node\n            const el = event.currentTarget;\n            const { height: elOffsetHeight, top: elClientTop } = el.getBoundingClientRect();\n            const eventOffsetY = event.clientY - elClientTop;\n            let mousePosition;\n            const allowDropInside = allowDrop({\n                node: node.rawNode,\n                dropPosition: 'inside',\n                phase: 'drag'\n            });\n            if (allowDropInside) {\n                if (eventOffsetY <= 8) {\n                    mousePosition = 'before';\n                }\n                else if (eventOffsetY >= elOffsetHeight - 8) {\n                    mousePosition = 'after';\n                }\n                else {\n                    mousePosition = 'inside';\n                }\n            }\n            else {\n                if (eventOffsetY <= elOffsetHeight / 2) {\n                    mousePosition = 'before';\n                }\n                else {\n                    mousePosition = 'after';\n                }\n            }\n            const { value: getFindex } = getFIndexRef;\n            /** determine the drop position and drop node */\n            /** the dropping node needn't to be the mouse hovering node! */\n            /**\n             * if there is something i've learned from implementing a complex\n             * drag & drop. that is never write unit test before you really figure\n             * out what behavior is exactly you want.\n             */\n            let finalDropNode;\n            let finalDropPosition;\n            const hoverNodeFIndex = getFindex(node.key);\n            if (hoverNodeFIndex === null) {\n                resetDropState();\n                return;\n            }\n            let mouseAtExpandedNonLeafNode = false;\n            if (mousePosition === 'inside') {\n                finalDropNode = node;\n                finalDropPosition = 'inside';\n            }\n            else {\n                if (mousePosition === 'before') {\n                    if (node.isFirstChild) {\n                        finalDropNode = node;\n                        finalDropPosition = 'before';\n                    }\n                    else {\n                        finalDropNode = fNodesRef.value[hoverNodeFIndex - 1];\n                        finalDropPosition = 'after';\n                    }\n                }\n                else {\n                    finalDropNode = node;\n                    finalDropPosition = 'after';\n                }\n            }\n            // If the node is non-leaf and it is expanded, we don't allow it to\n            // drop after it and change it to drop before its next view sibling\n            if (!finalDropNode.isLeaf &&\n                mergedExpandedKeysRef.value.includes(finalDropNode.key)) {\n                mouseAtExpandedNonLeafNode = true;\n                if (finalDropPosition === 'after') {\n                    finalDropNode = fNodesRef.value[hoverNodeFIndex + 1];\n                    if (!finalDropNode) {\n                        // maybe there is no next view sibling when non-leaf node has no\n                        // children and it is the last node in the tree\n                        finalDropNode = node;\n                        finalDropPosition = 'inside';\n                    }\n                    else {\n                        finalDropPosition = 'before';\n                    }\n                }\n            }\n            const droppingMouseNode = finalDropNode;\n            droppingMouseNodeRef.value = droppingMouseNode;\n            // This is a speacial case, user is dragging a last child itself, so we\n            // only view it as they are trying to drop after it.\n            // There are some relevant codes in bailout 1's child branch.\n            // Also, the expand bailout should have a high priority. If it's non-leaf\n            // node and expanded, keep its origin drop position\n            if (!mouseAtExpandedNonLeafNode &&\n                draggingNode.isLastChild &&\n                draggingNode.key === finalDropNode.key) {\n                finalDropPosition = 'after';\n            }\n            if (finalDropPosition === 'after') {\n                let offset = dragStartX - event.clientX; // drag left => > 0\n                let offsetLevel = 0;\n                while (offset >= indent / 2 && // divide by 2 to make it easier to trigger\n                    finalDropNode.parent !== null &&\n                    finalDropNode.isLastChild &&\n                    offsetLevel < 1) {\n                    offset -= indent;\n                    offsetLevel += 1;\n                    finalDropNode = finalDropNode.parent;\n                }\n                droppingOffsetLevelRef.value = offsetLevel;\n            }\n            else {\n                droppingOffsetLevelRef.value = 0;\n            }\n            // Bailout 1\n            // Drag self into self\n            // Drag it into direct parent\n            if (draggingNode.contains(finalDropNode) ||\n                (finalDropPosition === 'inside' &&\n                    ((_a = draggingNode.parent) === null || _a === void 0 ? void 0 : _a.key) === finalDropNode.key)) {\n                if (draggingNode.key === droppingMouseNode.key &&\n                    draggingNode.key === finalDropNode.key) {\n                    // This is special case that we want ui to show a mark to guide user\n                    // to start dragging. Nor they will think nothing happens.\n                    // However this is an invalid drop, we need to guard it inside\n                    // handleDrop\n                }\n                else {\n                    resetDropState();\n                    return;\n                }\n            }\n            // Bailout 3\n            if (!allowDrop({\n                node: finalDropNode.rawNode,\n                dropPosition: finalDropPosition,\n                phase: 'drag'\n            })) {\n                resetDropState();\n                return;\n            }\n            if (draggingNode.key === finalDropNode.key) {\n                // don't expand when drag on itself\n                resetDragExpandState();\n            }\n            else {\n                if (nodeKeyToBeExpanded !== finalDropNode.key) {\n                    if (finalDropPosition === 'inside') {\n                        if (props.expandOnDragenter) {\n                            expandDragEnterNode(finalDropNode);\n                            // Bailout 4\n                            // not try to loading\n                            if (!finalDropNode.shallowLoaded &&\n                                nodeKeyToBeExpanded !== finalDropNode.key) {\n                                resetDndState();\n                                return;\n                            }\n                        }\n                        else {\n                            // Bailout 5\n                            // never expands on drag\n                            if (!finalDropNode.shallowLoaded) {\n                                resetDndState();\n                                return;\n                            }\n                        }\n                    }\n                    else {\n                        resetDragExpandState();\n                    }\n                }\n                else {\n                    if (finalDropPosition !== 'inside') {\n                        resetDragExpandState();\n                    }\n                }\n            }\n            droppingPositionRef.value = finalDropPosition;\n            droppingNodeRef.value = finalDropNode;\n        }\n        function handleDrop({ event, node, dropPosition }) {\n            if (!props.draggable ||\n                props.disabled ||\n                isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            const { value: draggingNode } = draggingNodeRef;\n            const { value: droppingNode } = droppingNodeRef;\n            const { value: droppingPosition } = droppingPositionRef;\n            if (!draggingNode || !droppingNode || !droppingPosition) {\n                return;\n            }\n            // Bailout 1\n            if (!props.allowDrop({\n                node: droppingNode.rawNode,\n                dropPosition: droppingPosition,\n                phase: 'drag'\n            })) {\n                return;\n            }\n            // Bailout 2\n            // This is a special case to guard since we want ui to show the status\n            // but not to emit a event\n            if (draggingNode.key === droppingNode.key) {\n                return;\n            }\n            // Bailout 3\n            // insert before its next node\n            // insert after its prev node\n            if (droppingPosition === 'before') {\n                const nextNode = draggingNode.getNext({ includeDisabled: true });\n                if (nextNode) {\n                    if (nextNode.key === droppingNode.key) {\n                        resetDropState();\n                        return;\n                    }\n                }\n            }\n            if (droppingPosition === 'after') {\n                const prevNode = draggingNode.getPrev({ includeDisabled: true });\n                if (prevNode) {\n                    if (prevNode.key === droppingNode.key) {\n                        resetDropState();\n                        return;\n                    }\n                }\n            }\n            doDrop({\n                event,\n                node: droppingNode.rawNode,\n                dragNode: draggingNode.rawNode,\n                dropPosition\n            });\n            resetDndState();\n        }\n        function handleScroll() {\n            syncScrollbar();\n        }\n        function handleResize() {\n            syncScrollbar();\n        }\n        function handleFocusout(e) {\n            var _a;\n            if (props.virtualScroll || props.internalScrollable) {\n                const { value: scrollbarInst } = scrollbarInstRef;\n                if ((_a = scrollbarInst === null || scrollbarInst === void 0 ? void 0 : scrollbarInst.containerRef) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) {\n                    return;\n                }\n                pendingNodeKeyRef.value = null;\n            }\n            else {\n                const { value: selfEl } = selfElRef;\n                if (selfEl === null || selfEl === void 0 ? void 0 : selfEl.contains(e.relatedTarget))\n                    return;\n                pendingNodeKeyRef.value = null;\n            }\n        }\n        watch(pendingNodeKeyRef, (value) => {\n            var _a, _b;\n            if (value === null)\n                return;\n            if (props.virtualScroll) {\n                (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({ key: value });\n            }\n            else if (props.internalScrollable) {\n                const { value: scrollbarInst } = scrollbarInstRef;\n                if (scrollbarInst === null)\n                    return;\n                const targetEl = (_b = scrollbarInst.contentRef) === null || _b === void 0 ? void 0 : _b.querySelector(`[data-key=\"${createDataKey(value)}\"]`);\n                if (!targetEl)\n                    return;\n                scrollbarInst.scrollTo({\n                    el: targetEl\n                });\n            }\n        });\n        provide(treeInjectionKey, {\n            loadingKeysRef,\n            highlightKeySetRef: mergedHighlightKeySetRef,\n            displayedCheckedKeysRef,\n            displayedIndeterminateKeysRef,\n            mergedSelectedKeysRef,\n            mergedExpandedKeysRef,\n            mergedThemeRef: themeRef,\n            mergedCheckStrategyRef,\n            nodePropsRef: toRef(props, 'nodeProps'),\n            disabledRef: toRef(props, 'disabled'),\n            checkableRef: toRef(props, 'checkable'),\n            selectableRef: toRef(props, 'selectable'),\n            expandOnClickRef: toRef(props, 'expandOnClick'),\n            onLoadRef: toRef(props, 'onLoad'),\n            draggableRef: toRef(props, 'draggable'),\n            blockLineRef: toRef(props, 'blockLine'),\n            indentRef: toRef(props, 'indent'),\n            cascadeRef: toRef(props, 'cascade'),\n            checkOnClickRef: toRef(props, 'checkOnClick'),\n            checkboxPlacementRef: props.checkboxPlacement,\n            droppingMouseNodeRef,\n            droppingNodeParentRef,\n            draggingNodeRef,\n            droppingPositionRef,\n            droppingOffsetLevelRef,\n            fNodesRef,\n            pendingNodeKeyRef,\n            disabledFieldRef: toRef(props, 'disabledField'),\n            internalScrollableRef: toRef(props, 'internalScrollable'),\n            internalCheckboxFocusableRef: toRef(props, 'internalCheckboxFocusable'),\n            internalTreeSelect: props.internalTreeSelect,\n            renderLabelRef: toRef(props, 'renderLabel'),\n            renderPrefixRef: toRef(props, 'renderPrefix'),\n            renderSuffixRef: toRef(props, 'renderSuffix'),\n            renderSwitcherIconRef: toRef(props, 'renderSwitcherIcon'),\n            labelFieldRef: toRef(props, 'labelField'),\n            multipleRef: toRef(props, 'multiple'),\n            handleSwitcherClick,\n            handleDragEnd,\n            handleDragEnter,\n            handleDragLeave,\n            handleDragStart,\n            handleDrop,\n            handleDragOver,\n            handleSelect,\n            handleCheck\n        });\n        function scrollTo(options) {\n            var _a;\n            (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(options);\n        }\n        const exposedMethods = {\n            handleKeydown,\n            scrollTo\n        };\n        const cssVarsRef = computed(() => {\n            const { common: { cubicBezierEaseInOut }, self: { fontSize, nodeBorderRadius, nodeColorHover, nodeColorPressed, nodeColorActive, arrowColor, loadingColor, nodeTextColor, nodeTextColorDisabled, dropMarkColor } } = themeRef.value;\n            return {\n                '--n-arrow-color': arrowColor,\n                '--n-loading-color': loadingColor,\n                '--n-bezier': cubicBezierEaseInOut,\n                '--n-font-size': fontSize,\n                '--n-node-border-radius': nodeBorderRadius,\n                '--n-node-color-active': nodeColorActive,\n                '--n-node-color-hover': nodeColorHover,\n                '--n-node-color-pressed': nodeColorPressed,\n                '--n-node-text-color': nodeTextColor,\n                '--n-node-text-color-disabled': nodeTextColorDisabled,\n                '--n-drop-mark-color': dropMarkColor\n            };\n        });\n        const themeClassHandle = inlineThemeDisabled\n            ? useThemeClass('tree', undefined, cssVarsRef, props)\n            : undefined;\n        return {\n            mergedClsPrefix: mergedClsPrefixRef,\n            mergedTheme: themeRef,\n            rtlEnabled: rtlEnabledRef,\n            fNodes: mergedFNodesRef,\n            aip: aipRef,\n            selfElRef,\n            virtualListInstRef,\n            scrollbarInstRef,\n            handleFocusout,\n            handleDragLeaveTree,\n            handleScroll,\n            getScrollContainer,\n            getScrollContent,\n            handleAfterEnter,\n            handleResize,\n            handleKeydown: exposedMethods.handleKeydown,\n            scrollTo: exposedMethods.scrollTo,\n            cssVars: inlineThemeDisabled ? undefined : cssVarsRef,\n            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,\n            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender\n        };\n    },\n    render() {\n        var _a;\n        const { fNodes, internalRenderEmpty } = this;\n        if (!fNodes.length && internalRenderEmpty) {\n            return internalRenderEmpty();\n        }\n        const { mergedClsPrefix, blockNode, blockLine, draggable, disabled, internalFocusable, checkable, handleKeydown, rtlEnabled, handleFocusout } = this;\n        const mergedFocusable = internalFocusable && !disabled;\n        const tabindex = mergedFocusable ? '0' : undefined;\n        const treeClass = [\n            `${mergedClsPrefix}-tree`,\n            rtlEnabled && `${mergedClsPrefix}-tree--rtl`,\n            checkable && `${mergedClsPrefix}-tree--checkable`,\n            (blockLine || blockNode) && `${mergedClsPrefix}-tree--block-node`,\n            blockLine && `${mergedClsPrefix}-tree--block-line`\n        ];\n        const createNode = (tmNode) => {\n            return '__motion' in tmNode ? (h(MotionWrapper, { height: tmNode.height, nodes: tmNode.nodes, clsPrefix: mergedClsPrefix, mode: tmNode.mode, onAfterEnter: this.handleAfterEnter })) : (h(NTreeNode, { key: tmNode.key, tmNode: tmNode, clsPrefix: mergedClsPrefix }));\n        };\n        if (this.virtualScroll) {\n            const { mergedTheme, internalScrollablePadding } = this;\n            const padding = getPadding(internalScrollablePadding || '0');\n            return (h(NxScrollbar, { ref: \"scrollbarInstRef\", onDragleave: draggable ? this.handleDragLeaveTree : undefined, container: this.getScrollContainer, content: this.getScrollContent, class: treeClass, theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, tabindex: tabindex, onKeydown: mergedFocusable ? handleKeydown : undefined, onFocusout: mergedFocusable ? handleFocusout : undefined }, {\n                default: () => {\n                    var _a;\n                    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n                    return (h(VVirtualList, { ref: \"virtualListInstRef\", items: this.fNodes, itemSize: ITEM_SIZE, ignoreItemResize: this.aip, paddingTop: padding.top, paddingBottom: padding.bottom, class: this.themeClass, style: [\n                            this.cssVars,\n                            {\n                                paddingLeft: padding.left,\n                                paddingRight: padding.right\n                            }\n                        ], onScroll: this.handleScroll, onResize: this.handleResize, showScrollbar: false, itemResizable: true }, {\n                        default: ({ item }) => createNode(item)\n                    }));\n                }\n            }));\n        }\n        const { internalScrollable } = this;\n        treeClass.push(this.themeClass);\n        (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n        if (internalScrollable) {\n            return (h(NxScrollbar, { class: treeClass, tabindex: tabindex, onKeydown: mergedFocusable ? handleKeydown : undefined, onFocusout: mergedFocusable ? handleFocusout : undefined, style: this.cssVars, contentStyle: { padding: this.internalScrollablePadding } }, {\n                default: () => (h(\"div\", { onDragleave: draggable ? this.handleDragLeaveTree : undefined, ref: \"selfElRef\" }, this.fNodes.map(createNode)))\n            }));\n        }\n        else {\n            return (h(\"div\", { class: treeClass, tabindex: tabindex, ref: \"selfElRef\", style: this.cssVars, onKeydown: mergedFocusable ? handleKeydown : undefined, onFocusout: mergedFocusable ? handleFocusout : undefined, onDragleave: draggable ? this.handleDragLeaveTree : undefined }, !fNodes.length\n                ? resolveSlot(this.$slots.empty, () => [\n                    h(NEmpty, { class: `${mergedClsPrefix}-tree__empty`, theme: this.mergedTheme.peers.Empty, themeOverrides: this.mergedTheme.peerOverrides.Empty })\n                ])\n                : fNodes.map(createNode)));\n        }\n    }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}