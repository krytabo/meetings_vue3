{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* eslint-disable no-void */\n/* eslint-disable @typescript-eslint/restrict-plus-operands */\nimport { mergeProps, computed, defineComponent, ref, onMounted, h, onActivated, onDeactivated } from 'vue';\nimport { beforeNextFrameOnce, depx, pxfy } from 'seemly';\nimport { useMemo } from 'vooks';\nimport { useSsrAdapter } from '@css-render/vue3-ssr';\nimport VResizeObserver from '../../resize-observer/src/VResizeObserver';\nimport { c, cssrAnchorMetaName, FinweckTree } from '../../shared';\nimport { ensureMaybeTouch, ensureWheelScale } from './config';\nconst styles = c('.v-vl', {\n  maxHeight: 'inherit',\n  height: '100%',\n  overflow: 'auto',\n  minWidth: '1px' // a zero width container won't be scrollable\n}, [c('&:not(.v-vl--show-scrollbar)', {\n  scrollbarWidth: 'none'\n}, [c('&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb', {\n  width: 0,\n  height: 0,\n  display: 'none'\n})])]);\nexport default defineComponent({\n  name: 'VirtualList',\n  inheritAttrs: false,\n  props: {\n    showScrollbar: {\n      type: Boolean,\n      default: true\n    },\n    items: {\n      type: Array,\n      default: () => []\n    },\n    // it is suppose to be the min height\n    itemSize: {\n      type: Number,\n      required: true\n    },\n    itemResizable: Boolean,\n    itemsStyle: [String, Object],\n    visibleItemsTag: {\n      type: [String, Object],\n      default: 'div'\n    },\n    visibleItemsProps: Object,\n    ignoreItemResize: Boolean,\n    onScroll: Function,\n    onWheel: Function,\n    onResize: Function,\n    defaultScrollKey: [Number, String],\n    defaultScrollIndex: Number,\n    keyField: {\n      type: String,\n      default: 'key'\n    },\n    // Whether it is a good API?\n    // ResizeObserver + footer & header is not enough.\n    // Too complex for simple case\n    paddingTop: {\n      type: [Number, String],\n      default: 0\n    },\n    paddingBottom: {\n      type: [Number, String],\n      default: 0\n    }\n  },\n  setup(props) {\n    const ssrAdapter = useSsrAdapter();\n    styles.mount({\n      id: 'vueuc/virtual-list',\n      head: true,\n      anchorMetaName: cssrAnchorMetaName,\n      ssr: ssrAdapter\n    });\n    onMounted(() => {\n      const {\n        defaultScrollIndex,\n        defaultScrollKey\n      } = props;\n      if (defaultScrollIndex !== undefined && defaultScrollIndex !== null) {\n        scrollTo({\n          index: defaultScrollIndex\n        });\n      } else if (defaultScrollKey !== undefined && defaultScrollKey !== null) {\n        scrollTo({\n          key: defaultScrollKey\n        });\n      }\n    });\n    let isDeactivated = false;\n    let activateStateInitialized = false;\n    onActivated(() => {\n      isDeactivated = false;\n      if (!activateStateInitialized) {\n        activateStateInitialized = true;\n        return;\n      }\n      // remount\n      scrollTo({\n        top: scrollTopRef.value,\n        left: scrollLeft\n      });\n    });\n    onDeactivated(() => {\n      isDeactivated = true;\n      if (!activateStateInitialized) {\n        activateStateInitialized = true;\n      }\n    });\n    const keyIndexMapRef = computed(() => {\n      const map = new Map();\n      const {\n        keyField\n      } = props;\n      props.items.forEach((item, index) => {\n        map.set(item[keyField], index);\n      });\n      return map;\n    });\n    const listElRef = ref(null);\n    const listHeightRef = ref(undefined);\n    const keyToHeightOffset = new Map();\n    const finweckTreeRef = computed(() => {\n      const {\n        items,\n        itemSize,\n        keyField\n      } = props;\n      const ft = new FinweckTree(items.length, itemSize);\n      items.forEach((item, index) => {\n        const key = item[keyField];\n        const heightOffset = keyToHeightOffset.get(key);\n        if (heightOffset !== undefined) {\n          ft.add(index, heightOffset);\n        }\n      });\n      return ft;\n    });\n    const finweckTreeUpdateTrigger = ref(0);\n    let scrollLeft = 0;\n    const scrollTopRef = ref(0);\n    const startIndexRef = useMemo(() => {\n      return Math.max(finweckTreeRef.value.getBound(scrollTopRef.value - depx(props.paddingTop)) - 1, 0);\n    });\n    const viewportItemsRef = computed(() => {\n      const {\n        value: listHeight\n      } = listHeightRef;\n      if (listHeight === undefined) return [];\n      const {\n        items,\n        itemSize\n      } = props;\n      const startIndex = startIndexRef.value;\n      const endIndex = Math.min(startIndex + Math.ceil(listHeight / itemSize + 1), items.length - 1);\n      const viewportItems = [];\n      for (let i = startIndex; i <= endIndex; ++i) {\n        viewportItems.push(items[i]);\n      }\n      return viewportItems;\n    });\n    const scrollTo = (options, y) => {\n      if (typeof options === 'number') {\n        scrollToPosition(options, y, 'auto');\n        return;\n      }\n      const {\n        left,\n        top,\n        index,\n        key,\n        position,\n        behavior,\n        debounce = true\n      } = options;\n      if (left !== undefined || top !== undefined) {\n        scrollToPosition(left, top, behavior);\n      } else if (index !== undefined) {\n        scrollToIndex(index, behavior, debounce);\n      } else if (key !== undefined) {\n        const toIndex = keyIndexMapRef.value.get(key);\n        if (toIndex !== undefined) scrollToIndex(toIndex, behavior, debounce);\n      } else if (position === 'bottom') {\n        scrollToPosition(0, Number.MAX_SAFE_INTEGER, behavior);\n      } else if (position === 'top') {\n        scrollToPosition(0, 0, behavior);\n      }\n    };\n    let anchorIndex;\n    let anchorTimerId = null;\n    function scrollToIndex(index, behavior, debounce) {\n      const {\n        value: ft\n      } = finweckTreeRef;\n      const targetTop = ft.sum(index) + depx(props.paddingTop);\n      if (!debounce) {\n        listElRef.value.scrollTo({\n          left: 0,\n          top: targetTop,\n          behavior\n        });\n      } else {\n        anchorIndex = index;\n        if (anchorTimerId !== null) {\n          window.clearTimeout(anchorTimerId);\n        }\n        anchorTimerId = window.setTimeout(() => {\n          anchorIndex = undefined;\n          anchorTimerId = null;\n        }, 16); // use 0 ms may be ealier than resize callback...\n        const {\n          scrollTop,\n          offsetHeight\n        } = listElRef.value;\n        if (targetTop > scrollTop) {\n          const itemSize = ft.get(index);\n          if (targetTop + itemSize <= scrollTop + offsetHeight) {\n            // do nothing\n          } else {\n            listElRef.value.scrollTo({\n              left: 0,\n              top: targetTop + itemSize - offsetHeight,\n              behavior\n            });\n          }\n        } else {\n          listElRef.value.scrollTo({\n            left: 0,\n            top: targetTop,\n            behavior\n          });\n        }\n      }\n    }\n    function scrollToPosition(left, top, behavior) {\n      listElRef.value.scrollTo({\n        left,\n        top,\n        behavior\n      });\n    }\n    function handleItemResize(key, entry) {\n      var _a, _b, _c;\n      if (isDeactivated) return;\n      if (props.ignoreItemResize) return;\n      if (isHideByVShow(entry.target)) return;\n      const {\n        value: ft\n      } = finweckTreeRef;\n      const index = keyIndexMapRef.value.get(key);\n      const previousHeight = ft.get(index);\n      const height = (_c = (_b = (_a = entry.borderBoxSize) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.blockSize) !== null && _c !== void 0 ? _c : entry.contentRect.height;\n      if (height === previousHeight) return;\n      // height offset based on itemSize\n      // used when rebuild the finweck tree\n      const offset = height - props.itemSize;\n      if (offset === 0) {\n        keyToHeightOffset.delete(key);\n      } else {\n        keyToHeightOffset.set(key, height - props.itemSize);\n      }\n      // delta height based on finweck tree data\n      const delta = height - previousHeight;\n      if (delta === 0) return;\n      ft.add(index, delta);\n      const listEl = listElRef.value;\n      if (listEl != null) {\n        if (anchorIndex === undefined) {\n          const previousHeightSum = ft.sum(index);\n          if (listEl.scrollTop > previousHeightSum) {\n            listEl.scrollBy(0, delta);\n          }\n        } else {\n          if (index < anchorIndex) {\n            listEl.scrollBy(0, delta);\n          } else if (index === anchorIndex) {\n            const previousHeightSum = ft.sum(index);\n            if (height + previousHeightSum >\n            // Note, listEl shouldn't have border, nor offsetHeight won't be\n            // correct\n            listEl.scrollTop + listEl.offsetHeight) {\n              listEl.scrollBy(0, delta);\n            }\n          }\n        }\n        syncViewport();\n      }\n      finweckTreeUpdateTrigger.value++;\n    }\n    const mayUseWheel = !ensureMaybeTouch();\n    let wheelCatched = false;\n    function handleListScroll(e) {\n      var _a;\n      (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);\n      if (!mayUseWheel || !wheelCatched) {\n        syncViewport();\n      }\n    }\n    function handleListWheel(e) {\n      var _a;\n      (_a = props.onWheel) === null || _a === void 0 ? void 0 : _a.call(props, e);\n      if (mayUseWheel) {\n        const listEl = listElRef.value;\n        if (listEl != null) {\n          if (e.deltaX === 0) {\n            if (listEl.scrollTop === 0 && e.deltaY <= 0) {\n              return;\n            }\n            if (listEl.scrollTop + listEl.offsetHeight >= listEl.scrollHeight && e.deltaY >= 0) {\n              return;\n            }\n          }\n          e.preventDefault();\n          listEl.scrollTop += e.deltaY / ensureWheelScale();\n          listEl.scrollLeft += e.deltaX / ensureWheelScale();\n          syncViewport();\n          wheelCatched = true;\n          beforeNextFrameOnce(() => {\n            wheelCatched = false;\n          });\n        }\n      }\n    }\n    function handleListResize(entry) {\n      if (isDeactivated) return;\n      // List is HTMLElement\n      if (isHideByVShow(entry.target)) return;\n      // If height is same, return\n      if (entry.contentRect.height === listHeightRef.value) return;\n      listHeightRef.value = entry.contentRect.height;\n      const {\n        onResize\n      } = props;\n      if (onResize !== undefined) onResize(entry);\n    }\n    function syncViewport() {\n      const {\n        value: listEl\n      } = listElRef;\n      // sometime ref el can be null\n      // https://github.com/TuSimple/naive-ui/issues/811\n      if (listEl == null) return;\n      scrollTopRef.value = listEl.scrollTop;\n      scrollLeft = listEl.scrollLeft;\n    }\n    function isHideByVShow(el) {\n      let cursor = el;\n      while (cursor !== null) {\n        if (cursor.style.display === 'none') return true;\n        cursor = cursor.parentElement;\n      }\n      return false;\n    }\n    return {\n      listHeight: listHeightRef,\n      listStyle: {\n        overflow: 'auto'\n      },\n      keyToIndex: keyIndexMapRef,\n      itemsStyle: computed(() => {\n        const {\n          itemResizable\n        } = props;\n        const height = pxfy(finweckTreeRef.value.sum());\n        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n        finweckTreeUpdateTrigger.value;\n        return [props.itemsStyle, {\n          boxSizing: 'content-box',\n          height: itemResizable ? '' : height,\n          minHeight: itemResizable ? height : '',\n          paddingTop: pxfy(props.paddingTop),\n          paddingBottom: pxfy(props.paddingBottom)\n        }];\n      }),\n      visibleItemsStyle: computed(() => {\n        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n        finweckTreeUpdateTrigger.value;\n        return {\n          transform: `translateY(${pxfy(finweckTreeRef.value.sum(startIndexRef.value))})`\n        };\n      }),\n      viewportItems: viewportItemsRef,\n      listElRef,\n      itemsElRef: ref(null),\n      scrollTo,\n      handleListResize,\n      handleListScroll,\n      handleListWheel,\n      handleItemResize\n    };\n  },\n  render() {\n    const {\n      itemResizable,\n      keyField,\n      keyToIndex,\n      visibleItemsTag\n    } = this;\n    return h(VResizeObserver, {\n      onResize: this.handleListResize\n    }, {\n      default: () => {\n        var _a, _b;\n        return h('div', mergeProps(this.$attrs, {\n          class: ['v-vl', this.showScrollbar && 'v-vl--show-scrollbar'],\n          onScroll: this.handleListScroll,\n          onWheel: this.handleListWheel,\n          ref: 'listElRef'\n        }), [this.items.length !== 0 ? h('div', {\n          ref: 'itemsElRef',\n          class: 'v-vl-items',\n          style: this.itemsStyle\n        }, [h(visibleItemsTag, Object.assign({\n          class: 'v-vl-visible-items',\n          style: this.visibleItemsStyle\n        }, this.visibleItemsProps), {\n          default: () => this.viewportItems.map(item => {\n            const key = item[keyField];\n            const index = keyToIndex.get(key);\n            const itemVNode = this.$slots.default({\n              item,\n              index\n            })[0];\n            if (itemResizable) {\n              return h(VResizeObserver, {\n                key,\n                onResize: entry => this.handleItemResize(key, entry)\n              }, {\n                default: () => itemVNode\n              });\n            }\n            itemVNode.key = key;\n            return itemVNode;\n          })\n        })]) : (_b = (_a = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a)]);\n      }\n    });\n  }\n});","map":{"version":3,"names":["mergeProps","computed","defineComponent","ref","onMounted","h","onActivated","onDeactivated","beforeNextFrameOnce","depx","pxfy","useMemo","useSsrAdapter","VResizeObserver","c","cssrAnchorMetaName","FinweckTree","ensureMaybeTouch","ensureWheelScale","styles","maxHeight","height","overflow","minWidth","scrollbarWidth","width","display","name","inheritAttrs","props","showScrollbar","type","Boolean","default","items","Array","itemSize","Number","required","itemResizable","itemsStyle","String","Object","visibleItemsTag","visibleItemsProps","ignoreItemResize","onScroll","Function","onWheel","onResize","defaultScrollKey","defaultScrollIndex","keyField","paddingTop","paddingBottom","setup","ssrAdapter","mount","id","head","anchorMetaName","ssr","undefined","scrollTo","index","key","isDeactivated","activateStateInitialized","top","scrollTopRef","value","left","scrollLeft","keyIndexMapRef","map","Map","forEach","item","set","listElRef","listHeightRef","keyToHeightOffset","finweckTreeRef","ft","length","heightOffset","get","add","finweckTreeUpdateTrigger","startIndexRef","Math","max","getBound","viewportItemsRef","listHeight","startIndex","endIndex","min","ceil","viewportItems","i","push","options","y","scrollToPosition","position","behavior","debounce","scrollToIndex","toIndex","MAX_SAFE_INTEGER","anchorIndex","anchorTimerId","targetTop","sum","window","clearTimeout","setTimeout","scrollTop","offsetHeight","handleItemResize","entry","_a","_b","_c","isHideByVShow","target","previousHeight","borderBoxSize","blockSize","contentRect","offset","delete","delta","listEl","previousHeightSum","scrollBy","syncViewport","mayUseWheel","wheelCatched","handleListScroll","e","call","handleListWheel","deltaX","deltaY","scrollHeight","preventDefault","handleListResize","el","cursor","style","parentElement","listStyle","keyToIndex","boxSizing","minHeight","visibleItemsStyle","transform","itemsElRef","render","$attrs","class","assign","itemVNode","$slots","empty"],"sources":["/Users/elmo/GitHub/meetings_vue3/node_modules/vueuc/es/virtual-list/src/VirtualList.js"],"sourcesContent":["/* eslint-disable no-void */\n/* eslint-disable @typescript-eslint/restrict-plus-operands */\nimport { mergeProps, computed, defineComponent, ref, onMounted, h, onActivated, onDeactivated } from 'vue';\nimport { beforeNextFrameOnce, depx, pxfy } from 'seemly';\nimport { useMemo } from 'vooks';\nimport { useSsrAdapter } from '@css-render/vue3-ssr';\nimport VResizeObserver from '../../resize-observer/src/VResizeObserver';\nimport { c, cssrAnchorMetaName, FinweckTree } from '../../shared';\nimport { ensureMaybeTouch, ensureWheelScale } from './config';\nconst styles = c('.v-vl', {\n    maxHeight: 'inherit',\n    height: '100%',\n    overflow: 'auto',\n    minWidth: '1px' // a zero width container won't be scrollable\n}, [\n    c('&:not(.v-vl--show-scrollbar)', {\n        scrollbarWidth: 'none'\n    }, [\n        c('&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb', {\n            width: 0,\n            height: 0,\n            display: 'none'\n        })\n    ])\n]);\nexport default defineComponent({\n    name: 'VirtualList',\n    inheritAttrs: false,\n    props: {\n        showScrollbar: {\n            type: Boolean,\n            default: true\n        },\n        items: {\n            type: Array,\n            default: () => []\n        },\n        // it is suppose to be the min height\n        itemSize: {\n            type: Number,\n            required: true\n        },\n        itemResizable: Boolean,\n        itemsStyle: [String, Object],\n        visibleItemsTag: {\n            type: [String, Object],\n            default: 'div'\n        },\n        visibleItemsProps: Object,\n        ignoreItemResize: Boolean,\n        onScroll: Function,\n        onWheel: Function,\n        onResize: Function,\n        defaultScrollKey: [Number, String],\n        defaultScrollIndex: Number,\n        keyField: {\n            type: String,\n            default: 'key'\n        },\n        // Whether it is a good API?\n        // ResizeObserver + footer & header is not enough.\n        // Too complex for simple case\n        paddingTop: {\n            type: [Number, String],\n            default: 0\n        },\n        paddingBottom: {\n            type: [Number, String],\n            default: 0\n        }\n    },\n    setup(props) {\n        const ssrAdapter = useSsrAdapter();\n        styles.mount({\n            id: 'vueuc/virtual-list',\n            head: true,\n            anchorMetaName: cssrAnchorMetaName,\n            ssr: ssrAdapter\n        });\n        onMounted(() => {\n            const { defaultScrollIndex, defaultScrollKey } = props;\n            if (defaultScrollIndex !== undefined && defaultScrollIndex !== null) {\n                scrollTo({ index: defaultScrollIndex });\n            }\n            else if (defaultScrollKey !== undefined && defaultScrollKey !== null) {\n                scrollTo({ key: defaultScrollKey });\n            }\n        });\n        let isDeactivated = false;\n        let activateStateInitialized = false;\n        onActivated(() => {\n            isDeactivated = false;\n            if (!activateStateInitialized) {\n                activateStateInitialized = true;\n                return;\n            }\n            // remount\n            scrollTo({ top: scrollTopRef.value, left: scrollLeft });\n        });\n        onDeactivated(() => {\n            isDeactivated = true;\n            if (!activateStateInitialized) {\n                activateStateInitialized = true;\n            }\n        });\n        const keyIndexMapRef = computed(() => {\n            const map = new Map();\n            const { keyField } = props;\n            props.items.forEach((item, index) => {\n                map.set(item[keyField], index);\n            });\n            return map;\n        });\n        const listElRef = ref(null);\n        const listHeightRef = ref(undefined);\n        const keyToHeightOffset = new Map();\n        const finweckTreeRef = computed(() => {\n            const { items, itemSize, keyField } = props;\n            const ft = new FinweckTree(items.length, itemSize);\n            items.forEach((item, index) => {\n                const key = item[keyField];\n                const heightOffset = keyToHeightOffset.get(key);\n                if (heightOffset !== undefined) {\n                    ft.add(index, heightOffset);\n                }\n            });\n            return ft;\n        });\n        const finweckTreeUpdateTrigger = ref(0);\n        let scrollLeft = 0;\n        const scrollTopRef = ref(0);\n        const startIndexRef = useMemo(() => {\n            return Math.max(finweckTreeRef.value.getBound(scrollTopRef.value - depx(props.paddingTop)) - 1, 0);\n        });\n        const viewportItemsRef = computed(() => {\n            const { value: listHeight } = listHeightRef;\n            if (listHeight === undefined)\n                return [];\n            const { items, itemSize } = props;\n            const startIndex = startIndexRef.value;\n            const endIndex = Math.min(startIndex + Math.ceil(listHeight / itemSize + 1), items.length - 1);\n            const viewportItems = [];\n            for (let i = startIndex; i <= endIndex; ++i) {\n                viewportItems.push(items[i]);\n            }\n            return viewportItems;\n        });\n        const scrollTo = (options, y) => {\n            if (typeof options === 'number') {\n                scrollToPosition(options, y, 'auto');\n                return;\n            }\n            const { left, top, index, key, position, behavior, debounce = true } = options;\n            if (left !== undefined || top !== undefined) {\n                scrollToPosition(left, top, behavior);\n            }\n            else if (index !== undefined) {\n                scrollToIndex(index, behavior, debounce);\n            }\n            else if (key !== undefined) {\n                const toIndex = keyIndexMapRef.value.get(key);\n                if (toIndex !== undefined)\n                    scrollToIndex(toIndex, behavior, debounce);\n            }\n            else if (position === 'bottom') {\n                scrollToPosition(0, Number.MAX_SAFE_INTEGER, behavior);\n            }\n            else if (position === 'top') {\n                scrollToPosition(0, 0, behavior);\n            }\n        };\n        let anchorIndex;\n        let anchorTimerId = null;\n        function scrollToIndex(index, behavior, debounce) {\n            const { value: ft } = finweckTreeRef;\n            const targetTop = ft.sum(index) + depx(props.paddingTop);\n            if (!debounce) {\n                listElRef.value.scrollTo({\n                    left: 0,\n                    top: targetTop,\n                    behavior\n                });\n            }\n            else {\n                anchorIndex = index;\n                if (anchorTimerId !== null) {\n                    window.clearTimeout(anchorTimerId);\n                }\n                anchorTimerId = window.setTimeout(() => {\n                    anchorIndex = undefined;\n                    anchorTimerId = null;\n                }, 16); // use 0 ms may be ealier than resize callback...\n                const { scrollTop, offsetHeight } = listElRef.value;\n                if (targetTop > scrollTop) {\n                    const itemSize = ft.get(index);\n                    if (targetTop + itemSize <= scrollTop + offsetHeight) {\n                        // do nothing\n                    }\n                    else {\n                        listElRef.value.scrollTo({\n                            left: 0,\n                            top: targetTop + itemSize - offsetHeight,\n                            behavior\n                        });\n                    }\n                }\n                else {\n                    listElRef.value.scrollTo({\n                        left: 0,\n                        top: targetTop,\n                        behavior\n                    });\n                }\n            }\n        }\n        function scrollToPosition(left, top, behavior) {\n            listElRef.value.scrollTo({\n                left,\n                top,\n                behavior\n            });\n        }\n        function handleItemResize(key, entry) {\n            var _a, _b, _c;\n            if (isDeactivated)\n                return;\n            if (props.ignoreItemResize)\n                return;\n            if (isHideByVShow(entry.target))\n                return;\n            const { value: ft } = finweckTreeRef;\n            const index = keyIndexMapRef.value.get(key);\n            const previousHeight = ft.get(index);\n            const height = (_c = (_b = (_a = entry.borderBoxSize) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.blockSize) !== null && _c !== void 0 ? _c : entry.contentRect.height;\n            if (height === previousHeight)\n                return;\n            // height offset based on itemSize\n            // used when rebuild the finweck tree\n            const offset = height - props.itemSize;\n            if (offset === 0) {\n                keyToHeightOffset.delete(key);\n            }\n            else {\n                keyToHeightOffset.set(key, height - props.itemSize);\n            }\n            // delta height based on finweck tree data\n            const delta = height - previousHeight;\n            if (delta === 0)\n                return;\n            ft.add(index, delta);\n            const listEl = listElRef.value;\n            if (listEl != null) {\n                if (anchorIndex === undefined) {\n                    const previousHeightSum = ft.sum(index);\n                    if (listEl.scrollTop > previousHeightSum) {\n                        listEl.scrollBy(0, delta);\n                    }\n                }\n                else {\n                    if (index < anchorIndex) {\n                        listEl.scrollBy(0, delta);\n                    }\n                    else if (index === anchorIndex) {\n                        const previousHeightSum = ft.sum(index);\n                        if (height + previousHeightSum >\n                            // Note, listEl shouldn't have border, nor offsetHeight won't be\n                            // correct\n                            listEl.scrollTop + listEl.offsetHeight) {\n                            listEl.scrollBy(0, delta);\n                        }\n                    }\n                }\n                syncViewport();\n            }\n            finweckTreeUpdateTrigger.value++;\n        }\n        const mayUseWheel = !ensureMaybeTouch();\n        let wheelCatched = false;\n        function handleListScroll(e) {\n            var _a;\n            (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);\n            if (!mayUseWheel || !wheelCatched) {\n                syncViewport();\n            }\n        }\n        function handleListWheel(e) {\n            var _a;\n            (_a = props.onWheel) === null || _a === void 0 ? void 0 : _a.call(props, e);\n            if (mayUseWheel) {\n                const listEl = listElRef.value;\n                if (listEl != null) {\n                    if (e.deltaX === 0) {\n                        if (listEl.scrollTop === 0 && e.deltaY <= 0) {\n                            return;\n                        }\n                        if (listEl.scrollTop + listEl.offsetHeight >= listEl.scrollHeight &&\n                            e.deltaY >= 0) {\n                            return;\n                        }\n                    }\n                    e.preventDefault();\n                    listEl.scrollTop += e.deltaY / ensureWheelScale();\n                    listEl.scrollLeft += e.deltaX / ensureWheelScale();\n                    syncViewport();\n                    wheelCatched = true;\n                    beforeNextFrameOnce(() => {\n                        wheelCatched = false;\n                    });\n                }\n            }\n        }\n        function handleListResize(entry) {\n            if (isDeactivated)\n                return;\n            // List is HTMLElement\n            if (isHideByVShow(entry.target))\n                return;\n            // If height is same, return\n            if (entry.contentRect.height === listHeightRef.value)\n                return;\n            listHeightRef.value = entry.contentRect.height;\n            const { onResize } = props;\n            if (onResize !== undefined)\n                onResize(entry);\n        }\n        function syncViewport() {\n            const { value: listEl } = listElRef;\n            // sometime ref el can be null\n            // https://github.com/TuSimple/naive-ui/issues/811\n            if (listEl == null)\n                return;\n            scrollTopRef.value = listEl.scrollTop;\n            scrollLeft = listEl.scrollLeft;\n        }\n        function isHideByVShow(el) {\n            let cursor = el;\n            while (cursor !== null) {\n                if (cursor.style.display === 'none')\n                    return true;\n                cursor = cursor.parentElement;\n            }\n            return false;\n        }\n        return {\n            listHeight: listHeightRef,\n            listStyle: {\n                overflow: 'auto'\n            },\n            keyToIndex: keyIndexMapRef,\n            itemsStyle: computed(() => {\n                const { itemResizable } = props;\n                const height = pxfy(finweckTreeRef.value.sum());\n                // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n                finweckTreeUpdateTrigger.value;\n                return [\n                    props.itemsStyle,\n                    {\n                        boxSizing: 'content-box',\n                        height: itemResizable ? '' : height,\n                        minHeight: itemResizable ? height : '',\n                        paddingTop: pxfy(props.paddingTop),\n                        paddingBottom: pxfy(props.paddingBottom)\n                    }\n                ];\n            }),\n            visibleItemsStyle: computed(() => {\n                // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n                finweckTreeUpdateTrigger.value;\n                return {\n                    transform: `translateY(${pxfy(finweckTreeRef.value.sum(startIndexRef.value))})`\n                };\n            }),\n            viewportItems: viewportItemsRef,\n            listElRef,\n            itemsElRef: ref(null),\n            scrollTo,\n            handleListResize,\n            handleListScroll,\n            handleListWheel,\n            handleItemResize\n        };\n    },\n    render() {\n        const { itemResizable, keyField, keyToIndex, visibleItemsTag } = this;\n        return h(VResizeObserver, {\n            onResize: this.handleListResize\n        }, {\n            default: () => {\n                var _a, _b;\n                return h('div', mergeProps(this.$attrs, {\n                    class: ['v-vl', this.showScrollbar && 'v-vl--show-scrollbar'],\n                    onScroll: this.handleListScroll,\n                    onWheel: this.handleListWheel,\n                    ref: 'listElRef'\n                }), [\n                    this.items.length !== 0\n                        ? h('div', {\n                            ref: 'itemsElRef',\n                            class: 'v-vl-items',\n                            style: this.itemsStyle\n                        }, [\n                            h(visibleItemsTag, Object.assign({\n                                class: 'v-vl-visible-items',\n                                style: this.visibleItemsStyle\n                            }, this.visibleItemsProps), {\n                                default: () => this.viewportItems.map((item) => {\n                                    const key = item[keyField];\n                                    const index = keyToIndex.get(key);\n                                    const itemVNode = this.$slots.default({\n                                        item,\n                                        index\n                                    })[0];\n                                    if (itemResizable) {\n                                        return h(VResizeObserver, {\n                                            key,\n                                            onResize: (entry) => this.handleItemResize(key, entry)\n                                        }, {\n                                            default: () => itemVNode\n                                        });\n                                    }\n                                    itemVNode.key = key;\n                                    return itemVNode;\n                                })\n                            })\n                        ])\n                        : (_b = (_a = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a)\n                ]);\n            }\n        });\n    }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}