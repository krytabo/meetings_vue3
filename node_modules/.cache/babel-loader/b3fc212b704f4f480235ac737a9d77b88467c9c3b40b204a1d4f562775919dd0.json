{"ast":null,"code":"export function getFirstAvailableNode(nodes) {\n  if (nodes.length === 0) return null;\n  const node = nodes[0];\n  if (node.isGroup || node.ignored || node.disabled) {\n    return node.getNext();\n  }\n  return node;\n}\nfunction rawGetNext(node, loop) {\n  const sibs = node.siblings;\n  const l = sibs.length;\n  const {\n    index\n  } = node;\n  if (loop) {\n    return sibs[(index + 1) % l];\n  } else {\n    if (index === sibs.length - 1) return null;\n    return sibs[index + 1];\n  }\n}\nfunction move(fromNode, dir, {\n  loop = false,\n  includeDisabled = false\n} = {}) {\n  const iterate = dir === 'prev' ? rawGetPrev : rawGetNext;\n  const getChildOptions = {\n    reverse: dir === 'prev'\n  };\n  let meet = false;\n  let endNode = null;\n  function traverse(node) {\n    if (node === null) return;\n    if (node === fromNode) {\n      if (!meet) {\n        meet = true;\n      } else if (!fromNode.disabled && !fromNode.isGroup) {\n        endNode = fromNode;\n        return;\n      }\n    } else {\n      if ((!node.disabled || includeDisabled) && !node.ignored && !node.isGroup) {\n        endNode = node;\n        return;\n      }\n    }\n    if (node.isGroup) {\n      const child = getChild(node, getChildOptions);\n      if (child !== null) {\n        endNode = child;\n      } else {\n        traverse(iterate(node, loop));\n      }\n    } else {\n      const nextNode = iterate(node, false);\n      if (nextNode !== null) {\n        traverse(nextNode);\n      } else {\n        const parent = rawGetParent(node);\n        if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {\n          traverse(iterate(parent, loop));\n        } else if (loop) {\n          traverse(iterate(node, true));\n        }\n      }\n    }\n  }\n  traverse(fromNode);\n  return endNode;\n}\nfunction rawGetPrev(node, loop) {\n  const sibs = node.siblings;\n  const l = sibs.length;\n  const {\n    index\n  } = node;\n  if (loop) {\n    return sibs[(index - 1 + l) % l];\n  } else {\n    if (index === 0) return null;\n    return sibs[index - 1];\n  }\n}\nfunction rawGetParent(node) {\n  return node.parent;\n}\nfunction getChild(node, options = {}) {\n  const {\n    reverse = false\n  } = options;\n  const {\n    children\n  } = node;\n  if (children) {\n    const {\n      length\n    } = children;\n    const start = reverse ? length - 1 : 0;\n    const end = reverse ? -1 : length;\n    const delta = reverse ? -1 : 1;\n    for (let i = start; i !== end; i += delta) {\n      const child = children[i];\n      if (!child.disabled && !child.ignored) {\n        if (child.isGroup) {\n          const childInGroup = getChild(child, options);\n          if (childInGroup !== null) return childInGroup;\n        } else {\n          return child;\n        }\n      }\n    }\n  }\n  return null;\n}\nexport const moveMethods = {\n  getChild() {\n    if (this.ignored) return null;\n    return getChild(this);\n  },\n  getParent() {\n    const {\n      parent\n    } = this;\n    if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {\n      return parent.getParent();\n    }\n    return parent;\n  },\n  getNext(options = {}) {\n    return move(this, 'next', options);\n  },\n  getPrev(options = {}) {\n    return move(this, 'prev', options);\n  }\n};","map":{"version":3,"names":["getFirstAvailableNode","nodes","length","node","isGroup","ignored","disabled","getNext","rawGetNext","loop","sibs","siblings","l","index","move","fromNode","dir","includeDisabled","iterate","rawGetPrev","getChildOptions","reverse","meet","endNode","traverse","child","getChild","nextNode","parent","rawGetParent","options","children","start","end","delta","i","childInGroup","moveMethods","getParent","getPrev"],"sources":["/Users/elmo/GitHub/meetings_vue3/node_modules/treemate/es/move.js"],"sourcesContent":["export function getFirstAvailableNode(nodes) {\n    if (nodes.length === 0)\n        return null;\n    const node = nodes[0];\n    if (node.isGroup || node.ignored || node.disabled) {\n        return node.getNext();\n    }\n    return node;\n}\nfunction rawGetNext(node, loop) {\n    const sibs = node.siblings;\n    const l = sibs.length;\n    const { index } = node;\n    if (loop) {\n        return sibs[(index + 1) % l];\n    }\n    else {\n        if (index === sibs.length - 1)\n            return null;\n        return sibs[index + 1];\n    }\n}\nfunction move(fromNode, dir, { loop = false, includeDisabled = false } = {}) {\n    const iterate = dir === 'prev' ? rawGetPrev : rawGetNext;\n    const getChildOptions = {\n        reverse: dir === 'prev'\n    };\n    let meet = false;\n    let endNode = null;\n    function traverse(node) {\n        if (node === null)\n            return;\n        if (node === fromNode) {\n            if (!meet) {\n                meet = true;\n            }\n            else if (!fromNode.disabled && !fromNode.isGroup) {\n                endNode = fromNode;\n                return;\n            }\n        }\n        else {\n            if ((!node.disabled || includeDisabled) &&\n                !node.ignored &&\n                !node.isGroup) {\n                endNode = node;\n                return;\n            }\n        }\n        if (node.isGroup) {\n            const child = getChild(node, getChildOptions);\n            if (child !== null) {\n                endNode = child;\n            }\n            else {\n                traverse(iterate(node, loop));\n            }\n        }\n        else {\n            const nextNode = iterate(node, false);\n            if (nextNode !== null) {\n                traverse(nextNode);\n            }\n            else {\n                const parent = rawGetParent(node);\n                if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {\n                    traverse(iterate(parent, loop));\n                }\n                else if (loop) {\n                    traverse(iterate(node, true));\n                }\n            }\n        }\n    }\n    traverse(fromNode);\n    return endNode;\n}\nfunction rawGetPrev(node, loop) {\n    const sibs = node.siblings;\n    const l = sibs.length;\n    const { index } = node;\n    if (loop) {\n        return sibs[(index - 1 + l) % l];\n    }\n    else {\n        if (index === 0)\n            return null;\n        return sibs[index - 1];\n    }\n}\nfunction rawGetParent(node) {\n    return node.parent;\n}\nfunction getChild(node, options = {}) {\n    const { reverse = false } = options;\n    const { children } = node;\n    if (children) {\n        const { length } = children;\n        const start = reverse ? length - 1 : 0;\n        const end = reverse ? -1 : length;\n        const delta = reverse ? -1 : 1;\n        for (let i = start; i !== end; i += delta) {\n            const child = children[i];\n            if (!child.disabled && !child.ignored) {\n                if (child.isGroup) {\n                    const childInGroup = getChild(child, options);\n                    if (childInGroup !== null)\n                        return childInGroup;\n                }\n                else {\n                    return child;\n                }\n            }\n        }\n    }\n    return null;\n}\nexport const moveMethods = {\n    getChild() {\n        if (this.ignored)\n            return null;\n        return getChild(this);\n    },\n    getParent() {\n        const { parent } = this;\n        if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {\n            return parent.getParent();\n        }\n        return parent;\n    },\n    getNext(options = {}) {\n        return move(this, 'next', options);\n    },\n    getPrev(options = {}) {\n        return move(this, 'prev', options);\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}