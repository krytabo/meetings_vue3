{"ast":null,"code":"/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { h, defineComponent, inject, nextTick, watch, toRef, ref, onMounted, onBeforeUnmount, withDirectives } from 'vue';\nimport { zindexable } from 'vdirs';\nimport { useMemo, useIsMounted, onFontsReady } from 'vooks';\nimport { useSsrAdapter } from '@css-render/vue3-ssr';\nimport { c, cssrAnchorMetaName } from '../../shared';\nimport LazyTeleport from '../../lazy-teleport/src/index';\nimport { getPlacementAndOffsetOfFollower, getProperTransformOrigin, getOffset } from './get-placement-style';\nimport { getPointRect, getRect } from './utils';\nconst style = c([c('.v-binder-follower-container', {\n  position: 'absolute',\n  left: '0',\n  right: '0',\n  top: '0',\n  height: '0',\n  pointerEvents: 'none',\n  zIndex: 'auto'\n}), c('.v-binder-follower-content', {\n  position: 'absolute',\n  zIndex: 'auto'\n}, [c('> *', {\n  pointerEvents: 'all'\n})])]);\nexport default defineComponent({\n  name: 'Follower',\n  inheritAttrs: false,\n  props: {\n    show: Boolean,\n    enabled: {\n      type: Boolean,\n      default: undefined\n    },\n    placement: {\n      type: String,\n      default: 'bottom'\n    },\n    syncTrigger: {\n      type: Array,\n      default: ['resize', 'scroll']\n    },\n    to: [String, Object],\n    flip: {\n      type: Boolean,\n      default: true\n    },\n    internalShift: Boolean,\n    x: Number,\n    y: Number,\n    width: String,\n    minWidth: String,\n    containerClass: String,\n    teleportDisabled: Boolean,\n    zindexable: {\n      type: Boolean,\n      default: true\n    },\n    zIndex: Number,\n    overlap: Boolean\n  },\n  setup(props) {\n    const VBinder = inject('VBinder');\n    const mergedEnabledRef = useMemo(() => {\n      return props.enabled !== undefined ? props.enabled : props.show;\n    });\n    const followerRef = ref(null);\n    const offsetContainerRef = ref(null);\n    const ensureListeners = () => {\n      const {\n        syncTrigger\n      } = props;\n      if (syncTrigger.includes('scroll')) {\n        VBinder.addScrollListener(syncPosition);\n      }\n      if (syncTrigger.includes('resize')) {\n        VBinder.addResizeListener(syncPosition);\n      }\n    };\n    const removeListeners = () => {\n      VBinder.removeScrollListener(syncPosition);\n      VBinder.removeResizeListener(syncPosition);\n    };\n    onMounted(() => {\n      if (mergedEnabledRef.value) {\n        syncPosition();\n        ensureListeners();\n      }\n    });\n    const ssrAdapter = useSsrAdapter();\n    style.mount({\n      id: 'vueuc/binder',\n      head: true,\n      anchorMetaName: cssrAnchorMetaName,\n      ssr: ssrAdapter\n    });\n    onBeforeUnmount(() => {\n      removeListeners();\n    });\n    onFontsReady(() => {\n      if (mergedEnabledRef.value) {\n        syncPosition();\n      }\n    });\n    const syncPosition = () => {\n      if (!mergedEnabledRef.value) {\n        return;\n      }\n      const follower = followerRef.value;\n      // sometimes watched props change before its dom is ready\n      // for example: show=false, x=undefined, y=undefined\n      //              show=true,  x=0,         y=0\n      // will cause error\n      // I may optimize the watch start point later\n      if (follower === null) return;\n      const target = VBinder.targetRef;\n      const {\n        x,\n        y,\n        overlap\n      } = props;\n      const targetRect = x !== undefined && y !== undefined ? getPointRect(x, y) : getRect(target);\n      follower.style.setProperty('--v-target-width', `${Math.round(targetRect.width)}px`);\n      follower.style.setProperty('--v-target-height', `${Math.round(targetRect.height)}px`);\n      const {\n        width,\n        minWidth,\n        placement,\n        internalShift,\n        flip\n      } = props;\n      follower.setAttribute('v-placement', placement);\n      if (overlap) {\n        follower.setAttribute('v-overlap', '');\n      } else {\n        follower.removeAttribute('v-overlap');\n      }\n      const {\n        style\n      } = follower;\n      if (width === 'target') {\n        style.width = `${targetRect.width}px`;\n      } else if (width !== undefined) {\n        style.width = width;\n      } else {\n        style.width = '';\n      }\n      if (minWidth === 'target') {\n        style.minWidth = `${targetRect.width}px`;\n      } else if (minWidth !== undefined) {\n        style.minWidth = minWidth;\n      } else {\n        style.minWidth = '';\n      }\n      const followerRect = getRect(follower);\n      const offsetContainerRect = getRect(offsetContainerRef.value);\n      const {\n        left: offsetLeftToStandardPlacement,\n        top: offsetTopToStandardPlacement,\n        placement: properPlacement\n      } = getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, internalShift, flip, overlap);\n      const properTransformOrigin = getProperTransformOrigin(properPlacement, overlap);\n      const {\n        left,\n        top,\n        transform\n      } = getOffset(properPlacement, offsetContainerRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap);\n      // we assume that the content size doesn't change after flip,\n      // nor we need to make sync logic more complex\n      follower.setAttribute('v-placement', properPlacement);\n      follower.style.setProperty('--v-offset-left', `${Math.round(offsetLeftToStandardPlacement)}px`);\n      follower.style.setProperty('--v-offset-top', `${Math.round(offsetTopToStandardPlacement)}px`);\n      follower.style.transform = `translateX(${left}) translateY(${top}) ${transform}`;\n      follower.style.setProperty('--v-transform-origin', properTransformOrigin);\n      follower.style.transformOrigin = properTransformOrigin;\n    };\n    watch(mergedEnabledRef, value => {\n      if (value) {\n        ensureListeners();\n        syncOnNextTick();\n      } else {\n        removeListeners();\n      }\n    });\n    const syncOnNextTick = () => {\n      nextTick().then(syncPosition).catch(e => console.error(e));\n    };\n    ['placement', 'x', 'y', 'internalShift', 'flip', 'width', 'overlap', 'minWidth'].forEach(prop => {\n      watch(toRef(props, prop), syncPosition);\n    });\n    ['teleportDisabled'].forEach(prop => {\n      watch(toRef(props, prop), syncOnNextTick);\n    });\n    watch(toRef(props, 'syncTrigger'), value => {\n      if (!value.includes('resize')) {\n        VBinder.removeResizeListener(syncPosition);\n      } else {\n        VBinder.addResizeListener(syncPosition);\n      }\n      if (!value.includes('scroll')) {\n        VBinder.removeScrollListener(syncPosition);\n      } else {\n        VBinder.addScrollListener(syncPosition);\n      }\n    });\n    const isMountedRef = useIsMounted();\n    const mergedToRef = useMemo(() => {\n      const {\n        to\n      } = props;\n      if (to !== undefined) return to;\n      if (isMountedRef.value) {\n        // TODO: find proper container\n        return undefined;\n      }\n      return undefined;\n    });\n    return {\n      VBinder,\n      mergedEnabled: mergedEnabledRef,\n      offsetContainerRef,\n      followerRef,\n      mergedTo: mergedToRef,\n      syncPosition\n    };\n  },\n  render() {\n    return h(LazyTeleport, {\n      show: this.show,\n      to: this.mergedTo,\n      disabled: this.teleportDisabled\n    }, {\n      default: () => {\n        var _a, _b;\n        const vNode = h('div', {\n          class: ['v-binder-follower-container', this.containerClass],\n          ref: 'offsetContainerRef'\n        }, [h('div', {\n          class: 'v-binder-follower-content',\n          ref: 'followerRef'\n        }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a))]);\n        if (this.zindexable) {\n          return withDirectives(vNode, [[zindexable, {\n            enabled: this.mergedEnabled,\n            zIndex: this.zIndex\n          }]]);\n        }\n        return vNode;\n      }\n    });\n  }\n});","map":{"version":3,"names":["h","defineComponent","inject","nextTick","watch","toRef","ref","onMounted","onBeforeUnmount","withDirectives","zindexable","useMemo","useIsMounted","onFontsReady","useSsrAdapter","c","cssrAnchorMetaName","LazyTeleport","getPlacementAndOffsetOfFollower","getProperTransformOrigin","getOffset","getPointRect","getRect","style","position","left","right","top","height","pointerEvents","zIndex","name","inheritAttrs","props","show","Boolean","enabled","type","default","undefined","placement","String","syncTrigger","Array","to","Object","flip","internalShift","x","Number","y","width","minWidth","containerClass","teleportDisabled","overlap","setup","VBinder","mergedEnabledRef","followerRef","offsetContainerRef","ensureListeners","includes","addScrollListener","syncPosition","addResizeListener","removeListeners","removeScrollListener","removeResizeListener","value","ssrAdapter","mount","id","head","anchorMetaName","ssr","follower","target","targetRef","targetRect","setProperty","Math","round","setAttribute","removeAttribute","followerRect","offsetContainerRect","offsetLeftToStandardPlacement","offsetTopToStandardPlacement","properPlacement","properTransformOrigin","transform","transformOrigin","syncOnNextTick","then","catch","e","console","error","forEach","prop","isMountedRef","mergedToRef","mergedEnabled","mergedTo","render","disabled","_a","_b","vNode","class","$slots","call"],"sources":["/Users/krystal/Documents/GitHub/meetings_vue3/node_modules/vueuc/es/binder/src/Follower.js"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { h, defineComponent, inject, nextTick, watch, toRef, ref, onMounted, onBeforeUnmount, withDirectives } from 'vue';\nimport { zindexable } from 'vdirs';\nimport { useMemo, useIsMounted, onFontsReady } from 'vooks';\nimport { useSsrAdapter } from '@css-render/vue3-ssr';\nimport { c, cssrAnchorMetaName } from '../../shared';\nimport LazyTeleport from '../../lazy-teleport/src/index';\nimport { getPlacementAndOffsetOfFollower, getProperTransformOrigin, getOffset } from './get-placement-style';\nimport { getPointRect, getRect } from './utils';\nconst style = c([\n    c('.v-binder-follower-container', {\n        position: 'absolute',\n        left: '0',\n        right: '0',\n        top: '0',\n        height: '0',\n        pointerEvents: 'none',\n        zIndex: 'auto'\n    }),\n    c('.v-binder-follower-content', {\n        position: 'absolute',\n        zIndex: 'auto'\n    }, [\n        c('> *', {\n            pointerEvents: 'all'\n        })\n    ])\n]);\nexport default defineComponent({\n    name: 'Follower',\n    inheritAttrs: false,\n    props: {\n        show: Boolean,\n        enabled: {\n            type: Boolean,\n            default: undefined\n        },\n        placement: {\n            type: String,\n            default: 'bottom'\n        },\n        syncTrigger: {\n            type: Array,\n            default: ['resize', 'scroll']\n        },\n        to: [String, Object],\n        flip: {\n            type: Boolean,\n            default: true\n        },\n        internalShift: Boolean,\n        x: Number,\n        y: Number,\n        width: String,\n        minWidth: String,\n        containerClass: String,\n        teleportDisabled: Boolean,\n        zindexable: {\n            type: Boolean,\n            default: true\n        },\n        zIndex: Number,\n        overlap: Boolean\n    },\n    setup(props) {\n        const VBinder = inject('VBinder');\n        const mergedEnabledRef = useMemo(() => {\n            return props.enabled !== undefined ? props.enabled : props.show;\n        });\n        const followerRef = ref(null);\n        const offsetContainerRef = ref(null);\n        const ensureListeners = () => {\n            const { syncTrigger } = props;\n            if (syncTrigger.includes('scroll')) {\n                VBinder.addScrollListener(syncPosition);\n            }\n            if (syncTrigger.includes('resize')) {\n                VBinder.addResizeListener(syncPosition);\n            }\n        };\n        const removeListeners = () => {\n            VBinder.removeScrollListener(syncPosition);\n            VBinder.removeResizeListener(syncPosition);\n        };\n        onMounted(() => {\n            if (mergedEnabledRef.value) {\n                syncPosition();\n                ensureListeners();\n            }\n        });\n        const ssrAdapter = useSsrAdapter();\n        style.mount({\n            id: 'vueuc/binder',\n            head: true,\n            anchorMetaName: cssrAnchorMetaName,\n            ssr: ssrAdapter\n        });\n        onBeforeUnmount(() => {\n            removeListeners();\n        });\n        onFontsReady(() => {\n            if (mergedEnabledRef.value) {\n                syncPosition();\n            }\n        });\n        const syncPosition = () => {\n            if (!mergedEnabledRef.value) {\n                return;\n            }\n            const follower = followerRef.value;\n            // sometimes watched props change before its dom is ready\n            // for example: show=false, x=undefined, y=undefined\n            //              show=true,  x=0,         y=0\n            // will cause error\n            // I may optimize the watch start point later\n            if (follower === null)\n                return;\n            const target = VBinder.targetRef;\n            const { x, y, overlap } = props;\n            const targetRect = x !== undefined && y !== undefined\n                ? getPointRect(x, y)\n                : getRect(target);\n            follower.style.setProperty('--v-target-width', `${Math.round(targetRect.width)}px`);\n            follower.style.setProperty('--v-target-height', `${Math.round(targetRect.height)}px`);\n            const { width, minWidth, placement, internalShift, flip } = props;\n            follower.setAttribute('v-placement', placement);\n            if (overlap) {\n                follower.setAttribute('v-overlap', '');\n            }\n            else {\n                follower.removeAttribute('v-overlap');\n            }\n            const { style } = follower;\n            if (width === 'target') {\n                style.width = `${targetRect.width}px`;\n            }\n            else if (width !== undefined) {\n                style.width = width;\n            }\n            else {\n                style.width = '';\n            }\n            if (minWidth === 'target') {\n                style.minWidth = `${targetRect.width}px`;\n            }\n            else if (minWidth !== undefined) {\n                style.minWidth = minWidth;\n            }\n            else {\n                style.minWidth = '';\n            }\n            const followerRect = getRect(follower);\n            const offsetContainerRect = getRect(offsetContainerRef.value);\n            const { left: offsetLeftToStandardPlacement, top: offsetTopToStandardPlacement, placement: properPlacement } = getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, internalShift, flip, overlap);\n            const properTransformOrigin = getProperTransformOrigin(properPlacement, overlap);\n            const { left, top, transform } = getOffset(properPlacement, offsetContainerRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap);\n            // we assume that the content size doesn't change after flip,\n            // nor we need to make sync logic more complex\n            follower.setAttribute('v-placement', properPlacement);\n            follower.style.setProperty('--v-offset-left', `${Math.round(offsetLeftToStandardPlacement)}px`);\n            follower.style.setProperty('--v-offset-top', `${Math.round(offsetTopToStandardPlacement)}px`);\n            follower.style.transform = `translateX(${left}) translateY(${top}) ${transform}`;\n            follower.style.setProperty('--v-transform-origin', properTransformOrigin);\n            follower.style.transformOrigin = properTransformOrigin;\n        };\n        watch(mergedEnabledRef, (value) => {\n            if (value) {\n                ensureListeners();\n                syncOnNextTick();\n            }\n            else {\n                removeListeners();\n            }\n        });\n        const syncOnNextTick = () => {\n            nextTick()\n                .then(syncPosition)\n                .catch((e) => console.error(e));\n        };\n        [\n            'placement',\n            'x',\n            'y',\n            'internalShift',\n            'flip',\n            'width',\n            'overlap',\n            'minWidth'\n        ].forEach((prop) => {\n            watch(toRef(props, prop), syncPosition);\n        });\n        ['teleportDisabled'].forEach((prop) => {\n            watch(toRef(props, prop), syncOnNextTick);\n        });\n        watch(toRef(props, 'syncTrigger'), (value) => {\n            if (!value.includes('resize')) {\n                VBinder.removeResizeListener(syncPosition);\n            }\n            else {\n                VBinder.addResizeListener(syncPosition);\n            }\n            if (!value.includes('scroll')) {\n                VBinder.removeScrollListener(syncPosition);\n            }\n            else {\n                VBinder.addScrollListener(syncPosition);\n            }\n        });\n        const isMountedRef = useIsMounted();\n        const mergedToRef = useMemo(() => {\n            const { to } = props;\n            if (to !== undefined)\n                return to;\n            if (isMountedRef.value) {\n                // TODO: find proper container\n                return undefined;\n            }\n            return undefined;\n        });\n        return {\n            VBinder,\n            mergedEnabled: mergedEnabledRef,\n            offsetContainerRef,\n            followerRef,\n            mergedTo: mergedToRef,\n            syncPosition\n        };\n    },\n    render() {\n        return h(LazyTeleport, {\n            show: this.show,\n            to: this.mergedTo,\n            disabled: this.teleportDisabled\n        }, {\n            default: () => {\n                var _a, _b;\n                const vNode = h('div', {\n                    class: ['v-binder-follower-container', this.containerClass],\n                    ref: 'offsetContainerRef'\n                }, [\n                    h('div', {\n                        class: 'v-binder-follower-content',\n                        ref: 'followerRef'\n                    }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a))\n                ]);\n                if (this.zindexable) {\n                    return withDirectives(vNode, [\n                        [\n                            zindexable,\n                            {\n                                enabled: this.mergedEnabled,\n                                zIndex: this.zIndex\n                            }\n                        ]\n                    ]);\n                }\n                return vNode;\n            }\n        });\n    }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}