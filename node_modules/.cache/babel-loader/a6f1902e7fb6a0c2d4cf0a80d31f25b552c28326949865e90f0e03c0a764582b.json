{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Fragment, createTextVNode, Comment } from 'vue';\nexport function getSlot(scope, slots, slotName = 'default') {\n  const slot = slots[slotName];\n  if (slot === undefined) {\n    throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);\n  }\n  return slot();\n}\n// o(n) flatten\nexport function flatten(vNodes, filterCommentNode = true, result = []) {\n  vNodes.forEach(vNode => {\n    if (vNode === null) return;\n    if (typeof vNode !== 'object') {\n      if (typeof vNode === 'string' || typeof vNode === 'number') {\n        result.push(createTextVNode(String(vNode)));\n      }\n      return;\n    }\n    if (Array.isArray(vNode)) {\n      flatten(vNode, filterCommentNode, result);\n      return;\n    }\n    if (vNode.type === Fragment) {\n      if (vNode.children === null) return;\n      if (Array.isArray(vNode.children)) {\n        flatten(vNode.children, filterCommentNode, result);\n      }\n      // rawSlot\n    } else if (vNode.type !== Comment) {\n      result.push(vNode);\n    }\n  });\n  return result;\n}\nexport function getFirstVNode(scope, slots, slotName = 'default') {\n  const slot = slots[slotName];\n  if (slot === undefined) {\n    throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);\n  }\n  const content = flatten(slot());\n  // vue will normalize the slot, so slot must be an array\n  if (content.length === 1) {\n    return content[0];\n  } else {\n    throw new Error(`[vueuc/${scope}]: slot[${slotName}] should have exactly one child.`);\n  }\n}","map":{"version":3,"names":["Fragment","createTextVNode","Comment","getSlot","scope","slots","slotName","slot","undefined","Error","flatten","vNodes","filterCommentNode","result","forEach","vNode","push","String","Array","isArray","type","children","getFirstVNode","content","length"],"sources":["/Users/elmo/Documents/GitHub/meetings_vue3/node_modules/vueuc/es/shared/v-node.js"],"sourcesContent":["import { Fragment, createTextVNode, Comment } from 'vue';\nexport function getSlot(scope, slots, slotName = 'default') {\n    const slot = slots[slotName];\n    if (slot === undefined) {\n        throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);\n    }\n    return slot();\n}\n// o(n) flatten\nexport function flatten(vNodes, filterCommentNode = true, result = []) {\n    vNodes.forEach((vNode) => {\n        if (vNode === null)\n            return;\n        if (typeof vNode !== 'object') {\n            if (typeof vNode === 'string' || typeof vNode === 'number') {\n                result.push(createTextVNode(String(vNode)));\n            }\n            return;\n        }\n        if (Array.isArray(vNode)) {\n            flatten(vNode, filterCommentNode, result);\n            return;\n        }\n        if (vNode.type === Fragment) {\n            if (vNode.children === null)\n                return;\n            if (Array.isArray(vNode.children)) {\n                flatten(vNode.children, filterCommentNode, result);\n            }\n            // rawSlot\n        }\n        else if (vNode.type !== Comment) {\n            result.push(vNode);\n        }\n    });\n    return result;\n}\nexport function getFirstVNode(scope, slots, slotName = 'default') {\n    const slot = slots[slotName];\n    if (slot === undefined) {\n        throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);\n    }\n    const content = flatten(slot());\n    // vue will normalize the slot, so slot must be an array\n    if (content.length === 1) {\n        return content[0];\n    }\n    else {\n        throw new Error(`[vueuc/${scope}]: slot[${slotName}] should have exactly one child.`);\n    }\n}\n"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,eAAe,EAAEC,OAAO,QAAQ,KAAK;AACxD,OAAO,SAASC,OAAO,CAACC,KAAK,EAAEC,KAAK,EAAEC,QAAQ,GAAG,SAAS,EAAE;EACxD,MAAMC,IAAI,GAAGF,KAAK,CAACC,QAAQ,CAAC;EAC5B,IAAIC,IAAI,KAAKC,SAAS,EAAE;IACpB,MAAM,IAAIC,KAAK,CAAE,UAASL,KAAM,WAAUE,QAAS,aAAY,CAAC;EACpE;EACA,OAAOC,IAAI,EAAE;AACjB;AACA;AACA,OAAO,SAASG,OAAO,CAACC,MAAM,EAAEC,iBAAiB,GAAG,IAAI,EAAEC,MAAM,GAAG,EAAE,EAAE;EACnEF,MAAM,CAACG,OAAO,CAAEC,KAAK,IAAK;IACtB,IAAIA,KAAK,KAAK,IAAI,EACd;IACJ,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC3B,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;QACxDF,MAAM,CAACG,IAAI,CAACf,eAAe,CAACgB,MAAM,CAACF,KAAK,CAAC,CAAC,CAAC;MAC/C;MACA;IACJ;IACA,IAAIG,KAAK,CAACC,OAAO,CAACJ,KAAK,CAAC,EAAE;MACtBL,OAAO,CAACK,KAAK,EAAEH,iBAAiB,EAAEC,MAAM,CAAC;MACzC;IACJ;IACA,IAAIE,KAAK,CAACK,IAAI,KAAKpB,QAAQ,EAAE;MACzB,IAAIe,KAAK,CAACM,QAAQ,KAAK,IAAI,EACvB;MACJ,IAAIH,KAAK,CAACC,OAAO,CAACJ,KAAK,CAACM,QAAQ,CAAC,EAAE;QAC/BX,OAAO,CAACK,KAAK,CAACM,QAAQ,EAAET,iBAAiB,EAAEC,MAAM,CAAC;MACtD;MACA;IACJ,CAAC,MACI,IAAIE,KAAK,CAACK,IAAI,KAAKlB,OAAO,EAAE;MAC7BW,MAAM,CAACG,IAAI,CAACD,KAAK,CAAC;IACtB;EACJ,CAAC,CAAC;EACF,OAAOF,MAAM;AACjB;AACA,OAAO,SAASS,aAAa,CAAClB,KAAK,EAAEC,KAAK,EAAEC,QAAQ,GAAG,SAAS,EAAE;EAC9D,MAAMC,IAAI,GAAGF,KAAK,CAACC,QAAQ,CAAC;EAC5B,IAAIC,IAAI,KAAKC,SAAS,EAAE;IACpB,MAAM,IAAIC,KAAK,CAAE,UAASL,KAAM,WAAUE,QAAS,aAAY,CAAC;EACpE;EACA,MAAMiB,OAAO,GAAGb,OAAO,CAACH,IAAI,EAAE,CAAC;EAC/B;EACA,IAAIgB,OAAO,CAACC,MAAM,KAAK,CAAC,EAAE;IACtB,OAAOD,OAAO,CAAC,CAAC,CAAC;EACrB,CAAC,MACI;IACD,MAAM,IAAId,KAAK,CAAE,UAASL,KAAM,WAAUE,QAAS,kCAAiC,CAAC;EACzF;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}