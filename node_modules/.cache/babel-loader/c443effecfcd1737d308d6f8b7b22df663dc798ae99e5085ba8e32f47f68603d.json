{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { h, defineComponent, ref, cloneVNode, computed, onBeforeUnmount, watch, withDirectives, vShow, Transition, toRef, nextTick, onMounted, watchEffect, normalizeStyle, onUpdated } from 'vue';\nimport { VResizeObserver } from 'vueuc';\nimport { useMergedState } from 'vooks';\nimport { on, off } from 'evtd';\nimport { getPreciseEventTarget } from 'seemly';\nimport { useConfig, useTheme, useThemeClass } from '../../_mixins';\nimport { flatten, keep, resolveSlotWithProps } from '../../_utils';\nimport { carouselLight } from '../styles';\nimport { calculateSize, clampValue, resolveSpeed, isTouchEvent, getNextIndex, getPrevIndex, getDisplayIndex, getRealIndex, getDisplayTotalView, addDuplicateSlides } from './utils';\nimport { provideCarouselContext } from './CarouselContext';\nimport NCarouselDots from './CarouselDots';\nimport NCarouselArrow from './CarouselArrow';\nimport NCarouselItem, { isCarouselItem } from './CarouselItem';\nimport style from './styles/index.cssr';\nconst transitionProperties = ['transitionDuration', 'transitionTimingFunction'];\nexport const carouselProps = Object.assign(Object.assign({}, useTheme.props), {\n  defaultIndex: {\n    type: Number,\n    default: 0\n  },\n  currentIndex: Number,\n  showArrow: Boolean,\n  dotType: {\n    type: String,\n    default: 'dot'\n  },\n  dotPlacement: {\n    type: String,\n    default: 'bottom'\n  },\n  slidesPerView: {\n    type: [Number, String],\n    default: 1\n  },\n  spaceBetween: {\n    type: Number,\n    default: 0\n  },\n  centeredSlides: Boolean,\n  direction: {\n    type: String,\n    default: 'horizontal'\n  },\n  autoplay: Boolean,\n  interval: {\n    type: Number,\n    default: 5000\n  },\n  loop: {\n    type: Boolean,\n    default: true\n  },\n  effect: {\n    type: String,\n    default: 'slide'\n  },\n  showDots: {\n    type: Boolean,\n    default: true\n  },\n  trigger: {\n    type: String,\n    default: 'click'\n  },\n  transitionStyle: {\n    type: Object,\n    default: () => ({\n      transitionDuration: '300ms'\n    })\n  },\n  transitionProps: Object,\n  draggable: Boolean,\n  prevSlideStyle: [Object, String],\n  nextSlideStyle: [Object, String],\n  touchable: {\n    type: Boolean,\n    default: true\n  },\n  mousewheel: Boolean,\n  keyboard: Boolean,\n  'onUpdate:currentIndex': Function,\n  onUpdateCurrentIndex: Function\n});\n// only one carousel is allowed to trigger touch globally\nlet globalDragging = false;\nexport default defineComponent({\n  name: 'Carousel',\n  props: carouselProps,\n  setup(props) {\n    const {\n      mergedClsPrefixRef,\n      inlineThemeDisabled\n    } = useConfig(props);\n    // Dom\n    const selfElRef = ref(null);\n    const slidesElRef = ref(null);\n    const slideElsRef = ref([]);\n    const slideVNodesRef = {\n      value: []\n    };\n    // Computed states\n    const verticalRef = computed(() => props.direction === 'vertical');\n    const sizeAxisRef = computed(() => verticalRef.value ? 'height' : 'width');\n    const spaceAxisRef = computed(() => verticalRef.value ? 'bottom' : 'right');\n    const sequenceLayoutRef = computed(() => props.effect === 'slide');\n    const duplicatedableRef = computed(\n    // duplicate the copy operation in `slide` mode,\n    // because only its DOM is sequence layout\n    () => props.loop && props.slidesPerView === 1 && sequenceLayoutRef.value);\n    // user wants to control the transition animation\n    const userWantsControlRef = computed(() => props.effect === 'custom');\n    // used to calculate total views\n    const displaySlidesPerViewRef = computed(() => !sequenceLayoutRef.value || props.centeredSlides ? 1 : props.slidesPerView);\n    // used to calculate the size of each slide\n    const realSlidesPerViewRef = computed(() => userWantsControlRef.value ? 1 : props.slidesPerView);\n    // we automatically calculate total view for special slides per view\n    const autoSlideSizeRef = computed(() => displaySlidesPerViewRef.value === 'auto' || props.slidesPerView === 'auto' && props.centeredSlides);\n    // Carousel size\n    const perViewSizeRef = ref({\n      width: 0,\n      height: 0\n    });\n    const slideSizesRef = computed(() => {\n      const {\n        value: slidesEls\n      } = slideElsRef;\n      if (!slidesEls.length) return [];\n      const {\n        value: autoSlideSize\n      } = autoSlideSizeRef;\n      if (autoSlideSize) {\n        return slidesEls.map(slide => calculateSize(slide));\n      }\n      const {\n        value: slidesPerView\n      } = realSlidesPerViewRef;\n      const {\n        value: perViewSize\n      } = perViewSizeRef;\n      const {\n        value: axis\n      } = sizeAxisRef;\n      let axisSize = perViewSize[axis];\n      if (slidesPerView !== 'auto') {\n        const {\n          spaceBetween\n        } = props;\n        const remaining = axisSize - (slidesPerView - 1) * spaceBetween;\n        const percentage = 1 / Math.max(1, slidesPerView);\n        axisSize = remaining * percentage;\n      }\n      const slideSize = Object.assign(Object.assign({}, perViewSize), {\n        [axis]: axisSize\n      });\n      return slidesEls.map(() => slideSize);\n    });\n    // The translate required to reach each slide\n    const slideTranlatesRef = computed(() => {\n      const {\n        value: slideSizes\n      } = slideSizesRef;\n      if (!slideSizes.length) return [];\n      const {\n        centeredSlides,\n        spaceBetween\n      } = props;\n      const {\n        value: axis\n      } = sizeAxisRef;\n      const {\n        [axis]: perViewSize\n      } = perViewSizeRef.value;\n      let previousTranslate = 0;\n      return slideSizes.map(({\n        [axis]: slideSize\n      }) => {\n        let translate = previousTranslate;\n        if (centeredSlides) {\n          translate += (slideSize - perViewSize) / 2;\n        }\n        previousTranslate += slideSize + spaceBetween;\n        return translate;\n      });\n    });\n    // Styles\n    const isMountedRef = ref(false);\n    const transitionStyleRef = computed(() => {\n      const {\n        transitionStyle\n      } = props;\n      return transitionStyle ? keep(transitionStyle, transitionProperties) : {};\n    });\n    const speedRef = computed(() => userWantsControlRef.value ? 0 : resolveSpeed(transitionStyleRef.value.transitionDuration));\n    const slideStylesRef = computed(() => {\n      const {\n        value: slidesEls\n      } = slideElsRef;\n      if (!slidesEls.length) return [];\n      const useComputedSize = !(autoSlideSizeRef.value || realSlidesPerViewRef.value === 1);\n      const getSlideSize = index => {\n        if (useComputedSize) {\n          const {\n            value: axis\n          } = sizeAxisRef;\n          return {\n            [axis]: `${slideSizesRef.value[index][axis]}px`\n          };\n        }\n      };\n      if (userWantsControlRef.value) {\n        // We center each slide when user wants to control the transition animation,\n        // so there is no need to calculate the offset\n        return slidesEls.map((_, i) => getSlideSize(i));\n      }\n      const {\n        effect,\n        spaceBetween\n      } = props;\n      const {\n        value: spaceAxis\n      } = spaceAxisRef;\n      return slidesEls.reduce((styles, _, i) => {\n        const style = Object.assign(Object.assign({}, getSlideSize(i)), {\n          [`margin-${spaceAxis}`]: `${spaceBetween}px`\n        });\n        styles.push(style);\n        if (isMountedRef.value && (effect === 'fade' || effect === 'card')) {\n          Object.assign(style, transitionStyleRef.value);\n        }\n        return styles;\n      }, []);\n    });\n    // Total\n    const totalViewRef = computed(() => {\n      const {\n        value: slidesPerView\n      } = displaySlidesPerViewRef;\n      const {\n        length: totalSlides\n      } = slideElsRef.value;\n      if (slidesPerView !== 'auto') {\n        return Math.max(totalSlides - slidesPerView, 0) + 1;\n      } else {\n        const {\n          value: slideSizes\n        } = slideSizesRef;\n        const {\n          length\n        } = slideSizes;\n        if (!length) return totalSlides;\n        const {\n          value: translates\n        } = slideTranlatesRef;\n        const {\n          value: axis\n        } = sizeAxisRef;\n        const perViewSize = perViewSizeRef.value[axis];\n        let lastViewSize = slideSizes[slideSizes.length - 1][axis];\n        let i = length;\n        while (i > 1 && lastViewSize < perViewSize) {\n          i--;\n          lastViewSize += translates[i] - translates[i - 1];\n        }\n        return clampValue(i + 1, 1, length);\n      }\n    });\n    const displayTotalViewRef = computed(() => getDisplayTotalView(totalViewRef.value, duplicatedableRef.value));\n    // Index\n    const defaultRealIndex = getRealIndex(props.defaultIndex, duplicatedableRef.value);\n    const uncontrolledDisplayIndexRef = ref(getDisplayIndex(defaultRealIndex, totalViewRef.value, duplicatedableRef.value));\n    const mergedDisplayIndexRef = useMergedState(toRef(props, 'currentIndex'), uncontrolledDisplayIndexRef);\n    const realIndexRef = computed(() => getRealIndex(mergedDisplayIndexRef.value, duplicatedableRef.value));\n    // Reality methods\n    function toRealIndex(index) {\n      var _a, _b;\n      index = clampValue(index, 0, totalViewRef.value - 1);\n      const displayIndex = getDisplayIndex(index, totalViewRef.value, duplicatedableRef.value);\n      const {\n        value: lastDisplayIndex\n      } = mergedDisplayIndexRef;\n      if (displayIndex !== mergedDisplayIndexRef.value) {\n        uncontrolledDisplayIndexRef.value = displayIndex;\n        (_a = props['onUpdate:currentIndex']) === null || _a === void 0 ? void 0 : _a.call(props, displayIndex, lastDisplayIndex);\n        (_b = props.onUpdateCurrentIndex) === null || _b === void 0 ? void 0 : _b.call(props, displayIndex, lastDisplayIndex);\n      }\n    }\n    function getRealPrevIndex(index = realIndexRef.value) {\n      return getPrevIndex(index, totalViewRef.value, props.loop);\n    }\n    function getRealNextIndex(index = realIndexRef.value) {\n      return getNextIndex(index, totalViewRef.value, props.loop);\n    }\n    function isRealPrev(slideOrIndex) {\n      const index = getSlideIndex(slideOrIndex);\n      return index !== null && getRealPrevIndex() === index;\n    }\n    function isRealNext(slideOrIndex) {\n      const index = getSlideIndex(slideOrIndex);\n      return index !== null && getRealNextIndex() === index;\n    }\n    function isRealActive(slideOrIndex) {\n      return realIndexRef.value === getSlideIndex(slideOrIndex);\n    }\n    // Display methods\n    // They are used to deal with the actual values displayed on the UI\n    function isDisplayActive(index) {\n      return mergedDisplayIndexRef.value === index;\n    }\n    function isPrevDisabled() {\n      return getRealPrevIndex() === null;\n    }\n    function isNextDisabled() {\n      return getRealNextIndex() === null;\n    }\n    // To\n    function to(index) {\n      const realIndex = clampValue(getRealIndex(index, duplicatedableRef.value), 0, totalViewRef.value);\n      if (index !== mergedDisplayIndexRef.value || realIndex !== realIndexRef.value) {\n        toRealIndex(realIndex);\n      }\n    }\n    function prev() {\n      const prevIndex = getRealPrevIndex();\n      if (prevIndex !== null) toRealIndex(prevIndex);\n    }\n    function next() {\n      const nextIndex = getRealNextIndex();\n      if (nextIndex !== null) toRealIndex(nextIndex);\n    }\n    function prevIfSlideTransitionEnd() {\n      if (!inTransition || !duplicatedableRef.value) prev();\n    }\n    function nextIfSlideTransitionEnd() {\n      if (!inTransition || !duplicatedableRef.value) next();\n    }\n    // Translate to\n    let inTransition = false;\n    // record the translate of each slide, so that it can be restored at touch\n    let previousTranslate = 0;\n    const translateStyleRef = ref({});\n    function updateTranslate(translate, speed = 0) {\n      translateStyleRef.value = Object.assign({}, transitionStyleRef.value, {\n        transform: verticalRef.value ? `translateY(${-translate}px)` : `translateX(${-translate}px)`,\n        transitionDuration: `${speed}ms`\n      });\n    }\n    function fixTranslate(speed = 0) {\n      if (sequenceLayoutRef.value) {\n        translateTo(realIndexRef.value, speed);\n      } else if (previousTranslate !== 0) {\n        if (!inTransition && speed > 0) {\n          inTransition = true;\n        }\n        updateTranslate(previousTranslate = 0, speed);\n      }\n    }\n    function translateTo(index, speed) {\n      const translate = getTranslate(index);\n      if (translate !== previousTranslate && speed > 0) {\n        inTransition = true;\n      }\n      previousTranslate = getTranslate(realIndexRef.value);\n      updateTranslate(translate, speed);\n    }\n    function getTranslate(index) {\n      let translate;\n      // Deal with auto slides pre view\n      if (index >= totalViewRef.value - 1) {\n        translate = getLastViewTranslate();\n      } else {\n        translate = slideTranlatesRef.value[index] || 0;\n      }\n      return translate;\n    }\n    function getLastViewTranslate() {\n      if (displaySlidesPerViewRef.value === 'auto') {\n        const {\n          value: axis\n        } = sizeAxisRef;\n        const {\n          [axis]: perViewSize\n        } = perViewSizeRef.value;\n        const {\n          value: translates\n        } = slideTranlatesRef;\n        const lastTranslate = translates[translates.length - 1];\n        let overallSize;\n        if (lastTranslate === undefined) {\n          overallSize = perViewSize;\n        } else {\n          const {\n            value: slideSizes\n          } = slideSizesRef;\n          overallSize = lastTranslate + slideSizes[slideSizes.length - 1][axis];\n        }\n        // Bring the last slide to the edge\n        return overallSize - perViewSize;\n      } else {\n        const {\n          value: translates\n        } = slideTranlatesRef;\n        return translates[totalViewRef.value - 1] || 0;\n      }\n    }\n    // Provide\n    const carouselContext = {\n      currentIndexRef: mergedDisplayIndexRef,\n      to,\n      prev: prevIfSlideTransitionEnd,\n      next: nextIfSlideTransitionEnd,\n      isVertical: () => verticalRef.value,\n      isHorizontal: () => !verticalRef.value,\n      isPrev: isRealPrev,\n      isNext: isRealNext,\n      isActive: isRealActive,\n      isPrevDisabled,\n      isNextDisabled,\n      getSlideIndex,\n      getSlideStyle,\n      addSlide,\n      removeSlide,\n      onCarouselItemClick\n    };\n    provideCarouselContext(carouselContext);\n    function addSlide(slide) {\n      if (!slide) return;\n      slideElsRef.value.push(slide);\n    }\n    function removeSlide(slide) {\n      if (!slide) return;\n      const index = getSlideIndex(slide);\n      if (index !== -1) {\n        slideElsRef.value.splice(index, 1);\n      }\n    }\n    function getSlideIndex(slideOrIndex) {\n      return typeof slideOrIndex === 'number' ? slideOrIndex : slideOrIndex ? slideElsRef.value.indexOf(slideOrIndex) : -1;\n    }\n    function getSlideStyle(slide) {\n      const index = getSlideIndex(slide);\n      if (index !== -1) {\n        const styles = [slideStylesRef.value[index]];\n        const isPrev = carouselContext.isPrev(index);\n        const isNext = carouselContext.isNext(index);\n        if (isPrev) {\n          styles.push(props.prevSlideStyle || '');\n        }\n        if (isNext) {\n          styles.push(props.nextSlideStyle || '');\n        }\n        return normalizeStyle(styles);\n      }\n    }\n    function onCarouselItemClick(index, event) {\n      let allowClick = !inTransition && !dragging && !isEffectiveDrag;\n      if (props.effect === 'card' && allowClick && !isRealActive(index)) {\n        to(index);\n        allowClick = false;\n      }\n      if (!allowClick) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n    // Autoplay\n    let autoplayTimer = null;\n    function stopAutoplay() {\n      if (autoplayTimer) {\n        clearInterval(autoplayTimer);\n        autoplayTimer = null;\n      }\n    }\n    function resetAutoplay() {\n      stopAutoplay();\n      const disabled = !props.autoplay || displayTotalViewRef.value < 2;\n      if (!disabled) {\n        autoplayTimer = window.setInterval(next, props.interval);\n      }\n    }\n    // Drag\n    let dragStartX = 0;\n    let dragStartY = 0;\n    let dragOffset = 0;\n    let dragStartTime = 0;\n    let dragging = false;\n    let isEffectiveDrag = false;\n    function handleTouchstart(event) {\n      var _a;\n      if (globalDragging) return;\n      if (!((_a = slidesElRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(event)))) {\n        return;\n      }\n      globalDragging = true;\n      dragging = true;\n      isEffectiveDrag = false;\n      dragStartTime = Date.now();\n      stopAutoplay();\n      if (event.type !== 'touchstart' && !event.target.isContentEditable) {\n        event.preventDefault();\n      }\n      const touchEvent = isTouchEvent(event) ? event.touches[0] : event;\n      if (verticalRef.value) {\n        dragStartY = touchEvent.clientY;\n      } else {\n        dragStartX = touchEvent.clientX;\n      }\n      if (props.touchable) {\n        on('touchmove', document, handleTouchmove, {\n          passive: true\n        });\n        on('touchend', document, handleTouchend);\n        on('touchcancel', document, handleTouchend);\n      }\n      if (props.draggable) {\n        on('mousemove', document, handleTouchmove);\n        on('mouseup', document, handleTouchend);\n      }\n    }\n    function handleTouchmove(event) {\n      const {\n        value: vertical\n      } = verticalRef;\n      const {\n        value: axis\n      } = sizeAxisRef;\n      const touchEvent = isTouchEvent(event) ? event.touches[0] : event;\n      const offset = vertical ? touchEvent.clientY - dragStartY : touchEvent.clientX - dragStartX;\n      const perViewSize = perViewSizeRef.value[axis];\n      dragOffset = clampValue(offset, -perViewSize, perViewSize);\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      if (sequenceLayoutRef.value) {\n        updateTranslate(previousTranslate - dragOffset, 0);\n      }\n    }\n    function handleTouchend() {\n      const {\n        value: realIndex\n      } = realIndexRef;\n      let currentIndex = realIndex;\n      if (!inTransition && dragOffset !== 0 && sequenceLayoutRef.value) {\n        const currentTranslate = previousTranslate - dragOffset;\n        const translates = [...slideTranlatesRef.value.slice(0, totalViewRef.value - 1), getLastViewTranslate()];\n        let prevOffset = null;\n        for (let i = 0; i < translates.length; i++) {\n          const offset = Math.abs(translates[i] - currentTranslate);\n          if (prevOffset !== null && prevOffset < offset) {\n            break;\n          }\n          prevOffset = offset;\n          currentIndex = i;\n        }\n      }\n      if (currentIndex === realIndex) {\n        const timeElapsed = Date.now() - dragStartTime;\n        const {\n          value: axis\n        } = sizeAxisRef;\n        const perViewSize = perViewSizeRef.value[axis];\n        // more than 50% width or faster than 0.4px per ms\n        if (dragOffset > perViewSize / 2 || dragOffset / timeElapsed > 0.4) {\n          currentIndex = getRealPrevIndex(realIndex);\n        } else if (dragOffset < -perViewSize / 2 || dragOffset / timeElapsed < -0.4) {\n          currentIndex = getRealNextIndex(realIndex);\n        }\n      }\n      if (currentIndex !== null && currentIndex !== realIndex) {\n        isEffectiveDrag = true;\n        toRealIndex(currentIndex);\n        void nextTick(() => {\n          if (!duplicatedableRef.value || uncontrolledDisplayIndexRef.value !== mergedDisplayIndexRef.value) {\n            fixTranslate(speedRef.value);\n          }\n        });\n      } else {\n        fixTranslate(speedRef.value);\n      }\n      resetDragStatus();\n      resetAutoplay();\n    }\n    function resetDragStatus() {\n      if (dragging) {\n        globalDragging = false;\n      }\n      dragging = false;\n      dragStartX = 0;\n      dragStartY = 0;\n      dragOffset = 0;\n      dragStartTime = 0;\n      off('touchmove', document, handleTouchmove);\n      off('touchend', document, handleTouchend);\n      off('touchcancel', document, handleTouchend);\n      off('mousemove', document, handleTouchmove);\n      off('mouseup', document, handleTouchend);\n    }\n    function handleTransitionEnd() {\n      if (sequenceLayoutRef.value && inTransition) {\n        const {\n          value: realIndex\n        } = realIndexRef;\n        translateTo(realIndex, 0);\n      } else {\n        resetAutoplay();\n      }\n      if (sequenceLayoutRef.value) {\n        translateStyleRef.value.transitionDuration = '0ms';\n      }\n      inTransition = false;\n    }\n    function handleMousewheel(event) {\n      event.preventDefault();\n      if (inTransition) return;\n      let {\n        deltaX,\n        deltaY\n      } = event;\n      if (event.shiftKey && !deltaX) {\n        deltaX = deltaY;\n      }\n      const prevMultiplier = -1;\n      const nextMultiplier = 1;\n      const m = (deltaX || deltaY) > 0 ? nextMultiplier : prevMultiplier;\n      let rx = 0;\n      let ry = 0;\n      if (verticalRef.value) {\n        ry = m;\n      } else {\n        rx = m;\n      }\n      const responseStep = 10;\n      if (ry * deltaY >= responseStep || rx * deltaX >= responseStep) {\n        if (m === nextMultiplier && !isNextDisabled()) {\n          next();\n        } else if (m === prevMultiplier && !isPrevDisabled()) {\n          prev();\n        }\n      }\n    }\n    function handleResize() {\n      perViewSizeRef.value = calculateSize(selfElRef.value, true);\n      resetAutoplay();\n    }\n    function handleSlideResize() {\n      var _a, _b;\n      if (autoSlideSizeRef.value) {\n        (_b = (_a = slideSizesRef.effect).scheduler) === null || _b === void 0 ? void 0 : _b.call(_a);\n        slideSizesRef.effect.run();\n      }\n    }\n    function handleMouseenter() {\n      if (props.autoplay) {\n        stopAutoplay();\n      }\n    }\n    function handleMouseleave() {\n      if (props.autoplay) {\n        resetAutoplay();\n      }\n    }\n    onMounted(() => {\n      watchEffect(resetAutoplay);\n      requestAnimationFrame(() => isMountedRef.value = true);\n    });\n    onBeforeUnmount(() => {\n      resetDragStatus();\n      stopAutoplay();\n    });\n    // Fix index when remounting\n    onUpdated(() => {\n      const {\n        value: slidesEls\n      } = slideElsRef;\n      const {\n        value: slideVNodes\n      } = slideVNodesRef;\n      const indexMap = new Map();\n      const getDisplayIndex = el =>\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      indexMap.has(el) ? indexMap.get(el) : -1;\n      let isChanged = false;\n      for (let i = 0; i < slidesEls.length; i++) {\n        const index = slideVNodes.findIndex(v => v.el === slidesEls[i]);\n        if (index !== i) {\n          isChanged = true;\n        }\n        indexMap.set(slidesEls[i], index);\n      }\n      if (isChanged) {\n        slidesEls.sort((a, b) => getDisplayIndex(a) - getDisplayIndex(b));\n      }\n    });\n    watch(realIndexRef, (realIndex, lastRealIndex) => {\n      if (realIndex === lastRealIndex) return;\n      resetAutoplay();\n      if (sequenceLayoutRef.value) {\n        if (duplicatedableRef.value && displayTotalViewRef.value > 2) {\n          const {\n            value: length\n          } = totalViewRef;\n          if (realIndex === length - 2 && lastRealIndex === 1) {\n            realIndex = 0;\n          } else if (realIndex === 1 && lastRealIndex === length - 2) {\n            realIndex = length - 1;\n          }\n        }\n        translateTo(realIndex, speedRef.value);\n      } else {\n        fixTranslate();\n      }\n    }, {\n      immediate: true\n    });\n    watch([duplicatedableRef, displaySlidesPerViewRef], () => void nextTick(() => toRealIndex(realIndexRef.value)));\n    watch(slideTranlatesRef, () => sequenceLayoutRef.value && fixTranslate(), {\n      deep: true\n    });\n    watch(sequenceLayoutRef, value => {\n      if (!value) {\n        inTransition = false;\n        // if the current mode does not support translate, reset the position of the wrapper\n        updateTranslate(previousTranslate = 0);\n      } else {\n        fixTranslate();\n      }\n    });\n    const slidesControlListenersRef = computed(() => {\n      return {\n        onTouchstartPassive: props.touchable ? handleTouchstart : undefined,\n        onMousedown: props.draggable ? handleTouchstart : undefined,\n        onWheel: props.mousewheel ? handleMousewheel : undefined\n      };\n    });\n    const arrowSlotPropsRef = computed(() => Object.assign(Object.assign({}, keep(carouselContext, ['to', 'prev', 'next', 'isPrevDisabled', 'isNextDisabled'])), {\n      total: displayTotalViewRef.value,\n      currentIndex: mergedDisplayIndexRef.value\n    }));\n    const dotSlotPropsRef = computed(() => ({\n      total: displayTotalViewRef.value,\n      currentIndex: mergedDisplayIndexRef.value,\n      to: carouselContext.to\n    }));\n    const caroulseExposedMethod = {\n      getCurrentIndex: () => mergedDisplayIndexRef.value,\n      to,\n      prev,\n      next\n    };\n    const themeRef = useTheme('Carousel', '-carousel', style, carouselLight, props, mergedClsPrefixRef);\n    const cssVarsRef = computed(() => {\n      const {\n        common: {\n          cubicBezierEaseInOut\n        },\n        self: {\n          dotSize,\n          dotColor,\n          dotColorActive,\n          dotColorFocus,\n          dotLineWidth,\n          dotLineWidthActive,\n          arrowColor\n        }\n      } = themeRef.value;\n      return {\n        '--n-bezier': cubicBezierEaseInOut,\n        '--n-dot-color': dotColor,\n        '--n-dot-color-focus': dotColorFocus,\n        '--n-dot-color-active': dotColorActive,\n        '--n-dot-size': dotSize,\n        '--n-dot-line-width': dotLineWidth,\n        '--n-dot-line-width-active': dotLineWidthActive,\n        '--n-arrow-color': arrowColor\n      };\n    });\n    const themeClassHandle = inlineThemeDisabled ? useThemeClass('carousel', undefined, cssVarsRef, props) : undefined;\n    return Object.assign(Object.assign({\n      mergedClsPrefix: mergedClsPrefixRef,\n      selfElRef,\n      slidesElRef,\n      slideVNodes: slideVNodesRef,\n      duplicatedable: duplicatedableRef,\n      userWantsControl: userWantsControlRef,\n      autoSlideSize: autoSlideSizeRef,\n      displayIndex: mergedDisplayIndexRef,\n      realIndex: realIndexRef,\n      slideStyles: slideStylesRef,\n      translateStyle: translateStyleRef,\n      slidesControlListeners: slidesControlListenersRef,\n      handleTransitionEnd,\n      handleResize,\n      handleSlideResize,\n      handleMouseenter,\n      handleMouseleave,\n      isActive: isDisplayActive,\n      arrowSlotProps: arrowSlotPropsRef,\n      dotSlotProps: dotSlotPropsRef\n    }, caroulseExposedMethod), {\n      cssVars: inlineThemeDisabled ? undefined : cssVarsRef,\n      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,\n      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender\n    });\n  },\n  render() {\n    var _a;\n    const {\n      mergedClsPrefix,\n      showArrow,\n      userWantsControl,\n      slideStyles,\n      dotType,\n      dotPlacement,\n      slidesControlListeners,\n      transitionProps = {},\n      arrowSlotProps,\n      dotSlotProps,\n      $slots: {\n        default: defaultSlot,\n        dots: dotsSlot,\n        arrow: arrowSlot\n      }\n    } = this;\n    const children = defaultSlot && flatten(defaultSlot()) || [];\n    let slides = filterCarouselItem(children);\n    if (!slides.length) {\n      slides = children.map(ch => h(NCarouselItem, null, {\n        default: () => cloneVNode(ch)\n      }));\n    }\n    if (this.duplicatedable) {\n      slides = addDuplicateSlides(slides);\n    }\n    this.slideVNodes.value = slides;\n    // When users need to customize the size of the slide,\n    // we listen to them to fix the current translate\n    if (this.autoSlideSize) {\n      slides = slides.map(slide => h(VResizeObserver, {\n        onResize: this.handleSlideResize\n      }, {\n        default: () => slide\n      }));\n    }\n    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n    return h(\"div\", Object.assign({\n      ref: \"selfElRef\",\n      class: [this.themeClass, `${mergedClsPrefix}-carousel`, this.direction === 'vertical' && `${mergedClsPrefix}-carousel--vertical`, this.showArrow && `${mergedClsPrefix}-carousel--show-arrow`, `${mergedClsPrefix}-carousel--${dotPlacement}`, `${mergedClsPrefix}-carousel--${this.direction}`, `${mergedClsPrefix}-carousel--${this.effect}`, userWantsControl && `${mergedClsPrefix}-carousel--usercontrol`],\n      style: this.cssVars\n    }, slidesControlListeners, {\n      onMouseenter: this.handleMouseenter,\n      onMouseleave: this.handleMouseleave\n    }), h(VResizeObserver, {\n      onResize: this.handleResize\n    }, {\n      default: () => h(\"div\", {\n        ref: \"slidesElRef\",\n        class: `${mergedClsPrefix}-carousel__slides`,\n        role: \"listbox\",\n        style: this.translateStyle,\n        onTransitionend: this.handleTransitionEnd\n      }, userWantsControl ? slides.map((slide, i) => h(\"div\", {\n        style: slideStyles[i],\n        key: i\n      }, withDirectives(h(Transition, Object.assign({}, transitionProps), {\n        default: () => slide\n      }), [[vShow, this.isActive(i)]]))) : slides)\n    }), this.showDots && dotSlotProps.total > 1 && resolveSlotWithProps(dotsSlot, dotSlotProps, () => [h(NCarouselDots, {\n      key: dotType + dotPlacement,\n      total: dotSlotProps.total,\n      currentIndex: dotSlotProps.currentIndex,\n      dotType: dotType,\n      trigger: this.trigger,\n      keyboard: this.keyboard\n    })]), showArrow && resolveSlotWithProps(arrowSlot, arrowSlotProps, () => [h(NCarouselArrow, null)]));\n  }\n});\nfunction filterCarouselItem(vnodes) {\n  return vnodes.reduce((carouselItems, vnode) => {\n    if (isCarouselItem(vnode)) {\n      carouselItems.push(vnode);\n    }\n    return carouselItems;\n  }, []);\n}","map":{"version":3,"names":["h","defineComponent","ref","cloneVNode","computed","onBeforeUnmount","watch","withDirectives","vShow","Transition","toRef","nextTick","onMounted","watchEffect","normalizeStyle","onUpdated","VResizeObserver","useMergedState","on","off","getPreciseEventTarget","useConfig","useTheme","useThemeClass","flatten","keep","resolveSlotWithProps","carouselLight","calculateSize","clampValue","resolveSpeed","isTouchEvent","getNextIndex","getPrevIndex","getDisplayIndex","getRealIndex","getDisplayTotalView","addDuplicateSlides","provideCarouselContext","NCarouselDots","NCarouselArrow","NCarouselItem","isCarouselItem","style","transitionProperties","carouselProps","Object","assign","props","defaultIndex","type","Number","default","currentIndex","showArrow","Boolean","dotType","String","dotPlacement","slidesPerView","spaceBetween","centeredSlides","direction","autoplay","interval","loop","effect","showDots","trigger","transitionStyle","transitionDuration","transitionProps","draggable","prevSlideStyle","nextSlideStyle","touchable","mousewheel","keyboard","Function","onUpdateCurrentIndex","globalDragging","name","setup","mergedClsPrefixRef","inlineThemeDisabled","selfElRef","slidesElRef","slideElsRef","slideVNodesRef","value","verticalRef","sizeAxisRef","spaceAxisRef","sequenceLayoutRef","duplicatedableRef","userWantsControlRef","displaySlidesPerViewRef","realSlidesPerViewRef","autoSlideSizeRef","perViewSizeRef","width","height","slideSizesRef","slidesEls","length","autoSlideSize","map","slide","perViewSize","axis","axisSize","remaining","percentage","Math","max","slideSize","slideTranlatesRef","slideSizes","previousTranslate","translate","isMountedRef","transitionStyleRef","speedRef","slideStylesRef","useComputedSize","getSlideSize","index","_","i","spaceAxis","reduce","styles","push","totalViewRef","totalSlides","translates","lastViewSize","displayTotalViewRef","defaultRealIndex","uncontrolledDisplayIndexRef","mergedDisplayIndexRef","realIndexRef","toRealIndex","_a","_b","displayIndex","lastDisplayIndex","call","getRealPrevIndex","getRealNextIndex","isRealPrev","slideOrIndex","getSlideIndex","isRealNext","isRealActive","isDisplayActive","isPrevDisabled","isNextDisabled","to","realIndex","prev","prevIndex","next","nextIndex","prevIfSlideTransitionEnd","inTransition","nextIfSlideTransitionEnd","translateStyleRef","updateTranslate","speed","transform","fixTranslate","translateTo","getTranslate","getLastViewTranslate","lastTranslate","overallSize","undefined","carouselContext","currentIndexRef","isVertical","isHorizontal","isPrev","isNext","isActive","getSlideStyle","addSlide","removeSlide","onCarouselItemClick","splice","indexOf","event","allowClick","dragging","isEffectiveDrag","preventDefault","stopPropagation","autoplayTimer","stopAutoplay","clearInterval","resetAutoplay","disabled","window","setInterval","dragStartX","dragStartY","dragOffset","dragStartTime","handleTouchstart","contains","Date","now","target","isContentEditable","touchEvent","touches","clientY","clientX","document","handleTouchmove","passive","handleTouchend","vertical","offset","cancelable","currentTranslate","slice","prevOffset","abs","timeElapsed","resetDragStatus","handleTransitionEnd","handleMousewheel","deltaX","deltaY","shiftKey","prevMultiplier","nextMultiplier","m","rx","ry","responseStep","handleResize","handleSlideResize","scheduler","run","handleMouseenter","handleMouseleave","requestAnimationFrame","slideVNodes","indexMap","Map","el","has","get","isChanged","findIndex","v","set","sort","a","b","lastRealIndex","immediate","deep","slidesControlListenersRef","onTouchstartPassive","onMousedown","onWheel","arrowSlotPropsRef","total","dotSlotPropsRef","caroulseExposedMethod","getCurrentIndex","themeRef","cssVarsRef","common","cubicBezierEaseInOut","self","dotSize","dotColor","dotColorActive","dotColorFocus","dotLineWidth","dotLineWidthActive","arrowColor","themeClassHandle","mergedClsPrefix","duplicatedable","userWantsControl","slideStyles","translateStyle","slidesControlListeners","arrowSlotProps","dotSlotProps","cssVars","themeClass","onRender","render","$slots","defaultSlot","dots","dotsSlot","arrow","arrowSlot","children","slides","filterCarouselItem","ch","onResize","class","onMouseenter","onMouseleave","role","onTransitionend","key","vnodes","carouselItems","vnode"],"sources":["/Users/elmo/Documents/GitHub/meetings_vue3/node_modules/naive-ui/es/carousel/src/Carousel.js"],"sourcesContent":["import { h, defineComponent, ref, cloneVNode, computed, onBeforeUnmount, watch, withDirectives, vShow, Transition, toRef, nextTick, onMounted, watchEffect, normalizeStyle, onUpdated } from 'vue';\nimport { VResizeObserver } from 'vueuc';\nimport { useMergedState } from 'vooks';\nimport { on, off } from 'evtd';\nimport { getPreciseEventTarget } from 'seemly';\nimport { useConfig, useTheme, useThemeClass } from '../../_mixins';\nimport { flatten, keep, resolveSlotWithProps } from '../../_utils';\nimport { carouselLight } from '../styles';\nimport { calculateSize, clampValue, resolveSpeed, isTouchEvent, getNextIndex, getPrevIndex, getDisplayIndex, getRealIndex, getDisplayTotalView, addDuplicateSlides } from './utils';\nimport { provideCarouselContext } from './CarouselContext';\nimport NCarouselDots from './CarouselDots';\nimport NCarouselArrow from './CarouselArrow';\nimport NCarouselItem, { isCarouselItem } from './CarouselItem';\nimport style from './styles/index.cssr';\nconst transitionProperties = [\n    'transitionDuration',\n    'transitionTimingFunction'\n];\nexport const carouselProps = Object.assign(Object.assign({}, useTheme.props), { defaultIndex: {\n        type: Number,\n        default: 0\n    }, currentIndex: Number, showArrow: Boolean, dotType: {\n        type: String,\n        default: 'dot'\n    }, dotPlacement: {\n        type: String,\n        default: 'bottom'\n    }, slidesPerView: {\n        type: [Number, String],\n        default: 1\n    }, spaceBetween: {\n        type: Number,\n        default: 0\n    }, centeredSlides: Boolean, direction: {\n        type: String,\n        default: 'horizontal'\n    }, autoplay: Boolean, interval: {\n        type: Number,\n        default: 5000\n    }, loop: {\n        type: Boolean,\n        default: true\n    }, effect: {\n        type: String,\n        default: 'slide'\n    }, showDots: {\n        type: Boolean,\n        default: true\n    }, trigger: {\n        type: String,\n        default: 'click'\n    }, transitionStyle: {\n        type: Object,\n        default: () => ({\n            transitionDuration: '300ms'\n        })\n    }, transitionProps: Object, draggable: Boolean, prevSlideStyle: [Object, String], nextSlideStyle: [Object, String], touchable: {\n        type: Boolean,\n        default: true\n    }, mousewheel: Boolean, keyboard: Boolean, 'onUpdate:currentIndex': Function, onUpdateCurrentIndex: Function });\n// only one carousel is allowed to trigger touch globally\nlet globalDragging = false;\nexport default defineComponent({\n    name: 'Carousel',\n    props: carouselProps,\n    setup(props) {\n        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);\n        // Dom\n        const selfElRef = ref(null);\n        const slidesElRef = ref(null);\n        const slideElsRef = ref([]);\n        const slideVNodesRef = { value: [] };\n        // Computed states\n        const verticalRef = computed(() => props.direction === 'vertical');\n        const sizeAxisRef = computed(() => (verticalRef.value ? 'height' : 'width'));\n        const spaceAxisRef = computed(() => verticalRef.value ? 'bottom' : 'right');\n        const sequenceLayoutRef = computed(() => props.effect === 'slide');\n        const duplicatedableRef = computed(\n        // duplicate the copy operation in `slide` mode,\n        // because only its DOM is sequence layout\n        () => props.loop && props.slidesPerView === 1 && sequenceLayoutRef.value);\n        // user wants to control the transition animation\n        const userWantsControlRef = computed(() => props.effect === 'custom');\n        // used to calculate total views\n        const displaySlidesPerViewRef = computed(() => !sequenceLayoutRef.value || props.centeredSlides ? 1 : props.slidesPerView);\n        // used to calculate the size of each slide\n        const realSlidesPerViewRef = computed(() => userWantsControlRef.value ? 1 : props.slidesPerView);\n        // we automatically calculate total view for special slides per view\n        const autoSlideSizeRef = computed(() => displaySlidesPerViewRef.value === 'auto' ||\n            (props.slidesPerView === 'auto' && props.centeredSlides));\n        // Carousel size\n        const perViewSizeRef = ref({ width: 0, height: 0 });\n        const slideSizesRef = computed(() => {\n            const { value: slidesEls } = slideElsRef;\n            if (!slidesEls.length)\n                return [];\n            const { value: autoSlideSize } = autoSlideSizeRef;\n            if (autoSlideSize) {\n                return slidesEls.map((slide) => calculateSize(slide));\n            }\n            const { value: slidesPerView } = realSlidesPerViewRef;\n            const { value: perViewSize } = perViewSizeRef;\n            const { value: axis } = sizeAxisRef;\n            let axisSize = perViewSize[axis];\n            if (slidesPerView !== 'auto') {\n                const { spaceBetween } = props;\n                const remaining = axisSize - (slidesPerView - 1) * spaceBetween;\n                const percentage = 1 / Math.max(1, slidesPerView);\n                axisSize = remaining * percentage;\n            }\n            const slideSize = Object.assign(Object.assign({}, perViewSize), { [axis]: axisSize });\n            return slidesEls.map(() => slideSize);\n        });\n        // The translate required to reach each slide\n        const slideTranlatesRef = computed(() => {\n            const { value: slideSizes } = slideSizesRef;\n            if (!slideSizes.length)\n                return [];\n            const { centeredSlides, spaceBetween } = props;\n            const { value: axis } = sizeAxisRef;\n            const { [axis]: perViewSize } = perViewSizeRef.value;\n            let previousTranslate = 0;\n            return slideSizes.map(({ [axis]: slideSize }) => {\n                let translate = previousTranslate;\n                if (centeredSlides) {\n                    translate += (slideSize - perViewSize) / 2;\n                }\n                previousTranslate += slideSize + spaceBetween;\n                return translate;\n            });\n        });\n        // Styles\n        const isMountedRef = ref(false);\n        const transitionStyleRef = computed(() => {\n            const { transitionStyle } = props;\n            return transitionStyle\n                ? keep(transitionStyle, transitionProperties)\n                : {};\n        });\n        const speedRef = computed(() => userWantsControlRef.value\n            ? 0\n            : resolveSpeed(transitionStyleRef.value.transitionDuration));\n        const slideStylesRef = computed(() => {\n            const { value: slidesEls } = slideElsRef;\n            if (!slidesEls.length)\n                return [];\n            const useComputedSize = !(autoSlideSizeRef.value || realSlidesPerViewRef.value === 1);\n            const getSlideSize = (index) => {\n                if (useComputedSize) {\n                    const { value: axis } = sizeAxisRef;\n                    return {\n                        [axis]: `${slideSizesRef.value[index][axis]}px`\n                    };\n                }\n            };\n            if (userWantsControlRef.value) {\n                // We center each slide when user wants to control the transition animation,\n                // so there is no need to calculate the offset\n                return slidesEls.map((_, i) => getSlideSize(i));\n            }\n            const { effect, spaceBetween } = props;\n            const { value: spaceAxis } = spaceAxisRef;\n            return slidesEls.reduce((styles, _, i) => {\n                const style = Object.assign(Object.assign({}, getSlideSize(i)), { [`margin-${spaceAxis}`]: `${spaceBetween}px` });\n                styles.push(style);\n                if (isMountedRef.value && (effect === 'fade' || effect === 'card')) {\n                    Object.assign(style, transitionStyleRef.value);\n                }\n                return styles;\n            }, []);\n        });\n        // Total\n        const totalViewRef = computed(() => {\n            const { value: slidesPerView } = displaySlidesPerViewRef;\n            const { length: totalSlides } = slideElsRef.value;\n            if (slidesPerView !== 'auto') {\n                return Math.max(totalSlides - slidesPerView, 0) + 1;\n            }\n            else {\n                const { value: slideSizes } = slideSizesRef;\n                const { length } = slideSizes;\n                if (!length)\n                    return totalSlides;\n                const { value: translates } = slideTranlatesRef;\n                const { value: axis } = sizeAxisRef;\n                const perViewSize = perViewSizeRef.value[axis];\n                let lastViewSize = slideSizes[slideSizes.length - 1][axis];\n                let i = length;\n                while (i > 1 && lastViewSize < perViewSize) {\n                    i--;\n                    lastViewSize += translates[i] - translates[i - 1];\n                }\n                return clampValue(i + 1, 1, length);\n            }\n        });\n        const displayTotalViewRef = computed(() => getDisplayTotalView(totalViewRef.value, duplicatedableRef.value));\n        // Index\n        const defaultRealIndex = getRealIndex(props.defaultIndex, duplicatedableRef.value);\n        const uncontrolledDisplayIndexRef = ref(getDisplayIndex(defaultRealIndex, totalViewRef.value, duplicatedableRef.value));\n        const mergedDisplayIndexRef = useMergedState(toRef(props, 'currentIndex'), uncontrolledDisplayIndexRef);\n        const realIndexRef = computed(() => getRealIndex(mergedDisplayIndexRef.value, duplicatedableRef.value));\n        // Reality methods\n        function toRealIndex(index) {\n            var _a, _b;\n            index = clampValue(index, 0, totalViewRef.value - 1);\n            const displayIndex = getDisplayIndex(index, totalViewRef.value, duplicatedableRef.value);\n            const { value: lastDisplayIndex } = mergedDisplayIndexRef;\n            if (displayIndex !== mergedDisplayIndexRef.value) {\n                uncontrolledDisplayIndexRef.value = displayIndex;\n                (_a = props['onUpdate:currentIndex']) === null || _a === void 0 ? void 0 : _a.call(props, displayIndex, lastDisplayIndex);\n                (_b = props.onUpdateCurrentIndex) === null || _b === void 0 ? void 0 : _b.call(props, displayIndex, lastDisplayIndex);\n            }\n        }\n        function getRealPrevIndex(index = realIndexRef.value) {\n            return getPrevIndex(index, totalViewRef.value, props.loop);\n        }\n        function getRealNextIndex(index = realIndexRef.value) {\n            return getNextIndex(index, totalViewRef.value, props.loop);\n        }\n        function isRealPrev(slideOrIndex) {\n            const index = getSlideIndex(slideOrIndex);\n            return index !== null && getRealPrevIndex() === index;\n        }\n        function isRealNext(slideOrIndex) {\n            const index = getSlideIndex(slideOrIndex);\n            return index !== null && getRealNextIndex() === index;\n        }\n        function isRealActive(slideOrIndex) {\n            return realIndexRef.value === getSlideIndex(slideOrIndex);\n        }\n        // Display methods\n        // They are used to deal with the actual values displayed on the UI\n        function isDisplayActive(index) {\n            return mergedDisplayIndexRef.value === index;\n        }\n        function isPrevDisabled() {\n            return getRealPrevIndex() === null;\n        }\n        function isNextDisabled() {\n            return getRealNextIndex() === null;\n        }\n        // To\n        function to(index) {\n            const realIndex = clampValue(getRealIndex(index, duplicatedableRef.value), 0, totalViewRef.value);\n            if (index !== mergedDisplayIndexRef.value ||\n                realIndex !== realIndexRef.value) {\n                toRealIndex(realIndex);\n            }\n        }\n        function prev() {\n            const prevIndex = getRealPrevIndex();\n            if (prevIndex !== null)\n                toRealIndex(prevIndex);\n        }\n        function next() {\n            const nextIndex = getRealNextIndex();\n            if (nextIndex !== null)\n                toRealIndex(nextIndex);\n        }\n        function prevIfSlideTransitionEnd() {\n            if (!inTransition || !duplicatedableRef.value)\n                prev();\n        }\n        function nextIfSlideTransitionEnd() {\n            if (!inTransition || !duplicatedableRef.value)\n                next();\n        }\n        // Translate to\n        let inTransition = false;\n        // record the translate of each slide, so that it can be restored at touch\n        let previousTranslate = 0;\n        const translateStyleRef = ref({});\n        function updateTranslate(translate, speed = 0) {\n            translateStyleRef.value = Object.assign({}, transitionStyleRef.value, {\n                transform: verticalRef.value\n                    ? `translateY(${-translate}px)`\n                    : `translateX(${-translate}px)`,\n                transitionDuration: `${speed}ms`\n            });\n        }\n        function fixTranslate(speed = 0) {\n            if (sequenceLayoutRef.value) {\n                translateTo(realIndexRef.value, speed);\n            }\n            else if (previousTranslate !== 0) {\n                if (!inTransition && speed > 0) {\n                    inTransition = true;\n                }\n                updateTranslate((previousTranslate = 0), speed);\n            }\n        }\n        function translateTo(index, speed) {\n            const translate = getTranslate(index);\n            if (translate !== previousTranslate && speed > 0) {\n                inTransition = true;\n            }\n            previousTranslate = getTranslate(realIndexRef.value);\n            updateTranslate(translate, speed);\n        }\n        function getTranslate(index) {\n            let translate;\n            // Deal with auto slides pre view\n            if (index >= totalViewRef.value - 1) {\n                translate = getLastViewTranslate();\n            }\n            else {\n                translate = slideTranlatesRef.value[index] || 0;\n            }\n            return translate;\n        }\n        function getLastViewTranslate() {\n            if (displaySlidesPerViewRef.value === 'auto') {\n                const { value: axis } = sizeAxisRef;\n                const { [axis]: perViewSize } = perViewSizeRef.value;\n                const { value: translates } = slideTranlatesRef;\n                const lastTranslate = translates[translates.length - 1];\n                let overallSize;\n                if (lastTranslate === undefined) {\n                    overallSize = perViewSize;\n                }\n                else {\n                    const { value: slideSizes } = slideSizesRef;\n                    overallSize = lastTranslate + slideSizes[slideSizes.length - 1][axis];\n                }\n                // Bring the last slide to the edge\n                return overallSize - perViewSize;\n            }\n            else {\n                const { value: translates } = slideTranlatesRef;\n                return translates[totalViewRef.value - 1] || 0;\n            }\n        }\n        // Provide\n        const carouselContext = {\n            currentIndexRef: mergedDisplayIndexRef,\n            to,\n            prev: prevIfSlideTransitionEnd,\n            next: nextIfSlideTransitionEnd,\n            isVertical: () => verticalRef.value,\n            isHorizontal: () => !verticalRef.value,\n            isPrev: isRealPrev,\n            isNext: isRealNext,\n            isActive: isRealActive,\n            isPrevDisabled,\n            isNextDisabled,\n            getSlideIndex,\n            getSlideStyle,\n            addSlide,\n            removeSlide,\n            onCarouselItemClick\n        };\n        provideCarouselContext(carouselContext);\n        function addSlide(slide) {\n            if (!slide)\n                return;\n            slideElsRef.value.push(slide);\n        }\n        function removeSlide(slide) {\n            if (!slide)\n                return;\n            const index = getSlideIndex(slide);\n            if (index !== -1) {\n                slideElsRef.value.splice(index, 1);\n            }\n        }\n        function getSlideIndex(slideOrIndex) {\n            return typeof slideOrIndex === 'number'\n                ? slideOrIndex\n                : slideOrIndex\n                    ? slideElsRef.value.indexOf(slideOrIndex)\n                    : -1;\n        }\n        function getSlideStyle(slide) {\n            const index = getSlideIndex(slide);\n            if (index !== -1) {\n                const styles = [slideStylesRef.value[index]];\n                const isPrev = carouselContext.isPrev(index);\n                const isNext = carouselContext.isNext(index);\n                if (isPrev) {\n                    styles.push(props.prevSlideStyle || '');\n                }\n                if (isNext) {\n                    styles.push(props.nextSlideStyle || '');\n                }\n                return normalizeStyle(styles);\n            }\n        }\n        function onCarouselItemClick(index, event) {\n            let allowClick = !inTransition && !dragging && !isEffectiveDrag;\n            if (props.effect === 'card' && allowClick && !isRealActive(index)) {\n                to(index);\n                allowClick = false;\n            }\n            if (!allowClick) {\n                event.preventDefault();\n                event.stopPropagation();\n            }\n        }\n        // Autoplay\n        let autoplayTimer = null;\n        function stopAutoplay() {\n            if (autoplayTimer) {\n                clearInterval(autoplayTimer);\n                autoplayTimer = null;\n            }\n        }\n        function resetAutoplay() {\n            stopAutoplay();\n            const disabled = !props.autoplay || displayTotalViewRef.value < 2;\n            if (!disabled) {\n                autoplayTimer = window.setInterval(next, props.interval);\n            }\n        }\n        // Drag\n        let dragStartX = 0;\n        let dragStartY = 0;\n        let dragOffset = 0;\n        let dragStartTime = 0;\n        let dragging = false;\n        let isEffectiveDrag = false;\n        function handleTouchstart(event) {\n            var _a;\n            if (globalDragging)\n                return;\n            if (!((_a = slidesElRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(event)))) {\n                return;\n            }\n            globalDragging = true;\n            dragging = true;\n            isEffectiveDrag = false;\n            dragStartTime = Date.now();\n            stopAutoplay();\n            if (event.type !== 'touchstart' &&\n                !event.target.isContentEditable) {\n                event.preventDefault();\n            }\n            const touchEvent = isTouchEvent(event) ? event.touches[0] : event;\n            if (verticalRef.value) {\n                dragStartY = touchEvent.clientY;\n            }\n            else {\n                dragStartX = touchEvent.clientX;\n            }\n            if (props.touchable) {\n                on('touchmove', document, handleTouchmove, { passive: true });\n                on('touchend', document, handleTouchend);\n                on('touchcancel', document, handleTouchend);\n            }\n            if (props.draggable) {\n                on('mousemove', document, handleTouchmove);\n                on('mouseup', document, handleTouchend);\n            }\n        }\n        function handleTouchmove(event) {\n            const { value: vertical } = verticalRef;\n            const { value: axis } = sizeAxisRef;\n            const touchEvent = isTouchEvent(event) ? event.touches[0] : event;\n            const offset = vertical\n                ? touchEvent.clientY - dragStartY\n                : touchEvent.clientX - dragStartX;\n            const perViewSize = perViewSizeRef.value[axis];\n            dragOffset = clampValue(offset, -perViewSize, perViewSize);\n            if (event.cancelable) {\n                event.preventDefault();\n            }\n            if (sequenceLayoutRef.value) {\n                updateTranslate(previousTranslate - dragOffset, 0);\n            }\n        }\n        function handleTouchend() {\n            const { value: realIndex } = realIndexRef;\n            let currentIndex = realIndex;\n            if (!inTransition && dragOffset !== 0 && sequenceLayoutRef.value) {\n                const currentTranslate = previousTranslate - dragOffset;\n                const translates = [\n                    ...slideTranlatesRef.value.slice(0, totalViewRef.value - 1),\n                    getLastViewTranslate()\n                ];\n                let prevOffset = null;\n                for (let i = 0; i < translates.length; i++) {\n                    const offset = Math.abs(translates[i] - currentTranslate);\n                    if (prevOffset !== null && prevOffset < offset) {\n                        break;\n                    }\n                    prevOffset = offset;\n                    currentIndex = i;\n                }\n            }\n            if (currentIndex === realIndex) {\n                const timeElapsed = Date.now() - dragStartTime;\n                const { value: axis } = sizeAxisRef;\n                const perViewSize = perViewSizeRef.value[axis];\n                // more than 50% width or faster than 0.4px per ms\n                if (dragOffset > perViewSize / 2 || dragOffset / timeElapsed > 0.4) {\n                    currentIndex = getRealPrevIndex(realIndex);\n                }\n                else if (dragOffset < -perViewSize / 2 ||\n                    dragOffset / timeElapsed < -0.4) {\n                    currentIndex = getRealNextIndex(realIndex);\n                }\n            }\n            if (currentIndex !== null && currentIndex !== realIndex) {\n                isEffectiveDrag = true;\n                toRealIndex(currentIndex);\n                void nextTick(() => {\n                    if (!duplicatedableRef.value ||\n                        uncontrolledDisplayIndexRef.value !== mergedDisplayIndexRef.value) {\n                        fixTranslate(speedRef.value);\n                    }\n                });\n            }\n            else {\n                fixTranslate(speedRef.value);\n            }\n            resetDragStatus();\n            resetAutoplay();\n        }\n        function resetDragStatus() {\n            if (dragging) {\n                globalDragging = false;\n            }\n            dragging = false;\n            dragStartX = 0;\n            dragStartY = 0;\n            dragOffset = 0;\n            dragStartTime = 0;\n            off('touchmove', document, handleTouchmove);\n            off('touchend', document, handleTouchend);\n            off('touchcancel', document, handleTouchend);\n            off('mousemove', document, handleTouchmove);\n            off('mouseup', document, handleTouchend);\n        }\n        function handleTransitionEnd() {\n            if (sequenceLayoutRef.value && inTransition) {\n                const { value: realIndex } = realIndexRef;\n                translateTo(realIndex, 0);\n            }\n            else {\n                resetAutoplay();\n            }\n            if (sequenceLayoutRef.value) {\n                translateStyleRef.value.transitionDuration = '0ms';\n            }\n            inTransition = false;\n        }\n        function handleMousewheel(event) {\n            event.preventDefault();\n            if (inTransition)\n                return;\n            let { deltaX, deltaY } = event;\n            if (event.shiftKey && !deltaX) {\n                deltaX = deltaY;\n            }\n            const prevMultiplier = -1;\n            const nextMultiplier = 1;\n            const m = (deltaX || deltaY) > 0 ? nextMultiplier : prevMultiplier;\n            let rx = 0;\n            let ry = 0;\n            if (verticalRef.value) {\n                ry = m;\n            }\n            else {\n                rx = m;\n            }\n            const responseStep = 10;\n            if (ry * deltaY >= responseStep || rx * deltaX >= responseStep) {\n                if (m === nextMultiplier && !isNextDisabled()) {\n                    next();\n                }\n                else if (m === prevMultiplier && !isPrevDisabled()) {\n                    prev();\n                }\n            }\n        }\n        function handleResize() {\n            perViewSizeRef.value = calculateSize(selfElRef.value, true);\n            resetAutoplay();\n        }\n        function handleSlideResize() {\n            var _a, _b;\n            if (autoSlideSizeRef.value) {\n                (_b = (_a = slideSizesRef.effect).scheduler) === null || _b === void 0 ? void 0 : _b.call(_a);\n                slideSizesRef.effect.run();\n            }\n        }\n        function handleMouseenter() {\n            if (props.autoplay) {\n                stopAutoplay();\n            }\n        }\n        function handleMouseleave() {\n            if (props.autoplay) {\n                resetAutoplay();\n            }\n        }\n        onMounted(() => {\n            watchEffect(resetAutoplay);\n            requestAnimationFrame(() => (isMountedRef.value = true));\n        });\n        onBeforeUnmount(() => {\n            resetDragStatus();\n            stopAutoplay();\n        });\n        // Fix index when remounting\n        onUpdated(() => {\n            const { value: slidesEls } = slideElsRef;\n            const { value: slideVNodes } = slideVNodesRef;\n            const indexMap = new Map();\n            const getDisplayIndex = (el) => \n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            indexMap.has(el) ? indexMap.get(el) : -1;\n            let isChanged = false;\n            for (let i = 0; i < slidesEls.length; i++) {\n                const index = slideVNodes.findIndex((v) => v.el === slidesEls[i]);\n                if (index !== i) {\n                    isChanged = true;\n                }\n                indexMap.set(slidesEls[i], index);\n            }\n            if (isChanged) {\n                slidesEls.sort((a, b) => getDisplayIndex(a) - getDisplayIndex(b));\n            }\n        });\n        watch(realIndexRef, (realIndex, lastRealIndex) => {\n            if (realIndex === lastRealIndex)\n                return;\n            resetAutoplay();\n            if (sequenceLayoutRef.value) {\n                if (duplicatedableRef.value && displayTotalViewRef.value > 2) {\n                    const { value: length } = totalViewRef;\n                    if (realIndex === length - 2 && lastRealIndex === 1) {\n                        realIndex = 0;\n                    }\n                    else if (realIndex === 1 && lastRealIndex === length - 2) {\n                        realIndex = length - 1;\n                    }\n                }\n                translateTo(realIndex, speedRef.value);\n            }\n            else {\n                fixTranslate();\n            }\n        }, { immediate: true });\n        watch([duplicatedableRef, displaySlidesPerViewRef], () => void nextTick(() => toRealIndex(realIndexRef.value)));\n        watch(slideTranlatesRef, () => sequenceLayoutRef.value && fixTranslate(), {\n            deep: true\n        });\n        watch(sequenceLayoutRef, (value) => {\n            if (!value) {\n                inTransition = false;\n                // if the current mode does not support translate, reset the position of the wrapper\n                updateTranslate((previousTranslate = 0));\n            }\n            else {\n                fixTranslate();\n            }\n        });\n        const slidesControlListenersRef = computed(() => {\n            return {\n                onTouchstartPassive: props.touchable ? handleTouchstart : undefined,\n                onMousedown: props.draggable ? handleTouchstart : undefined,\n                onWheel: props.mousewheel ? handleMousewheel : undefined\n            };\n        });\n        const arrowSlotPropsRef = computed(() => (Object.assign(Object.assign({}, keep(carouselContext, [\n            'to',\n            'prev',\n            'next',\n            'isPrevDisabled',\n            'isNextDisabled'\n        ])), { total: displayTotalViewRef.value, currentIndex: mergedDisplayIndexRef.value })));\n        const dotSlotPropsRef = computed(() => ({\n            total: displayTotalViewRef.value,\n            currentIndex: mergedDisplayIndexRef.value,\n            to: carouselContext.to\n        }));\n        const caroulseExposedMethod = {\n            getCurrentIndex: () => mergedDisplayIndexRef.value,\n            to,\n            prev,\n            next\n        };\n        const themeRef = useTheme('Carousel', '-carousel', style, carouselLight, props, mergedClsPrefixRef);\n        const cssVarsRef = computed(() => {\n            const { common: { cubicBezierEaseInOut }, self: { dotSize, dotColor, dotColorActive, dotColorFocus, dotLineWidth, dotLineWidthActive, arrowColor } } = themeRef.value;\n            return {\n                '--n-bezier': cubicBezierEaseInOut,\n                '--n-dot-color': dotColor,\n                '--n-dot-color-focus': dotColorFocus,\n                '--n-dot-color-active': dotColorActive,\n                '--n-dot-size': dotSize,\n                '--n-dot-line-width': dotLineWidth,\n                '--n-dot-line-width-active': dotLineWidthActive,\n                '--n-arrow-color': arrowColor\n            };\n        });\n        const themeClassHandle = inlineThemeDisabled\n            ? useThemeClass('carousel', undefined, cssVarsRef, props)\n            : undefined;\n        return Object.assign(Object.assign({ mergedClsPrefix: mergedClsPrefixRef, selfElRef,\n            slidesElRef, slideVNodes: slideVNodesRef, duplicatedable: duplicatedableRef, userWantsControl: userWantsControlRef, autoSlideSize: autoSlideSizeRef, displayIndex: mergedDisplayIndexRef, realIndex: realIndexRef, slideStyles: slideStylesRef, translateStyle: translateStyleRef, slidesControlListeners: slidesControlListenersRef, handleTransitionEnd,\n            handleResize,\n            handleSlideResize,\n            handleMouseenter,\n            handleMouseleave, isActive: isDisplayActive, arrowSlotProps: arrowSlotPropsRef, dotSlotProps: dotSlotPropsRef }, caroulseExposedMethod), { cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender });\n    },\n    render() {\n        var _a;\n        const { mergedClsPrefix, showArrow, userWantsControl, slideStyles, dotType, dotPlacement, slidesControlListeners, transitionProps = {}, arrowSlotProps, dotSlotProps, $slots: { default: defaultSlot, dots: dotsSlot, arrow: arrowSlot } } = this;\n        const children = (defaultSlot && flatten(defaultSlot())) || [];\n        let slides = filterCarouselItem(children);\n        if (!slides.length) {\n            slides = children.map((ch) => (h(NCarouselItem, null, {\n                default: () => cloneVNode(ch)\n            })));\n        }\n        if (this.duplicatedable) {\n            slides = addDuplicateSlides(slides);\n        }\n        this.slideVNodes.value = slides;\n        // When users need to customize the size of the slide,\n        // we listen to them to fix the current translate\n        if (this.autoSlideSize) {\n            slides = slides.map((slide) => (h(VResizeObserver, { onResize: this.handleSlideResize }, {\n                default: () => slide\n            })));\n        }\n        (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n        return (h(\"div\", Object.assign({ ref: \"selfElRef\", class: [\n                this.themeClass,\n                `${mergedClsPrefix}-carousel`,\n                this.direction === 'vertical' &&\n                    `${mergedClsPrefix}-carousel--vertical`,\n                this.showArrow && `${mergedClsPrefix}-carousel--show-arrow`,\n                `${mergedClsPrefix}-carousel--${dotPlacement}`,\n                `${mergedClsPrefix}-carousel--${this.direction}`,\n                `${mergedClsPrefix}-carousel--${this.effect}`,\n                userWantsControl && `${mergedClsPrefix}-carousel--usercontrol`\n            ], style: this.cssVars }, slidesControlListeners, { onMouseenter: this.handleMouseenter, onMouseleave: this.handleMouseleave }),\n            h(VResizeObserver, { onResize: this.handleResize }, {\n                default: () => (h(\"div\", { ref: \"slidesElRef\", class: `${mergedClsPrefix}-carousel__slides`, role: \"listbox\", style: this.translateStyle, onTransitionend: this.handleTransitionEnd }, userWantsControl\n                    ? slides.map((slide, i) => (h(\"div\", { style: slideStyles[i], key: i }, withDirectives(h(Transition, Object.assign({}, transitionProps), {\n                        default: () => slide\n                    }), [[vShow, this.isActive(i)]]))))\n                    : slides))\n            }),\n            this.showDots &&\n                dotSlotProps.total > 1 &&\n                resolveSlotWithProps(dotsSlot, dotSlotProps, () => [\n                    h(NCarouselDots, { key: dotType + dotPlacement, total: dotSlotProps.total, currentIndex: dotSlotProps.currentIndex, dotType: dotType, trigger: this.trigger, keyboard: this.keyboard })\n                ]),\n            showArrow &&\n                resolveSlotWithProps(arrowSlot, arrowSlotProps, () => [\n                    h(NCarouselArrow, null)\n                ])));\n    }\n});\nfunction filterCarouselItem(vnodes) {\n    return vnodes.reduce((carouselItems, vnode) => {\n        if (isCarouselItem(vnode)) {\n            carouselItems.push(vnode);\n        }\n        return carouselItems;\n    }, []);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}