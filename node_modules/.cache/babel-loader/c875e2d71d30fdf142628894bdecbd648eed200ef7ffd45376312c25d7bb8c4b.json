{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { watch, onMounted, inject, getCurrentInstance, onBeforeUnmount } from 'vue';\n// injection.collection {\n//   key1: [insta, instb]\n//   key2: [instc]\n// }\nexport function useInjectionInstanceCollection(injectionName, collectionKey, registerKeyRef) {\n  var _a;\n  const injection = inject(injectionName, null);\n  if (injection === null) return;\n  const vm = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy;\n  watch(registerKeyRef, registerInstance);\n  registerInstance(registerKeyRef.value);\n  onBeforeUnmount(() => {\n    registerInstance(undefined, registerKeyRef.value);\n  });\n  function registerInstance(key, oldKey) {\n    const collection = injection[collectionKey];\n    if (oldKey !== undefined) removeInstance(collection, oldKey);\n    if (key !== undefined) addInstance(collection, key);\n  }\n  function removeInstance(collection, key) {\n    if (!collection[key]) collection[key] = [];\n    collection[key].splice(collection[key].findIndex(instance => instance === vm), 1);\n  }\n  function addInstance(collection, key) {\n    if (!collection[key]) collection[key] = [];\n    if (!~collection[key].findIndex(instance => instance === vm)) {\n      collection[key].push(vm);\n    }\n  }\n}\n// injection.collection {\n//   key1: [insta.value, instb.value]\n//   key2: [instc.value]\n// }\nexport function useInjectionCollection(injectionName, collectionKey, valueRef) {\n  const injection = inject(injectionName, null);\n  if (injection === null) return;\n  if (!(collectionKey in injection)) {\n    injection[collectionKey] = [];\n  }\n  injection[collectionKey].push(valueRef.value);\n  watch(valueRef, (value, prevValue) => {\n    const collectionArray = injection[collectionKey];\n    const index = collectionArray.findIndex(collectionValue => collectionValue === prevValue);\n    if (~index) collectionArray.splice(index, 1);\n    collectionArray.push(value);\n  });\n  onBeforeUnmount(() => {\n    const collectionArray = injection[collectionKey];\n    const index = collectionArray.findIndex(collectionValue => collectionValue === valueRef.value);\n    if (~index) collectionArray.splice(index, 1);\n  });\n}\n// injection.collection {\n//   key1: [insta.$el, instb.$el]\n//   key2: [instc.$el]\n// }\nexport function useInjectionElementCollection(injectionName, collectionKey, getElement) {\n  const injection = inject(injectionName, null);\n  if (injection === null) return;\n  if (!(collectionKey in injection)) {\n    injection[collectionKey] = [];\n  }\n  onMounted(() => {\n    const el = getElement();\n    if (!el) return;\n    injection[collectionKey].push(el);\n  });\n  onBeforeUnmount(() => {\n    const collectionArray = injection[collectionKey];\n    const element = getElement();\n    const index = collectionArray.findIndex(collectionElement => collectionElement === element);\n    if (~index) collectionArray.splice(index, 1);\n  });\n}","map":{"version":3,"names":["watch","onMounted","inject","getCurrentInstance","onBeforeUnmount","useInjectionInstanceCollection","injectionName","collectionKey","registerKeyRef","_a","injection","vm","proxy","registerInstance","value","undefined","key","oldKey","collection","removeInstance","addInstance","splice","findIndex","instance","push","useInjectionCollection","valueRef","prevValue","collectionArray","index","collectionValue","useInjectionElementCollection","getElement","el","element","collectionElement"],"sources":["/Users/elmo/GitHub/meetings_vue3/node_modules/naive-ui/es/_utils/composable/use-collection.js"],"sourcesContent":["import { watch, onMounted, inject, getCurrentInstance, onBeforeUnmount } from 'vue';\n// injection.collection {\n//   key1: [insta, instb]\n//   key2: [instc]\n// }\nexport function useInjectionInstanceCollection(injectionName, collectionKey, registerKeyRef) {\n    var _a;\n    const injection = inject(injectionName, null);\n    if (injection === null)\n        return;\n    const vm = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy;\n    watch(registerKeyRef, registerInstance);\n    registerInstance(registerKeyRef.value);\n    onBeforeUnmount(() => {\n        registerInstance(undefined, registerKeyRef.value);\n    });\n    function registerInstance(key, oldKey) {\n        const collection = injection[collectionKey];\n        if (oldKey !== undefined)\n            removeInstance(collection, oldKey);\n        if (key !== undefined)\n            addInstance(collection, key);\n    }\n    function removeInstance(collection, key) {\n        if (!collection[key])\n            collection[key] = [];\n        collection[key].splice(collection[key].findIndex((instance) => instance === vm), 1);\n    }\n    function addInstance(collection, key) {\n        if (!collection[key])\n            collection[key] = [];\n        if (!~collection[key].findIndex((instance) => instance === vm)) {\n            collection[key].push(vm);\n        }\n    }\n}\n// injection.collection {\n//   key1: [insta.value, instb.value]\n//   key2: [instc.value]\n// }\nexport function useInjectionCollection(injectionName, collectionKey, valueRef) {\n    const injection = inject(injectionName, null);\n    if (injection === null)\n        return;\n    if (!(collectionKey in injection)) {\n        injection[collectionKey] = [];\n    }\n    injection[collectionKey].push(valueRef.value);\n    watch(valueRef, (value, prevValue) => {\n        const collectionArray = injection[collectionKey];\n        const index = collectionArray.findIndex((collectionValue) => collectionValue === prevValue);\n        if (~index)\n            collectionArray.splice(index, 1);\n        collectionArray.push(value);\n    });\n    onBeforeUnmount(() => {\n        const collectionArray = injection[collectionKey];\n        const index = collectionArray.findIndex((collectionValue) => collectionValue === valueRef.value);\n        if (~index)\n            collectionArray.splice(index, 1);\n    });\n}\n// injection.collection {\n//   key1: [insta.$el, instb.$el]\n//   key2: [instc.$el]\n// }\nexport function useInjectionElementCollection(injectionName, collectionKey, getElement) {\n    const injection = inject(injectionName, null);\n    if (injection === null)\n        return;\n    if (!(collectionKey in injection)) {\n        injection[collectionKey] = [];\n    }\n    onMounted(() => {\n        const el = getElement();\n        if (!el)\n            return;\n        injection[collectionKey].push(el);\n    });\n    onBeforeUnmount(() => {\n        const collectionArray = injection[collectionKey];\n        const element = getElement();\n        const index = collectionArray.findIndex((collectionElement) => collectionElement === element);\n        if (~index)\n            collectionArray.splice(index, 1);\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}