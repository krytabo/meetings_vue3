{"ast":null,"code":"import videojs from 'video.js';\nimport { version } from 'videojs-swf/package.json';\nimport window from 'global/window';\nvar version$1 = \"2.2.1\";\n\n/**\n * @file flash-rtmp.js\n * @module flash-rtmp\n */\n\n/**\n * Add RTMP properties to the {@link Flash} Tech.\n *\n * @param {Flash} Flash\n *        The flash tech class.\n *\n * @mixin FlashRtmpDecorator\n *\n * @return {Flash}\n *         The flash tech with RTMP properties added.\n */\nfunction FlashRtmpDecorator(Flash) {\n  Flash.streamingFormats = {\n    'rtmp/mp4': 'MP4',\n    'rtmp/flv': 'FLV'\n  };\n\n  /**\n   * Join connection and stream with an ampersand.\n   *\n   * @param {string} connection\n   *        The connection string.\n   *\n   * @param {string} stream\n   *        The stream string.\n   *\n   * @return {string}\n   *         The connection and stream joined with an `&` character\n   */\n  Flash.streamFromParts = function (connection, stream) {\n    return connection + '&' + stream;\n  };\n\n  /**\n   * The flash parts object that contains connection and stream info.\n   *\n   * @typedef {Object} Flash~PartsObject\n   *\n   * @property {string} connection\n   *           The connection string of a source, defaults to an empty string.\n   *\n   * @property {string} stream\n   *           The stream string of the source, defaults to an empty string.\n   */\n\n  /**\n   * Convert a source url into a stream and connection parts.\n   *\n   * @param {string} src\n   *        the source url\n   *\n   * @return {Flash~PartsObject}\n   *         The parts object that contains a connection and a stream\n   */\n  Flash.streamToParts = function (src) {\n    var parts = {\n      connection: '',\n      stream: ''\n    };\n    if (!src) {\n      return parts;\n    }\n\n    // Look for the normal URL separator we expect, '&'.\n    // If found, we split the URL into two pieces around the\n    // first '&'.\n    var connEnd = src.search(/&(?![\\w-]+=)/);\n    var streamBegin = void 0;\n    if (connEnd !== -1) {\n      streamBegin = connEnd + 1;\n    } else {\n      // If there's not a '&', we use the last '/' as the delimiter.\n      connEnd = streamBegin = src.lastIndexOf('/') + 1;\n      if (connEnd === 0) {\n        // really, there's not a '/'?\n        connEnd = streamBegin = src.length;\n      }\n    }\n    parts.connection = src.substring(0, connEnd);\n    parts.stream = src.substring(streamBegin, src.length);\n    return parts;\n  };\n\n  /**\n   * Check if the source type is a streaming type.\n   *\n   * @param {string} srcType\n   *        The mime type to check.\n   *\n   * @return {boolean}\n   *          - True if the source type is a streaming type.\n   *          - False if the source type is not a streaming type.\n   */\n  Flash.isStreamingType = function (srcType) {\n    return srcType in Flash.streamingFormats;\n  };\n\n  // RTMP has four variations, any string starting\n  // with one of these protocols should be valid\n\n  /**\n   * Regular expression used to check if the source is an rtmp source.\n   *\n   * @property {RegExp} Flash.RTMP_RE\n   */\n  Flash.RTMP_RE = /^rtmp[set]?:\\/\\//i;\n\n  /**\n   * Check if the source itself is a streaming type.\n   *\n   * @param {string} src\n   *        The url to the source.\n   *\n   * @return {boolean}\n   *          - True if the source url indicates that the source is streaming.\n   *          - False if the shource url indicates that the source url is not streaming.\n   */\n  Flash.isStreamingSrc = function (src) {\n    return Flash.RTMP_RE.test(src);\n  };\n\n  /**\n   * A source handler for RTMP urls\n   * @type {Object}\n   */\n  Flash.rtmpSourceHandler = {};\n\n  /**\n   * Check if Flash can play the given mime type.\n   *\n   * @param {string} type\n   *        The mime type to check\n   *\n   * @return {string}\n   *         'maybe', or '' (empty string)\n   */\n  Flash.rtmpSourceHandler.canPlayType = function (type) {\n    if (Flash.isStreamingType(type)) {\n      return 'maybe';\n    }\n    return '';\n  };\n\n  /**\n   * Check if Flash can handle the source natively\n   *\n   * @param {Object} source\n   *        The source object\n   *\n   * @param {Object} [options]\n   *        The options passed to the tech\n   *\n   * @return {string}\n   *         'maybe', or '' (empty string)\n   */\n  Flash.rtmpSourceHandler.canHandleSource = function (source, options) {\n    var can = Flash.rtmpSourceHandler.canPlayType(source.type);\n    if (can) {\n      return can;\n    }\n    if (Flash.isStreamingSrc(source.src)) {\n      return 'maybe';\n    }\n    return '';\n  };\n\n  /**\n   * Pass the source to the flash object.\n   *\n   * @param {Object} source\n   *        The source object\n   *\n   * @param {Flash} tech\n   *        The instance of the Flash tech\n   *\n   * @param {Object} [options]\n   *        The options to pass to the source\n   */\n  Flash.rtmpSourceHandler.handleSource = function (source, tech, options) {\n    var srcParts = Flash.streamToParts(source.src);\n    tech.setRtmpConnection(srcParts.connection);\n    tech.setRtmpStream(srcParts.stream);\n  };\n\n  // Register the native source handler\n  Flash.registerSourceHandler(Flash.rtmpSourceHandler);\n  return Flash;\n}\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n/**\n * @file flash.js\n * VideoJS-SWF - Custom Flash Player with HTML5-ish API\n * https://github.com/zencoder/video-js-swf\n * Not using setupTriggers. Using global onEvent func to distribute events\n */\n\nvar Tech = videojs.getComponent('Tech');\nvar Dom = videojs.dom;\nvar Url = videojs.url;\nvar createTimeRange = videojs.createTimeRange;\nvar mergeOptions = videojs.mergeOptions;\nvar navigator = window && window.navigator || {};\n\n/**\n * Flash Media Controller - Wrapper for Flash Media API\n *\n * @mixes FlashRtmpDecorator\n * @mixes Tech~SouceHandlerAdditions\n * @extends Tech\n */\n\nvar Flash = function (_Tech) {\n  inherits(Flash, _Tech);\n\n  /**\n  * Create an instance of this Tech.\n  *\n  * @param {Object} [options]\n  *        The key/value store of player options.\n  *\n  * @param {Component~ReadyCallback} ready\n  *        Callback function to call when the `Flash` Tech is ready.\n  */\n  function Flash(options, ready) {\n    classCallCheck(this, Flash);\n\n    // Set the source when ready\n    var _this = possibleConstructorReturn(this, _Tech.call(this, options, ready));\n    if (options.source) {\n      _this.ready(function () {\n        this.setSource(options.source);\n      }, true);\n    }\n\n    // Having issues with Flash reloading on certain page actions\n    // (hide/resize/fullscreen) in certain browsers\n    // This allows resetting the playhead when we catch the reload\n    if (options.startTime) {\n      _this.ready(function () {\n        this.load();\n        this.play();\n        this.currentTime(options.startTime);\n      }, true);\n    }\n\n    // Add global window functions that the swf expects\n    // A 4.x workflow we weren't able to solve for in 5.0\n    // because of the need to hard code these functions\n    // into the swf for security reasons\n    window.videojs = window.videojs || {};\n    window.videojs.Flash = window.videojs.Flash || {};\n    window.videojs.Flash.onReady = Flash.onReady;\n    window.videojs.Flash.onEvent = Flash.onEvent;\n    window.videojs.Flash.onError = Flash.onError;\n    _this.on('seeked', function () {\n      this.lastSeekTarget_ = undefined;\n    });\n    return _this;\n  }\n\n  /**\n   * Create the `Flash` Tech's DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n  Flash.prototype.createEl = function createEl() {\n    var options = this.options_;\n\n    // If video.js is hosted locally you should also set the location\n    // for the hosted swf, which should be relative to the page (not video.js)\n    // Otherwise this adds a CDN url.\n    // The CDN also auto-adds a swf URL for that specific version.\n    if (!options.swf) {\n      options.swf = 'https://vjs.zencdn.net/swf/' + version + '/video-js.swf';\n    }\n\n    // Generate ID for swf object\n    var objId = options.techId;\n\n    // Merge default flashvars with ones passed in to init\n    var flashVars = mergeOptions({\n      // SWF Callback Functions\n      readyFunction: 'videojs.Flash.onReady',\n      eventProxyFunction: 'videojs.Flash.onEvent',\n      errorEventProxyFunction: 'videojs.Flash.onError',\n      // Player Settings\n      autoplay: options.autoplay,\n      preload: options.preload,\n      loop: options.loop,\n      muted: options.muted\n    }, options.flashVars);\n\n    // Merge default parames with ones passed in\n    var params = mergeOptions({\n      // Opaque is needed to overlay controls, but can affect playback performance\n      wmode: 'opaque',\n      // Using bgcolor prevents a white flash when the object is loading\n      bgcolor: '#000000'\n    }, options.params);\n\n    // Merge default attributes with ones passed in\n    var attributes = mergeOptions({\n      // Both ID and Name needed or swf to identify itself\n      id: objId,\n      name: objId,\n      'class': 'vjs-tech'\n    }, options.attributes);\n    this.el_ = Flash.embed(options.swf, flashVars, params, attributes);\n    this.el_.tech = this;\n    return this.el_;\n  };\n\n  /**\n   * Called by {@link Player#play} to play using the `Flash` `Tech`.\n   */\n\n  Flash.prototype.play = function play() {\n    if (this.ended()) {\n      this.setCurrentTime(0);\n    }\n    this.el_.vjs_play();\n  };\n\n  /**\n   * Called by {@link Player#pause} to pause using the `Flash` `Tech`.\n   */\n\n  Flash.prototype.pause = function pause() {\n    this.el_.vjs_pause();\n  };\n\n  /**\n   * A getter/setter for the `Flash` Tech's source object.\n   * > Note: Please use {@link Flash#setSource}\n   *\n   * @param {Tech~SourceObject} [src]\n   *        The source object you want to set on the `Flash` techs.\n   *\n   * @return {Tech~SourceObject|undefined}\n   *         - The current source object when a source is not passed in.\n   *         - undefined when setting\n   *\n   * @deprecated Since version 5.\n   */\n\n  Flash.prototype.src = function src(_src) {\n    if (_src === undefined) {\n      return this.currentSrc();\n    }\n\n    // Setting src through `src` not `setSrc` will be deprecated\n    return this.setSrc(_src);\n  };\n\n  /**\n   * A getter/setter for the `Flash` Tech's source object.\n   *\n   * @param {Tech~SourceObject} [src]\n   *        The source object you want to set on the `Flash` techs.\n   */\n\n  Flash.prototype.setSrc = function setSrc(src) {\n    var _this2 = this;\n\n    // Make sure source URL is absolute.\n    src = Url.getAbsoluteURL(src);\n    this.el_.vjs_src(src);\n\n    // Currently the SWF doesn't autoplay if you load a source later.\n    // e.g. Load player w/ no source, wait 2s, set src.\n    if (this.autoplay()) {\n      this.setTimeout(function () {\n        return _this2.play();\n      }, 0);\n    }\n  };\n\n  /**\n   * Indicates whether the media is currently seeking to a new position or not.\n   *\n   * @return {boolean}\n   *         - True if seeking to a new position\n   *         - False otherwise\n   */\n\n  Flash.prototype.seeking = function seeking() {\n    return this.lastSeekTarget_ !== undefined;\n  };\n\n  /**\n   * Returns the current time in seconds that the media is at in playback.\n   *\n   * @param {number} time\n   *        Current playtime of the media in seconds.\n   */\n\n  Flash.prototype.setCurrentTime = function setCurrentTime(time) {\n    var seekable = this.seekable();\n    if (seekable.length) {\n      // clamp to the current seekable range\n      time = time > seekable.start(0) ? time : seekable.start(0);\n      time = time < seekable.end(seekable.length - 1) ? time : seekable.end(seekable.length - 1);\n      this.lastSeekTarget_ = time;\n      this.trigger('seeking');\n      this.el_.vjs_setProperty('currentTime', time);\n      _Tech.prototype.setCurrentTime.call(this);\n    }\n  };\n\n  /**\n   * Get the current playback time in seconds\n   *\n   * @return {number}\n   *         The current time of playback in seconds.\n   */\n\n  Flash.prototype.currentTime = function currentTime() {\n    // when seeking make the reported time keep up with the requested time\n    // by reading the time we're seeking to\n    if (this.seeking()) {\n      return this.lastSeekTarget_ || 0;\n    }\n    return this.el_.vjs_getProperty('currentTime');\n  };\n\n  /**\n   * Get the current source\n   *\n   * @method currentSrc\n   * @return {Tech~SourceObject}\n   *         The current source\n   */\n\n  Flash.prototype.currentSrc = function currentSrc() {\n    if (this.currentSource_) {\n      return this.currentSource_.src;\n    }\n    return this.el_.vjs_getProperty('currentSrc');\n  };\n\n  /**\n   * Get the total duration of the current media.\n   *\n   * @return {number}\n   8          The total duration of the current media.\n   */\n\n  Flash.prototype.duration = function duration() {\n    if (this.readyState() === 0) {\n      return NaN;\n    }\n    var duration = this.el_.vjs_getProperty('duration');\n    return duration >= 0 ? duration : Infinity;\n  };\n\n  /**\n   * Load media into Tech.\n   */\n\n  Flash.prototype.load = function load() {\n    this.el_.vjs_load();\n  };\n\n  /**\n   * Get the poster image that was set on the tech.\n   */\n\n  Flash.prototype.poster = function poster() {\n    this.el_.vjs_getProperty('poster');\n  };\n\n  /**\n   * Poster images are not handled by the Flash tech so make this is a no-op.\n   */\n\n  Flash.prototype.setPoster = function setPoster() {};\n\n  /**\n   * Determine the time ranges that can be seeked to in the media.\n   *\n   * @return {TimeRange}\n   *         Returns the time ranges that can be seeked to.\n   */\n\n  Flash.prototype.seekable = function seekable() {\n    var duration = this.duration();\n    if (duration === 0) {\n      return createTimeRange();\n    }\n    return createTimeRange(0, duration);\n  };\n\n  /**\n   * Get and create a `TimeRange` object for buffering.\n   *\n   * @return {TimeRange}\n   *         The time range object that was created.\n   */\n\n  Flash.prototype.buffered = function buffered() {\n    var ranges = this.el_.vjs_getProperty('buffered');\n    if (ranges.length === 0) {\n      return createTimeRange();\n    }\n    return createTimeRange(ranges[0][0], ranges[0][1]);\n  };\n\n  /**\n   * Get fullscreen support -\n   *\n   * Flash does not allow fullscreen through javascript\n   * so this always returns false.\n   *\n   * @return {boolean}\n   *         The Flash tech does not support fullscreen, so it will always return false.\n   */\n\n  Flash.prototype.supportsFullScreen = function supportsFullScreen() {\n    // Flash does not allow fullscreen through javascript\n    return false;\n  };\n\n  /**\n   * Flash does not allow fullscreen through javascript\n   * so this always returns false.\n   *\n   * @return {boolean}\n   *         The Flash tech does not support fullscreen, so it will always return false.\n   */\n\n  Flash.prototype.enterFullScreen = function enterFullScreen() {\n    return false;\n  };\n\n  /**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object}\n   *         An object with supported media playback quality metrics\n   */\n\n  Flash.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {\n    var videoPlaybackQuality = this.el_.vjs_getProperty('getVideoPlaybackQuality');\n    if (window.performance && typeof window.performance.now === 'function') {\n      videoPlaybackQuality.creationTime = window.performance.now();\n    } else if (window.performance && window.performance.timing && typeof window.performance.timing.navigationStart === 'number') {\n      videoPlaybackQuality.creationTime = window.Date.now() - window.performance.timing.navigationStart;\n    }\n    return videoPlaybackQuality;\n  };\n  return Flash;\n}(Tech);\n\n// Create setters and getters for attributes\n\nvar _readWrite = ['rtmpConnection', 'rtmpStream', 'preload', 'defaultPlaybackRate', 'playbackRate', 'autoplay', 'loop', 'controls', 'volume', 'muted', 'defaultMuted'];\nvar _readOnly = ['networkState', 'readyState', 'initialTime', 'startOffsetTime', 'paused', 'ended', 'videoWidth', 'videoHeight'];\nvar _api = Flash.prototype;\n\n/**\n * Create setters for the swf on the element\n *\n * @param {string} attr\n *        The name of the parameter\n *\n * @private\n */\nfunction _createSetter(attr) {\n  var attrUpper = attr.charAt(0).toUpperCase() + attr.slice(1);\n  _api['set' + attrUpper] = function (val) {\n    return this.el_.vjs_setProperty(attr, val);\n  };\n}\n\n/**\n * Create getters for the swf on the element\n *\n * @param {string} attr\n *        The name of the parameter\n *\n * @private\n */\nfunction _createGetter(attr) {\n  _api[attr] = function () {\n    return this.el_.vjs_getProperty(attr);\n  };\n}\n\n// Create getter and setters for all read/write attributes\nfor (var i = 0; i < _readWrite.length; i++) {\n  _createGetter(_readWrite[i]);\n  _createSetter(_readWrite[i]);\n}\n\n// Create getters for read-only attributes\nfor (var _i = 0; _i < _readOnly.length; _i++) {\n  _createGetter(_readOnly[_i]);\n}\n\n/** ------------------------------ Getters ------------------------------ **/\n/**\n * Get the value of `rtmpConnection` from the swf.\n *\n * @method Flash#rtmpConnection\n * @return {string}\n *         The current value of `rtmpConnection` on the swf.\n */\n\n/**\n * Get the value of `rtmpStream` from the swf.\n *\n * @method Flash#rtmpStream\n * @return {string}\n *         The current value of `rtmpStream` on the swf.\n */\n\n/**\n * Get the value of `preload` from the swf. `preload` indicates\n * what should download before the media is interacted with. It can have the following\n * values:\n * - none: nothing should be downloaded\n * - metadata: poster and the first few frames of the media may be downloaded to get\n *   media dimensions and other metadata\n * - auto: allow the media and metadata for the media to be downloaded before\n *    interaction\n *\n * @method Flash#preload\n * @return {string}\n *         The value of `preload` from the swf. Will be 'none', 'metadata',\n *         or 'auto'.\n */\n\n/**\n * Get the value of `defaultPlaybackRate` from the swf.\n *\n * @method Flash#defaultPlaybackRate\n * @return {number}\n *         The current value of `defaultPlaybackRate` on the swf.\n */\n\n/**\n * Get the value of `playbackRate` from the swf. `playbackRate` indicates\n * the rate at which the media is currently playing back. Examples:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Flash#playbackRate\n * @return {number}\n *         The value of `playbackRate` from the swf. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n */\n\n/**\n * Get the value of `autoplay` from the swf. `autoplay` indicates\n * that the media should start to play as soon as the page is ready.\n *\n * @method Flash#autoplay\n * @return {boolean}\n *         - The value of `autoplay` from the swf.\n *         - True indicates that the media ashould start as soon as the page loads.\n *         - False indicates that the media should not start as soon as the page loads.\n */\n\n/**\n * Get the value of `loop` from the swf. `loop` indicates\n * that the media should return to the start of the media and continue playing once\n * it reaches the end.\n *\n * @method Flash#loop\n * @return {boolean}\n *         - The value of `loop` from the swf.\n *         - True indicates that playback should seek back to start once\n *           the end of a media is reached.\n *         - False indicates that playback should not loop back to the start when the\n *           end of the media is reached.\n */\n\n/**\n * Get the value of `mediaGroup` from the swf.\n *\n * @method Flash#mediaGroup\n * @return {string}\n *         The current value of `mediaGroup` on the swf.\n */\n\n/**\n * Get the value of `controller` from the swf.\n *\n * @method Flash#controller\n * @return {string}\n *         The current value of `controller` on the swf.\n */\n\n/**\n * Get the value of `controls` from the swf. `controls` indicates\n * whether the native flash controls should be shown or hidden.\n *\n * @method Flash#controls\n * @return {boolean}\n *         - The value of `controls` from the swf.\n *         - True indicates that native controls should be showing.\n *         - False indicates that native controls should be hidden.\n */\n\n/**\n * Get the value of the `volume` from the swf. `volume` indicates the current\n * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and\n * so on.\n *\n * @method Flash#volume\n * @return {number}\n *         The volume percent as a decimal. Value will be between 0-1.\n */\n\n/**\n * Get the value of the `muted` from the swf. `muted` indicates the current\n * audio level should be silent.\n *\n * @method Flash#muted\n * @return {boolean}\n *         - True if the audio should be set to silent\n *         - False otherwise\n */\n\n/**\n * Get the value of `defaultMuted` from the swf. `defaultMuted` indicates\n * whether the media should start muted or not. Only changes the default state of the\n * media. `muted` and `defaultMuted` can have different values. `muted` indicates the\n * current state.\n *\n * @method Flash#defaultMuted\n * @return {boolean}\n *         - The value of `defaultMuted` from the swf.\n *         - True indicates that the media should start muted.\n *         - False indicates that the media should not start muted.\n */\n\n/**\n * Get the value of `networkState` from the swf. `networkState` indicates\n * the current network state. It returns an enumeration from the following list:\n * - 0: NETWORK_EMPTY\n * - 1: NEWORK_IDLE\n * - 2: NETWORK_LOADING\n * - 3: NETWORK_NO_SOURCE\n *\n * @method Flash#networkState\n * @return {number}\n *         The value of `networkState` from the swf. This will be a number\n *         from the list in the description.\n */\n\n/**\n * Get the value of `readyState` from the swf. `readyState` indicates\n * the current state of the media element. It returns an enumeration from the\n * following list:\n * - 0: HAVE_NOTHING\n * - 1: HAVE_METADATA\n * - 2: HAVE_CURRENT_DATA\n * - 3: HAVE_FUTURE_DATA\n * - 4: HAVE_ENOUGH_DATA\n *\n * @method Flash#readyState\n * @return {number}\n *         The value of `readyState` from the swf. This will be a number\n *         from the list in the description.\n */\n\n/**\n * Get the value of `readyState` from the swf. `readyState` indicates\n * the current state of the media element. It returns an enumeration from the\n * following list:\n * - 0: HAVE_NOTHING\n * - 1: HAVE_METADATA\n * - 2: HAVE_CURRENT_DATA\n * - 3: HAVE_FUTURE_DATA\n * - 4: HAVE_ENOUGH_DATA\n *\n * @method Flash#readyState\n * @return {number}\n *         The value of `readyState` from the swf. This will be a number\n *         from the list in the description.\n */\n\n/**\n * Get the value of `initialTime` from the swf.\n *\n * @method Flash#initialTime\n * @return {number}\n *         The `initialTime` proprety on the swf.\n */\n\n/**\n * Get the value of `startOffsetTime` from the swf.\n *\n * @method Flash#startOffsetTime\n * @return {number}\n *         The `startOffsetTime` proprety on the swf.\n */\n\n/**\n * Get the value of `paused` from the swf. `paused` indicates whether the swf\n * is current paused or not.\n *\n * @method Flash#paused\n * @return {boolean}\n *         The value of `paused` from the swf.\n */\n\n/**\n * Get the value of `ended` from the swf. `ended` indicates whether\n * the media has reached the end or not.\n *\n * @method Flash#ended\n * @return {boolean}\n *         - True indicates that the media has ended.\n *         - False indicates that the media has not ended.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}\n */\n\n/**\n * Get the value of `videoWidth` from the swf. `videoWidth` indicates\n * the current width of the media in css pixels.\n *\n * @method Flash#videoWidth\n * @return {number}\n *         The value of `videoWidth` from the swf. This will be a number\n *         in css pixels.\n */\n\n/**\n * Get the value of `videoHeight` from the swf. `videoHeigth` indicates\n * the current height of the media in css pixels.\n *\n * @method Flassh.prototype.videoHeight\n * @return {number}\n *         The value of `videoHeight` from the swf. This will be a number\n *         in css pixels.\n */\n/** ------------------------------ Setters ------------------------------ **/\n\n/**\n * Set the value of `rtmpConnection` on the swf.\n *\n * @method Flash#setRtmpConnection\n * @param {string} rtmpConnection\n *        New value to set the `rtmpConnection` property to.\n */\n\n/**\n * Set the value of `rtmpStream` on the swf.\n *\n * @method Flash#setRtmpStream\n * @param {string} rtmpStream\n *        New value to set the `rtmpStream` property to.\n */\n\n/**\n * Set the value of `preload` on the swf. `preload` indicates\n * what should download before the media is interacted with. It can have the following\n * values:\n * - none: nothing should be downloaded\n * - metadata: poster and the first few frames of the media may be downloaded to get\n *   media dimensions and other metadata\n * - auto: allow the media and metadata for the media to be downloaded before\n *    interaction\n *\n * @method Flash#setPreload\n * @param {string} preload\n *        The value of `preload` to set on the swf. Should be 'none', 'metadata',\n *        or 'auto'.\n */\n\n/**\n * Set the value of `defaultPlaybackRate` on the swf.\n *\n * @method Flash#setDefaultPlaybackRate\n * @param {number} defaultPlaybackRate\n *        New value to set the `defaultPlaybackRate` property to.\n */\n\n/**\n * Set the value of `playbackRate` on the swf. `playbackRate` indicates\n * the rate at which the media is currently playing back. Examples:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Flash#setPlaybackRate\n * @param {number} playbackRate\n *        New value of `playbackRate` on the swf. A number indicating\n *        the current playback speed of the media, where 1 is normal speed.\n */\n\n/**\n * Set the value of `autoplay` on the swf. `autoplay` indicates\n * that the media should start to play as soon as the page is ready.\n *\n * @method Flash#setAutoplay\n * @param {boolean} autoplay\n *        - The value of `autoplay` from the swf.\n *        - True indicates that the media ashould start as soon as the page loads.\n *        - False indicates that the media should not start as soon as the page loads.\n */\n\n/**\n * Set the value of `loop` on the swf. `loop` indicates\n * that the media should return to the start of the media and continue playing once\n * it reaches the end.\n *\n * @method Flash#setLoop\n * @param {boolean} loop\n *        - True indicates that playback should seek back to start once\n *          the end of a media is reached.\n *        - False indicates that playback should not loop back to the start when the\n *          end of the media is reached.\n */\n\n/**\n * Set the value of `mediaGroup` on the swf.\n *\n * @method Flash#setMediaGroup\n * @param {string} mediaGroup\n *        New value of `mediaGroup` to set on the swf.\n */\n\n/**\n * Set the value of `controller` on the swf.\n *\n * @method Flash#setController\n * @param {string} controller\n *        New value the current value of `controller` on the swf.\n */\n\n/**\n * Get the value of `controls` from the swf. `controls` indicates\n * whether the native flash controls should be shown or hidden.\n *\n * @method Flash#controls\n * @return {boolean}\n *         - The value of `controls` from the swf.\n *         - True indicates that native controls should be showing.\n *         - False indicates that native controls should be hidden.\n */\n\n/**\n * Set the value of the `volume` on the swf. `volume` indicates the current\n * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and\n * so on.\n *\n * @method Flash#setVolume\n * @param {number} percentAsDecimal\n *         The volume percent as a decimal. Value will be between 0-1.\n */\n\n/**\n * Set the value of the `muted` on the swf. `muted` indicates that the current\n * audio level should be silent.\n *\n * @method Flash#setMuted\n * @param {boolean} muted\n *         - True if the audio should be set to silent\n *         - False otherwise\n */\n\n/**\n * Set the value of `defaultMuted` on the swf. `defaultMuted` indicates\n * whether the media should start muted or not. Only changes the default state of the\n * media. `muted` and `defaultMuted` can have different values. `muted` indicates the\n * current state.\n *\n * @method Flash#setDefaultMuted\n * @param {boolean} defaultMuted\n *         - True indicates that the media should start muted.\n *         - False indicates that the media should not start muted.\n */\n\n/* Flash Support Testing -------------------------------------------------------- */\n\n/**\n * Check if the Flash tech is currently supported.\n *\n * @return {boolean}\n *          - True for Chrome and Safari Desktop and Microsoft Edge and if flash tech is supported\n *          - False otherwise\n */\nFlash.isSupported = function () {\n  // for Chrome Desktop and Safari Desktop\n  if (videojs.browser.IS_CHROME && (!videojs.browser.IS_ANDROID || !videojs.browser.IS_IOS) || videojs.browser.IS_SAFARI && !videojs.browser.IS_IOS || videojs.browser.IS_EDGE) {\n    return true;\n  }\n  // for other browsers\n  return Flash.version()[0] >= 10;\n};\n\n// Add Source Handler pattern functions to this tech\nTech.withSourceHandlers(Flash);\n\n/*\n * Native source handler for flash,  simply passes the source to the swf element.\n *\n * @property {Tech~SourceObject} source\n *           The source object\n *\n * @property {Flash} tech\n *           The instance of the Flash tech\n */\nFlash.nativeSourceHandler = {};\n\n/**\n * Check if the Flash can play the given mime type.\n *\n * @param {string} type\n *        The mimetype to check\n *\n * @return {string}\n *         'maybe', or '' (empty string)\n */\nFlash.nativeSourceHandler.canPlayType = function (type) {\n  if (type in Flash.formats) {\n    return 'maybe';\n  }\n  return '';\n};\n\n/**\n * Check if the media element can handle a source natively.\n *\n * @param {Tech~SourceObject} source\n *         The source object\n *\n * @param {Object} [options]\n *         Options to be passed to the tech.\n *\n * @return {string}\n *         'maybe', or '' (empty string).\n */\nFlash.nativeSourceHandler.canHandleSource = function (source, options) {\n  var type = void 0;\n\n  /**\n   * Guess the mime type of a file if it does not have one\n   *\n   * @param {Tech~SourceObject} src\n   *        The source object to guess the mime type for\n   *\n   * @return {string}\n   *         The mime type that was guessed\n   */\n  function guessMimeType(src) {\n    var ext = Url.getFileExtension(src);\n    if (ext) {\n      return 'video/' + ext;\n    }\n    return '';\n  }\n  if (!source.type) {\n    type = guessMimeType(source.src);\n  } else {\n    // Strip code information from the type because we don't get that specific\n    type = source.type.replace(/;.*/, '').toLowerCase();\n  }\n  return Flash.nativeSourceHandler.canPlayType(type);\n};\n\n/**\n * Pass the source to the swf.\n *\n * @param {Tech~SourceObject} source\n *        The source object\n *\n * @param {Flash} tech\n *        The instance of the Flash tech\n *\n * @param {Object} [options]\n *        The options to pass to the source\n */\nFlash.nativeSourceHandler.handleSource = function (source, tech, options) {\n  tech.setSrc(source.src);\n};\n\n/**\n * noop for native source handler dispose, as cleanup will happen automatically.\n */\nFlash.nativeSourceHandler.dispose = function () {};\n\n// Register the native source handler\nFlash.registerSourceHandler(Flash.nativeSourceHandler);\n\n/**\n * Flash supported mime types.\n *\n * @constant {Object}\n */\nFlash.formats = {\n  'video/flv': 'FLV',\n  'video/x-flv': 'FLV',\n  'video/mp4': 'MP4',\n  'video/m4v': 'MP4'\n};\n\n/**\n * Called when the the swf is \"ready\", and makes sure that the swf is really\n * ready using {@link Flash#checkReady}\n *\n * @param {Object} currSwf\n *        The current swf object\n */\nFlash.onReady = function (currSwf) {\n  var el = Dom.$('#' + currSwf);\n  var tech = el && el.tech;\n\n  // if there is no el then the tech has been disposed\n  // and the tech element was removed from the player div\n  if (tech && tech.el()) {\n    // check that the flash object is really ready\n    Flash.checkReady(tech);\n  }\n};\n\n/**\n * The SWF isn't always ready when it says it is. Sometimes the API functions still\n * need to be added to the object. If it's not ready, we set a timeout to check again\n * shortly.\n *\n * @param {Flash} tech\n *        The instance of the flash tech to check.\n */\nFlash.checkReady = function (tech) {\n  // stop worrying if the tech has been disposed\n  if (!tech.el()) {\n    return;\n  }\n\n  // check if API property exists\n  if (tech.el().vjs_getProperty) {\n    // tell tech it's ready\n    tech.triggerReady();\n  } else {\n    // wait longer\n    this.setTimeout(function () {\n      Flash.checkReady(tech);\n    }, 50);\n  }\n};\n\n/**\n * Trigger events from the swf on the Flash Tech.\n *\n * @param {number} swfID\n *        The id of the swf that had the event\n *\n * @param {string} eventName\n *        The name of the event to trigger\n */\nFlash.onEvent = function (swfID, eventName) {\n  var tech = Dom.$('#' + swfID).tech;\n  var args = Array.prototype.slice.call(arguments, 2);\n\n  // dispatch Flash events asynchronously for two reasons:\n  // - Flash swallows any exceptions generated by javascript it\n  //   invokes\n  // - Flash is suspended until the javascript returns which may cause\n  //   playback performance issues\n  tech.setTimeout(function () {\n    tech.trigger(eventName, args);\n  }, 1);\n};\n\n/**\n * Log errors from the swf on the Flash tech.\n *\n * @param {number} swfID\n *        The id of the swf that had an error.\n *\n * @param {string} err\n *        The error to set on the Flash Tech.\n *\n * @return {MediaError|undefined}\n *          - Returns a MediaError when err is 'srcnotfound'\n *          - Returns undefined otherwise.\n */\nFlash.onError = function (swfID, err) {\n  var tech = Dom.$('#' + swfID).tech;\n\n  // trigger MEDIA_ERR_SRC_NOT_SUPPORTED\n  if (err === 'srcnotfound') {\n    return tech.error(4);\n  }\n\n  // trigger a custom error\n  if (typeof err === 'string') {\n    tech.error('FLASH: ' + err);\n  } else {\n    err.origin = 'flash';\n    tech.error(err);\n  }\n};\n\n/**\n * Get the current version of Flash that is in use on the page.\n *\n * @return {Array}\n *          an array of versions that are available.\n */\nFlash.version = function () {\n  var version$$1 = '0,0,0';\n\n  // IE\n  try {\n    version$$1 = new window.ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\\D+/g, ',').match(/^,?(.+),?$/)[1];\n\n    // other browsers\n  } catch (e) {\n    try {\n      if (navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin) {\n        version$$1 = (navigator.plugins['Shockwave Flash 2.0'] || navigator.plugins['Shockwave Flash']).description.replace(/\\D+/g, ',').match(/^,?(.+),?$/)[1];\n      }\n    } catch (err) {\n      // satisfy linter\n    }\n  }\n  return version$$1.split(',');\n};\n\n/**\n * Only use for non-iframe embeds.\n *\n * @param {Object} swf\n *        The videojs-swf object.\n *\n * @param {Object} flashVars\n *        Names and values to use as flash option variables.\n *\n * @param {Object} params\n *        Style parameters to set on the object.\n *\n * @param {Object} attributes\n *        Attributes to set on the element.\n *\n * @return {Element}\n *          The embeded Flash DOM element.\n */\nFlash.embed = function (swf, flashVars, params, attributes) {\n  var code = Flash.getEmbedCode(swf, flashVars, params, attributes);\n\n  // Get element by embedding code and retrieving created element\n  var obj = Dom.createEl('div', {\n    innerHTML: code\n  }).childNodes[0];\n  return obj;\n};\n\n/**\n * Only use for non-iframe embeds.\n *\n * @param {Object} swf\n *        The videojs-swf object.\n *\n * @param {Object} flashVars\n *        Names and values to use as flash option variables.\n *\n * @param {Object} params\n *        Style parameters to set on the object.\n *\n * @param {Object} attributes\n *        Attributes to set on the element.\n *\n * @return {Element}\n *          The embeded Flash DOM element.\n */\nFlash.getEmbedCode = function (swf, flashVars, params, attributes) {\n  var objTag = '<object type=\"application/x-shockwave-flash\" ';\n  var flashVarsString = '';\n  var paramsString = '';\n  var attrsString = '';\n\n  // Convert flash vars to string\n  if (flashVars) {\n    Object.getOwnPropertyNames(flashVars).forEach(function (key) {\n      flashVarsString += key + '=' + flashVars[key] + '&amp;';\n    });\n  }\n\n  // Add swf, flashVars, and other default params\n  params = mergeOptions({\n    movie: swf,\n    flashvars: flashVarsString,\n    // Required to talk to swf\n    allowScriptAccess: 'always',\n    // All should be default, but having security issues.\n    allowNetworking: 'all'\n  }, params);\n\n  // Create param tags string\n  Object.getOwnPropertyNames(params).forEach(function (key) {\n    paramsString += '<param name=\"' + key + '\" value=\"' + params[key] + '\" />';\n  });\n  attributes = mergeOptions({\n    // Add swf to attributes (need both for IE and Others to work)\n    data: swf,\n    // Default to 100% width/height\n    width: '100%',\n    height: '100%'\n  }, attributes);\n\n  // Create Attributes string\n  Object.getOwnPropertyNames(attributes).forEach(function (key) {\n    attrsString += key + '=\"' + attributes[key] + '\" ';\n  });\n  return '' + objTag + attrsString + '>' + paramsString + '</object>';\n};\n\n// Run Flash through the RTMP decorator\nFlashRtmpDecorator(Flash);\nif (Tech.getTech('Flash')) {\n  videojs.log.warn('Not using videojs-flash as it appears to already be registered');\n  videojs.log.warn('videojs-flash should only be used with video.js@6 and above');\n} else {\n  videojs.registerTech('Flash', Flash);\n}\nFlash.VERSION = version$1;\nexport default Flash;","map":{"version":3,"names":["videojs","version","window","version$1","FlashRtmpDecorator","Flash","streamingFormats","streamFromParts","connection","stream","streamToParts","src","parts","connEnd","search","streamBegin","lastIndexOf","length","substring","isStreamingType","srcType","RTMP_RE","isStreamingSrc","test","rtmpSourceHandler","canPlayType","type","canHandleSource","source","options","can","handleSource","tech","srcParts","setRtmpConnection","setRtmpStream","registerSourceHandler","classCallCheck","instance","Constructor","TypeError","inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","possibleConstructorReturn","self","call","ReferenceError","Tech","getComponent","Dom","dom","Url","url","createTimeRange","mergeOptions","navigator","_Tech","ready","_this","setSource","startTime","load","play","currentTime","onReady","onEvent","onError","on","lastSeekTarget_","undefined","createEl","options_","swf","objId","techId","flashVars","readyFunction","eventProxyFunction","errorEventProxyFunction","autoplay","preload","loop","muted","params","wmode","bgcolor","attributes","id","name","el_","embed","ended","setCurrentTime","vjs_play","pause","vjs_pause","_src","currentSrc","setSrc","_this2","getAbsoluteURL","vjs_src","setTimeout","seeking","time","seekable","start","end","trigger","vjs_setProperty","vjs_getProperty","currentSource_","duration","readyState","NaN","Infinity","vjs_load","poster","setPoster","buffered","ranges","supportsFullScreen","enterFullScreen","getVideoPlaybackQuality","videoPlaybackQuality","performance","now","creationTime","timing","navigationStart","Date","_readWrite","_readOnly","_api","_createSetter","attr","attrUpper","charAt","toUpperCase","slice","val","_createGetter","i","_i","isSupported","browser","IS_CHROME","IS_ANDROID","IS_IOS","IS_SAFARI","IS_EDGE","withSourceHandlers","nativeSourceHandler","formats","guessMimeType","ext","getFileExtension","replace","toLowerCase","dispose","currSwf","el","$","checkReady","triggerReady","swfID","eventName","args","Array","arguments","err","error","origin","version$$1","ActiveXObject","GetVariable","match","e","mimeTypes","enabledPlugin","plugins","description","split","code","getEmbedCode","obj","innerHTML","childNodes","objTag","flashVarsString","paramsString","attrsString","getOwnPropertyNames","forEach","key","movie","flashvars","allowScriptAccess","allowNetworking","data","width","height","getTech","log","warn","registerTech","VERSION"],"sources":["/Users/elmo/GitHub/meetings_vue3/node_modules/videojs-flash/dist/videojs-flash.es.js"],"sourcesContent":["import videojs from 'video.js';\nimport { version } from 'videojs-swf/package.json';\nimport window from 'global/window';\n\nvar version$1 = \"2.2.1\";\n\n/**\n * @file flash-rtmp.js\n * @module flash-rtmp\n */\n\n/**\n * Add RTMP properties to the {@link Flash} Tech.\n *\n * @param {Flash} Flash\n *        The flash tech class.\n *\n * @mixin FlashRtmpDecorator\n *\n * @return {Flash}\n *         The flash tech with RTMP properties added.\n */\nfunction FlashRtmpDecorator(Flash) {\n  Flash.streamingFormats = {\n    'rtmp/mp4': 'MP4',\n    'rtmp/flv': 'FLV'\n  };\n\n  /**\n   * Join connection and stream with an ampersand.\n   *\n   * @param {string} connection\n   *        The connection string.\n   *\n   * @param {string} stream\n   *        The stream string.\n   *\n   * @return {string}\n   *         The connection and stream joined with an `&` character\n   */\n  Flash.streamFromParts = function (connection, stream) {\n    return connection + '&' + stream;\n  };\n\n  /**\n   * The flash parts object that contains connection and stream info.\n   *\n   * @typedef {Object} Flash~PartsObject\n   *\n   * @property {string} connection\n   *           The connection string of a source, defaults to an empty string.\n   *\n   * @property {string} stream\n   *           The stream string of the source, defaults to an empty string.\n   */\n\n  /**\n   * Convert a source url into a stream and connection parts.\n   *\n   * @param {string} src\n   *        the source url\n   *\n   * @return {Flash~PartsObject}\n   *         The parts object that contains a connection and a stream\n   */\n  Flash.streamToParts = function (src) {\n    var parts = {\n      connection: '',\n      stream: ''\n    };\n\n    if (!src) {\n      return parts;\n    }\n\n    // Look for the normal URL separator we expect, '&'.\n    // If found, we split the URL into two pieces around the\n    // first '&'.\n    var connEnd = src.search(/&(?![\\w-]+=)/);\n    var streamBegin = void 0;\n\n    if (connEnd !== -1) {\n      streamBegin = connEnd + 1;\n    } else {\n      // If there's not a '&', we use the last '/' as the delimiter.\n      connEnd = streamBegin = src.lastIndexOf('/') + 1;\n      if (connEnd === 0) {\n        // really, there's not a '/'?\n        connEnd = streamBegin = src.length;\n      }\n    }\n\n    parts.connection = src.substring(0, connEnd);\n    parts.stream = src.substring(streamBegin, src.length);\n\n    return parts;\n  };\n\n  /**\n   * Check if the source type is a streaming type.\n   *\n   * @param {string} srcType\n   *        The mime type to check.\n   *\n   * @return {boolean}\n   *          - True if the source type is a streaming type.\n   *          - False if the source type is not a streaming type.\n   */\n  Flash.isStreamingType = function (srcType) {\n    return srcType in Flash.streamingFormats;\n  };\n\n  // RTMP has four variations, any string starting\n  // with one of these protocols should be valid\n\n  /**\n   * Regular expression used to check if the source is an rtmp source.\n   *\n   * @property {RegExp} Flash.RTMP_RE\n   */\n  Flash.RTMP_RE = /^rtmp[set]?:\\/\\//i;\n\n  /**\n   * Check if the source itself is a streaming type.\n   *\n   * @param {string} src\n   *        The url to the source.\n   *\n   * @return {boolean}\n   *          - True if the source url indicates that the source is streaming.\n   *          - False if the shource url indicates that the source url is not streaming.\n   */\n  Flash.isStreamingSrc = function (src) {\n    return Flash.RTMP_RE.test(src);\n  };\n\n  /**\n   * A source handler for RTMP urls\n   * @type {Object}\n   */\n  Flash.rtmpSourceHandler = {};\n\n  /**\n   * Check if Flash can play the given mime type.\n   *\n   * @param {string} type\n   *        The mime type to check\n   *\n   * @return {string}\n   *         'maybe', or '' (empty string)\n   */\n  Flash.rtmpSourceHandler.canPlayType = function (type) {\n    if (Flash.isStreamingType(type)) {\n      return 'maybe';\n    }\n\n    return '';\n  };\n\n  /**\n   * Check if Flash can handle the source natively\n   *\n   * @param {Object} source\n   *        The source object\n   *\n   * @param {Object} [options]\n   *        The options passed to the tech\n   *\n   * @return {string}\n   *         'maybe', or '' (empty string)\n   */\n  Flash.rtmpSourceHandler.canHandleSource = function (source, options) {\n    var can = Flash.rtmpSourceHandler.canPlayType(source.type);\n\n    if (can) {\n      return can;\n    }\n\n    if (Flash.isStreamingSrc(source.src)) {\n      return 'maybe';\n    }\n\n    return '';\n  };\n\n  /**\n   * Pass the source to the flash object.\n   *\n   * @param {Object} source\n   *        The source object\n   *\n   * @param {Flash} tech\n   *        The instance of the Flash tech\n   *\n   * @param {Object} [options]\n   *        The options to pass to the source\n   */\n  Flash.rtmpSourceHandler.handleSource = function (source, tech, options) {\n    var srcParts = Flash.streamToParts(source.src);\n\n    tech.setRtmpConnection(srcParts.connection);\n    tech.setRtmpStream(srcParts.stream);\n  };\n\n  // Register the native source handler\n  Flash.registerSourceHandler(Flash.rtmpSourceHandler);\n\n  return Flash;\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n/**\n * @file flash.js\n * VideoJS-SWF - Custom Flash Player with HTML5-ish API\n * https://github.com/zencoder/video-js-swf\n * Not using setupTriggers. Using global onEvent func to distribute events\n */\n\nvar Tech = videojs.getComponent('Tech');\nvar Dom = videojs.dom;\nvar Url = videojs.url;\nvar createTimeRange = videojs.createTimeRange;\nvar mergeOptions = videojs.mergeOptions;\n\nvar navigator = window && window.navigator || {};\n\n/**\n * Flash Media Controller - Wrapper for Flash Media API\n *\n * @mixes FlashRtmpDecorator\n * @mixes Tech~SouceHandlerAdditions\n * @extends Tech\n */\n\nvar Flash = function (_Tech) {\n  inherits(Flash, _Tech);\n\n  /**\n  * Create an instance of this Tech.\n  *\n  * @param {Object} [options]\n  *        The key/value store of player options.\n  *\n  * @param {Component~ReadyCallback} ready\n  *        Callback function to call when the `Flash` Tech is ready.\n  */\n  function Flash(options, ready) {\n    classCallCheck(this, Flash);\n\n    // Set the source when ready\n    var _this = possibleConstructorReturn(this, _Tech.call(this, options, ready));\n\n    if (options.source) {\n      _this.ready(function () {\n        this.setSource(options.source);\n      }, true);\n    }\n\n    // Having issues with Flash reloading on certain page actions\n    // (hide/resize/fullscreen) in certain browsers\n    // This allows resetting the playhead when we catch the reload\n    if (options.startTime) {\n      _this.ready(function () {\n        this.load();\n        this.play();\n        this.currentTime(options.startTime);\n      }, true);\n    }\n\n    // Add global window functions that the swf expects\n    // A 4.x workflow we weren't able to solve for in 5.0\n    // because of the need to hard code these functions\n    // into the swf for security reasons\n    window.videojs = window.videojs || {};\n    window.videojs.Flash = window.videojs.Flash || {};\n    window.videojs.Flash.onReady = Flash.onReady;\n    window.videojs.Flash.onEvent = Flash.onEvent;\n    window.videojs.Flash.onError = Flash.onError;\n\n    _this.on('seeked', function () {\n      this.lastSeekTarget_ = undefined;\n    });\n\n    return _this;\n  }\n\n  /**\n   * Create the `Flash` Tech's DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  Flash.prototype.createEl = function createEl() {\n    var options = this.options_;\n\n    // If video.js is hosted locally you should also set the location\n    // for the hosted swf, which should be relative to the page (not video.js)\n    // Otherwise this adds a CDN url.\n    // The CDN also auto-adds a swf URL for that specific version.\n    if (!options.swf) {\n      options.swf = 'https://vjs.zencdn.net/swf/' + version + '/video-js.swf';\n    }\n\n    // Generate ID for swf object\n    var objId = options.techId;\n\n    // Merge default flashvars with ones passed in to init\n    var flashVars = mergeOptions({\n\n      // SWF Callback Functions\n      readyFunction: 'videojs.Flash.onReady',\n      eventProxyFunction: 'videojs.Flash.onEvent',\n      errorEventProxyFunction: 'videojs.Flash.onError',\n\n      // Player Settings\n      autoplay: options.autoplay,\n      preload: options.preload,\n      loop: options.loop,\n      muted: options.muted\n\n    }, options.flashVars);\n\n    // Merge default parames with ones passed in\n    var params = mergeOptions({\n      // Opaque is needed to overlay controls, but can affect playback performance\n      wmode: 'opaque',\n      // Using bgcolor prevents a white flash when the object is loading\n      bgcolor: '#000000'\n    }, options.params);\n\n    // Merge default attributes with ones passed in\n    var attributes = mergeOptions({\n      // Both ID and Name needed or swf to identify itself\n      id: objId,\n      name: objId,\n      'class': 'vjs-tech'\n    }, options.attributes);\n\n    this.el_ = Flash.embed(options.swf, flashVars, params, attributes);\n    this.el_.tech = this;\n\n    return this.el_;\n  };\n\n  /**\n   * Called by {@link Player#play} to play using the `Flash` `Tech`.\n   */\n\n\n  Flash.prototype.play = function play() {\n    if (this.ended()) {\n      this.setCurrentTime(0);\n    }\n    this.el_.vjs_play();\n  };\n\n  /**\n   * Called by {@link Player#pause} to pause using the `Flash` `Tech`.\n   */\n\n\n  Flash.prototype.pause = function pause() {\n    this.el_.vjs_pause();\n  };\n\n  /**\n   * A getter/setter for the `Flash` Tech's source object.\n   * > Note: Please use {@link Flash#setSource}\n   *\n   * @param {Tech~SourceObject} [src]\n   *        The source object you want to set on the `Flash` techs.\n   *\n   * @return {Tech~SourceObject|undefined}\n   *         - The current source object when a source is not passed in.\n   *         - undefined when setting\n   *\n   * @deprecated Since version 5.\n   */\n\n\n  Flash.prototype.src = function src(_src) {\n    if (_src === undefined) {\n      return this.currentSrc();\n    }\n\n    // Setting src through `src` not `setSrc` will be deprecated\n    return this.setSrc(_src);\n  };\n\n  /**\n   * A getter/setter for the `Flash` Tech's source object.\n   *\n   * @param {Tech~SourceObject} [src]\n   *        The source object you want to set on the `Flash` techs.\n   */\n\n\n  Flash.prototype.setSrc = function setSrc(src) {\n    var _this2 = this;\n\n    // Make sure source URL is absolute.\n    src = Url.getAbsoluteURL(src);\n    this.el_.vjs_src(src);\n\n    // Currently the SWF doesn't autoplay if you load a source later.\n    // e.g. Load player w/ no source, wait 2s, set src.\n    if (this.autoplay()) {\n      this.setTimeout(function () {\n        return _this2.play();\n      }, 0);\n    }\n  };\n\n  /**\n   * Indicates whether the media is currently seeking to a new position or not.\n   *\n   * @return {boolean}\n   *         - True if seeking to a new position\n   *         - False otherwise\n   */\n\n\n  Flash.prototype.seeking = function seeking() {\n    return this.lastSeekTarget_ !== undefined;\n  };\n\n  /**\n   * Returns the current time in seconds that the media is at in playback.\n   *\n   * @param {number} time\n   *        Current playtime of the media in seconds.\n   */\n\n\n  Flash.prototype.setCurrentTime = function setCurrentTime(time) {\n    var seekable = this.seekable();\n\n    if (seekable.length) {\n      // clamp to the current seekable range\n      time = time > seekable.start(0) ? time : seekable.start(0);\n      time = time < seekable.end(seekable.length - 1) ? time : seekable.end(seekable.length - 1);\n\n      this.lastSeekTarget_ = time;\n      this.trigger('seeking');\n      this.el_.vjs_setProperty('currentTime', time);\n      _Tech.prototype.setCurrentTime.call(this);\n    }\n  };\n\n  /**\n   * Get the current playback time in seconds\n   *\n   * @return {number}\n   *         The current time of playback in seconds.\n   */\n\n\n  Flash.prototype.currentTime = function currentTime() {\n    // when seeking make the reported time keep up with the requested time\n    // by reading the time we're seeking to\n    if (this.seeking()) {\n      return this.lastSeekTarget_ || 0;\n    }\n    return this.el_.vjs_getProperty('currentTime');\n  };\n\n  /**\n   * Get the current source\n   *\n   * @method currentSrc\n   * @return {Tech~SourceObject}\n   *         The current source\n   */\n\n\n  Flash.prototype.currentSrc = function currentSrc() {\n    if (this.currentSource_) {\n      return this.currentSource_.src;\n    }\n    return this.el_.vjs_getProperty('currentSrc');\n  };\n\n  /**\n   * Get the total duration of the current media.\n   *\n   * @return {number}\n   8          The total duration of the current media.\n   */\n\n\n  Flash.prototype.duration = function duration() {\n    if (this.readyState() === 0) {\n      return NaN;\n    }\n    var duration = this.el_.vjs_getProperty('duration');\n\n    return duration >= 0 ? duration : Infinity;\n  };\n\n  /**\n   * Load media into Tech.\n   */\n\n\n  Flash.prototype.load = function load() {\n    this.el_.vjs_load();\n  };\n\n  /**\n   * Get the poster image that was set on the tech.\n   */\n\n\n  Flash.prototype.poster = function poster() {\n    this.el_.vjs_getProperty('poster');\n  };\n\n  /**\n   * Poster images are not handled by the Flash tech so make this is a no-op.\n   */\n\n\n  Flash.prototype.setPoster = function setPoster() {};\n\n  /**\n   * Determine the time ranges that can be seeked to in the media.\n   *\n   * @return {TimeRange}\n   *         Returns the time ranges that can be seeked to.\n   */\n\n\n  Flash.prototype.seekable = function seekable() {\n    var duration = this.duration();\n\n    if (duration === 0) {\n      return createTimeRange();\n    }\n    return createTimeRange(0, duration);\n  };\n\n  /**\n   * Get and create a `TimeRange` object for buffering.\n   *\n   * @return {TimeRange}\n   *         The time range object that was created.\n   */\n\n\n  Flash.prototype.buffered = function buffered() {\n    var ranges = this.el_.vjs_getProperty('buffered');\n\n    if (ranges.length === 0) {\n      return createTimeRange();\n    }\n    return createTimeRange(ranges[0][0], ranges[0][1]);\n  };\n\n  /**\n   * Get fullscreen support -\n   *\n   * Flash does not allow fullscreen through javascript\n   * so this always returns false.\n   *\n   * @return {boolean}\n   *         The Flash tech does not support fullscreen, so it will always return false.\n   */\n\n\n  Flash.prototype.supportsFullScreen = function supportsFullScreen() {\n    // Flash does not allow fullscreen through javascript\n    return false;\n  };\n\n  /**\n   * Flash does not allow fullscreen through javascript\n   * so this always returns false.\n   *\n   * @return {boolean}\n   *         The Flash tech does not support fullscreen, so it will always return false.\n   */\n\n\n  Flash.prototype.enterFullScreen = function enterFullScreen() {\n    return false;\n  };\n\n  /**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object}\n   *         An object with supported media playback quality metrics\n   */\n\n\n  Flash.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {\n    var videoPlaybackQuality = this.el_.vjs_getProperty('getVideoPlaybackQuality');\n\n    if (window.performance && typeof window.performance.now === 'function') {\n      videoPlaybackQuality.creationTime = window.performance.now();\n    } else if (window.performance && window.performance.timing && typeof window.performance.timing.navigationStart === 'number') {\n      videoPlaybackQuality.creationTime = window.Date.now() - window.performance.timing.navigationStart;\n    }\n\n    return videoPlaybackQuality;\n  };\n\n  return Flash;\n}(Tech);\n\n// Create setters and getters for attributes\n\n\nvar _readWrite = ['rtmpConnection', 'rtmpStream', 'preload', 'defaultPlaybackRate', 'playbackRate', 'autoplay', 'loop', 'controls', 'volume', 'muted', 'defaultMuted'];\nvar _readOnly = ['networkState', 'readyState', 'initialTime', 'startOffsetTime', 'paused', 'ended', 'videoWidth', 'videoHeight'];\nvar _api = Flash.prototype;\n\n/**\n * Create setters for the swf on the element\n *\n * @param {string} attr\n *        The name of the parameter\n *\n * @private\n */\nfunction _createSetter(attr) {\n  var attrUpper = attr.charAt(0).toUpperCase() + attr.slice(1);\n\n  _api['set' + attrUpper] = function (val) {\n    return this.el_.vjs_setProperty(attr, val);\n  };\n}\n\n/**\n * Create getters for the swf on the element\n *\n * @param {string} attr\n *        The name of the parameter\n *\n * @private\n */\nfunction _createGetter(attr) {\n  _api[attr] = function () {\n    return this.el_.vjs_getProperty(attr);\n  };\n}\n\n// Create getter and setters for all read/write attributes\nfor (var i = 0; i < _readWrite.length; i++) {\n  _createGetter(_readWrite[i]);\n  _createSetter(_readWrite[i]);\n}\n\n// Create getters for read-only attributes\nfor (var _i = 0; _i < _readOnly.length; _i++) {\n  _createGetter(_readOnly[_i]);\n}\n\n/** ------------------------------ Getters ------------------------------ **/\n/**\n * Get the value of `rtmpConnection` from the swf.\n *\n * @method Flash#rtmpConnection\n * @return {string}\n *         The current value of `rtmpConnection` on the swf.\n */\n\n/**\n * Get the value of `rtmpStream` from the swf.\n *\n * @method Flash#rtmpStream\n * @return {string}\n *         The current value of `rtmpStream` on the swf.\n */\n\n/**\n * Get the value of `preload` from the swf. `preload` indicates\n * what should download before the media is interacted with. It can have the following\n * values:\n * - none: nothing should be downloaded\n * - metadata: poster and the first few frames of the media may be downloaded to get\n *   media dimensions and other metadata\n * - auto: allow the media and metadata for the media to be downloaded before\n *    interaction\n *\n * @method Flash#preload\n * @return {string}\n *         The value of `preload` from the swf. Will be 'none', 'metadata',\n *         or 'auto'.\n */\n\n/**\n * Get the value of `defaultPlaybackRate` from the swf.\n *\n * @method Flash#defaultPlaybackRate\n * @return {number}\n *         The current value of `defaultPlaybackRate` on the swf.\n */\n\n/**\n * Get the value of `playbackRate` from the swf. `playbackRate` indicates\n * the rate at which the media is currently playing back. Examples:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Flash#playbackRate\n * @return {number}\n *         The value of `playbackRate` from the swf. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n */\n\n/**\n * Get the value of `autoplay` from the swf. `autoplay` indicates\n * that the media should start to play as soon as the page is ready.\n *\n * @method Flash#autoplay\n * @return {boolean}\n *         - The value of `autoplay` from the swf.\n *         - True indicates that the media ashould start as soon as the page loads.\n *         - False indicates that the media should not start as soon as the page loads.\n */\n\n/**\n * Get the value of `loop` from the swf. `loop` indicates\n * that the media should return to the start of the media and continue playing once\n * it reaches the end.\n *\n * @method Flash#loop\n * @return {boolean}\n *         - The value of `loop` from the swf.\n *         - True indicates that playback should seek back to start once\n *           the end of a media is reached.\n *         - False indicates that playback should not loop back to the start when the\n *           end of the media is reached.\n */\n\n/**\n * Get the value of `mediaGroup` from the swf.\n *\n * @method Flash#mediaGroup\n * @return {string}\n *         The current value of `mediaGroup` on the swf.\n */\n\n/**\n * Get the value of `controller` from the swf.\n *\n * @method Flash#controller\n * @return {string}\n *         The current value of `controller` on the swf.\n */\n\n/**\n * Get the value of `controls` from the swf. `controls` indicates\n * whether the native flash controls should be shown or hidden.\n *\n * @method Flash#controls\n * @return {boolean}\n *         - The value of `controls` from the swf.\n *         - True indicates that native controls should be showing.\n *         - False indicates that native controls should be hidden.\n */\n\n/**\n * Get the value of the `volume` from the swf. `volume` indicates the current\n * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and\n * so on.\n *\n * @method Flash#volume\n * @return {number}\n *         The volume percent as a decimal. Value will be between 0-1.\n */\n\n/**\n * Get the value of the `muted` from the swf. `muted` indicates the current\n * audio level should be silent.\n *\n * @method Flash#muted\n * @return {boolean}\n *         - True if the audio should be set to silent\n *         - False otherwise\n */\n\n/**\n * Get the value of `defaultMuted` from the swf. `defaultMuted` indicates\n * whether the media should start muted or not. Only changes the default state of the\n * media. `muted` and `defaultMuted` can have different values. `muted` indicates the\n * current state.\n *\n * @method Flash#defaultMuted\n * @return {boolean}\n *         - The value of `defaultMuted` from the swf.\n *         - True indicates that the media should start muted.\n *         - False indicates that the media should not start muted.\n */\n\n/**\n * Get the value of `networkState` from the swf. `networkState` indicates\n * the current network state. It returns an enumeration from the following list:\n * - 0: NETWORK_EMPTY\n * - 1: NEWORK_IDLE\n * - 2: NETWORK_LOADING\n * - 3: NETWORK_NO_SOURCE\n *\n * @method Flash#networkState\n * @return {number}\n *         The value of `networkState` from the swf. This will be a number\n *         from the list in the description.\n */\n\n/**\n * Get the value of `readyState` from the swf. `readyState` indicates\n * the current state of the media element. It returns an enumeration from the\n * following list:\n * - 0: HAVE_NOTHING\n * - 1: HAVE_METADATA\n * - 2: HAVE_CURRENT_DATA\n * - 3: HAVE_FUTURE_DATA\n * - 4: HAVE_ENOUGH_DATA\n *\n * @method Flash#readyState\n * @return {number}\n *         The value of `readyState` from the swf. This will be a number\n *         from the list in the description.\n */\n\n/**\n * Get the value of `readyState` from the swf. `readyState` indicates\n * the current state of the media element. It returns an enumeration from the\n * following list:\n * - 0: HAVE_NOTHING\n * - 1: HAVE_METADATA\n * - 2: HAVE_CURRENT_DATA\n * - 3: HAVE_FUTURE_DATA\n * - 4: HAVE_ENOUGH_DATA\n *\n * @method Flash#readyState\n * @return {number}\n *         The value of `readyState` from the swf. This will be a number\n *         from the list in the description.\n */\n\n/**\n * Get the value of `initialTime` from the swf.\n *\n * @method Flash#initialTime\n * @return {number}\n *         The `initialTime` proprety on the swf.\n */\n\n/**\n * Get the value of `startOffsetTime` from the swf.\n *\n * @method Flash#startOffsetTime\n * @return {number}\n *         The `startOffsetTime` proprety on the swf.\n */\n\n/**\n * Get the value of `paused` from the swf. `paused` indicates whether the swf\n * is current paused or not.\n *\n * @method Flash#paused\n * @return {boolean}\n *         The value of `paused` from the swf.\n */\n\n/**\n * Get the value of `ended` from the swf. `ended` indicates whether\n * the media has reached the end or not.\n *\n * @method Flash#ended\n * @return {boolean}\n *         - True indicates that the media has ended.\n *         - False indicates that the media has not ended.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}\n */\n\n/**\n * Get the value of `videoWidth` from the swf. `videoWidth` indicates\n * the current width of the media in css pixels.\n *\n * @method Flash#videoWidth\n * @return {number}\n *         The value of `videoWidth` from the swf. This will be a number\n *         in css pixels.\n */\n\n/**\n * Get the value of `videoHeight` from the swf. `videoHeigth` indicates\n * the current height of the media in css pixels.\n *\n * @method Flassh.prototype.videoHeight\n * @return {number}\n *         The value of `videoHeight` from the swf. This will be a number\n *         in css pixels.\n */\n/** ------------------------------ Setters ------------------------------ **/\n\n/**\n * Set the value of `rtmpConnection` on the swf.\n *\n * @method Flash#setRtmpConnection\n * @param {string} rtmpConnection\n *        New value to set the `rtmpConnection` property to.\n */\n\n/**\n * Set the value of `rtmpStream` on the swf.\n *\n * @method Flash#setRtmpStream\n * @param {string} rtmpStream\n *        New value to set the `rtmpStream` property to.\n */\n\n/**\n * Set the value of `preload` on the swf. `preload` indicates\n * what should download before the media is interacted with. It can have the following\n * values:\n * - none: nothing should be downloaded\n * - metadata: poster and the first few frames of the media may be downloaded to get\n *   media dimensions and other metadata\n * - auto: allow the media and metadata for the media to be downloaded before\n *    interaction\n *\n * @method Flash#setPreload\n * @param {string} preload\n *        The value of `preload` to set on the swf. Should be 'none', 'metadata',\n *        or 'auto'.\n */\n\n/**\n * Set the value of `defaultPlaybackRate` on the swf.\n *\n * @method Flash#setDefaultPlaybackRate\n * @param {number} defaultPlaybackRate\n *        New value to set the `defaultPlaybackRate` property to.\n */\n\n/**\n * Set the value of `playbackRate` on the swf. `playbackRate` indicates\n * the rate at which the media is currently playing back. Examples:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Flash#setPlaybackRate\n * @param {number} playbackRate\n *        New value of `playbackRate` on the swf. A number indicating\n *        the current playback speed of the media, where 1 is normal speed.\n */\n\n/**\n * Set the value of `autoplay` on the swf. `autoplay` indicates\n * that the media should start to play as soon as the page is ready.\n *\n * @method Flash#setAutoplay\n * @param {boolean} autoplay\n *        - The value of `autoplay` from the swf.\n *        - True indicates that the media ashould start as soon as the page loads.\n *        - False indicates that the media should not start as soon as the page loads.\n */\n\n/**\n * Set the value of `loop` on the swf. `loop` indicates\n * that the media should return to the start of the media and continue playing once\n * it reaches the end.\n *\n * @method Flash#setLoop\n * @param {boolean} loop\n *        - True indicates that playback should seek back to start once\n *          the end of a media is reached.\n *        - False indicates that playback should not loop back to the start when the\n *          end of the media is reached.\n */\n\n/**\n * Set the value of `mediaGroup` on the swf.\n *\n * @method Flash#setMediaGroup\n * @param {string} mediaGroup\n *        New value of `mediaGroup` to set on the swf.\n */\n\n/**\n * Set the value of `controller` on the swf.\n *\n * @method Flash#setController\n * @param {string} controller\n *        New value the current value of `controller` on the swf.\n */\n\n/**\n * Get the value of `controls` from the swf. `controls` indicates\n * whether the native flash controls should be shown or hidden.\n *\n * @method Flash#controls\n * @return {boolean}\n *         - The value of `controls` from the swf.\n *         - True indicates that native controls should be showing.\n *         - False indicates that native controls should be hidden.\n */\n\n/**\n * Set the value of the `volume` on the swf. `volume` indicates the current\n * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and\n * so on.\n *\n * @method Flash#setVolume\n * @param {number} percentAsDecimal\n *         The volume percent as a decimal. Value will be between 0-1.\n */\n\n/**\n * Set the value of the `muted` on the swf. `muted` indicates that the current\n * audio level should be silent.\n *\n * @method Flash#setMuted\n * @param {boolean} muted\n *         - True if the audio should be set to silent\n *         - False otherwise\n */\n\n/**\n * Set the value of `defaultMuted` on the swf. `defaultMuted` indicates\n * whether the media should start muted or not. Only changes the default state of the\n * media. `muted` and `defaultMuted` can have different values. `muted` indicates the\n * current state.\n *\n * @method Flash#setDefaultMuted\n * @param {boolean} defaultMuted\n *         - True indicates that the media should start muted.\n *         - False indicates that the media should not start muted.\n */\n\n/* Flash Support Testing -------------------------------------------------------- */\n\n/**\n * Check if the Flash tech is currently supported.\n *\n * @return {boolean}\n *          - True for Chrome and Safari Desktop and Microsoft Edge and if flash tech is supported\n *          - False otherwise\n */\nFlash.isSupported = function () {\n  // for Chrome Desktop and Safari Desktop\n  if (videojs.browser.IS_CHROME && (!videojs.browser.IS_ANDROID || !videojs.browser.IS_IOS) || videojs.browser.IS_SAFARI && !videojs.browser.IS_IOS || videojs.browser.IS_EDGE) {\n    return true;\n  }\n  // for other browsers\n  return Flash.version()[0] >= 10;\n};\n\n// Add Source Handler pattern functions to this tech\nTech.withSourceHandlers(Flash);\n\n/*\n * Native source handler for flash,  simply passes the source to the swf element.\n *\n * @property {Tech~SourceObject} source\n *           The source object\n *\n * @property {Flash} tech\n *           The instance of the Flash tech\n */\nFlash.nativeSourceHandler = {};\n\n/**\n * Check if the Flash can play the given mime type.\n *\n * @param {string} type\n *        The mimetype to check\n *\n * @return {string}\n *         'maybe', or '' (empty string)\n */\nFlash.nativeSourceHandler.canPlayType = function (type) {\n  if (type in Flash.formats) {\n    return 'maybe';\n  }\n\n  return '';\n};\n\n/**\n * Check if the media element can handle a source natively.\n *\n * @param {Tech~SourceObject} source\n *         The source object\n *\n * @param {Object} [options]\n *         Options to be passed to the tech.\n *\n * @return {string}\n *         'maybe', or '' (empty string).\n */\nFlash.nativeSourceHandler.canHandleSource = function (source, options) {\n  var type = void 0;\n\n  /**\n   * Guess the mime type of a file if it does not have one\n   *\n   * @param {Tech~SourceObject} src\n   *        The source object to guess the mime type for\n   *\n   * @return {string}\n   *         The mime type that was guessed\n   */\n  function guessMimeType(src) {\n    var ext = Url.getFileExtension(src);\n\n    if (ext) {\n      return 'video/' + ext;\n    }\n    return '';\n  }\n\n  if (!source.type) {\n    type = guessMimeType(source.src);\n  } else {\n    // Strip code information from the type because we don't get that specific\n    type = source.type.replace(/;.*/, '').toLowerCase();\n  }\n\n  return Flash.nativeSourceHandler.canPlayType(type);\n};\n\n/**\n * Pass the source to the swf.\n *\n * @param {Tech~SourceObject} source\n *        The source object\n *\n * @param {Flash} tech\n *        The instance of the Flash tech\n *\n * @param {Object} [options]\n *        The options to pass to the source\n */\nFlash.nativeSourceHandler.handleSource = function (source, tech, options) {\n  tech.setSrc(source.src);\n};\n\n/**\n * noop for native source handler dispose, as cleanup will happen automatically.\n */\nFlash.nativeSourceHandler.dispose = function () {};\n\n// Register the native source handler\nFlash.registerSourceHandler(Flash.nativeSourceHandler);\n\n/**\n * Flash supported mime types.\n *\n * @constant {Object}\n */\nFlash.formats = {\n  'video/flv': 'FLV',\n  'video/x-flv': 'FLV',\n  'video/mp4': 'MP4',\n  'video/m4v': 'MP4'\n};\n\n/**\n * Called when the the swf is \"ready\", and makes sure that the swf is really\n * ready using {@link Flash#checkReady}\n *\n * @param {Object} currSwf\n *        The current swf object\n */\nFlash.onReady = function (currSwf) {\n  var el = Dom.$('#' + currSwf);\n  var tech = el && el.tech;\n\n  // if there is no el then the tech has been disposed\n  // and the tech element was removed from the player div\n  if (tech && tech.el()) {\n    // check that the flash object is really ready\n    Flash.checkReady(tech);\n  }\n};\n\n/**\n * The SWF isn't always ready when it says it is. Sometimes the API functions still\n * need to be added to the object. If it's not ready, we set a timeout to check again\n * shortly.\n *\n * @param {Flash} tech\n *        The instance of the flash tech to check.\n */\nFlash.checkReady = function (tech) {\n  // stop worrying if the tech has been disposed\n  if (!tech.el()) {\n    return;\n  }\n\n  // check if API property exists\n  if (tech.el().vjs_getProperty) {\n    // tell tech it's ready\n    tech.triggerReady();\n  } else {\n    // wait longer\n    this.setTimeout(function () {\n      Flash.checkReady(tech);\n    }, 50);\n  }\n};\n\n/**\n * Trigger events from the swf on the Flash Tech.\n *\n * @param {number} swfID\n *        The id of the swf that had the event\n *\n * @param {string} eventName\n *        The name of the event to trigger\n */\nFlash.onEvent = function (swfID, eventName) {\n  var tech = Dom.$('#' + swfID).tech;\n  var args = Array.prototype.slice.call(arguments, 2);\n\n  // dispatch Flash events asynchronously for two reasons:\n  // - Flash swallows any exceptions generated by javascript it\n  //   invokes\n  // - Flash is suspended until the javascript returns which may cause\n  //   playback performance issues\n  tech.setTimeout(function () {\n    tech.trigger(eventName, args);\n  }, 1);\n};\n\n/**\n * Log errors from the swf on the Flash tech.\n *\n * @param {number} swfID\n *        The id of the swf that had an error.\n *\n * @param {string} err\n *        The error to set on the Flash Tech.\n *\n * @return {MediaError|undefined}\n *          - Returns a MediaError when err is 'srcnotfound'\n *          - Returns undefined otherwise.\n */\nFlash.onError = function (swfID, err) {\n  var tech = Dom.$('#' + swfID).tech;\n\n  // trigger MEDIA_ERR_SRC_NOT_SUPPORTED\n  if (err === 'srcnotfound') {\n    return tech.error(4);\n  }\n\n  // trigger a custom error\n  if (typeof err === 'string') {\n    tech.error('FLASH: ' + err);\n  } else {\n    err.origin = 'flash';\n    tech.error(err);\n  }\n};\n\n/**\n * Get the current version of Flash that is in use on the page.\n *\n * @return {Array}\n *          an array of versions that are available.\n */\nFlash.version = function () {\n  var version$$1 = '0,0,0';\n\n  // IE\n  try {\n    version$$1 = new window.ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\\D+/g, ',').match(/^,?(.+),?$/)[1];\n\n    // other browsers\n  } catch (e) {\n    try {\n      if (navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin) {\n        version$$1 = (navigator.plugins['Shockwave Flash 2.0'] || navigator.plugins['Shockwave Flash']).description.replace(/\\D+/g, ',').match(/^,?(.+),?$/)[1];\n      }\n    } catch (err) {\n      // satisfy linter\n    }\n  }\n  return version$$1.split(',');\n};\n\n/**\n * Only use for non-iframe embeds.\n *\n * @param {Object} swf\n *        The videojs-swf object.\n *\n * @param {Object} flashVars\n *        Names and values to use as flash option variables.\n *\n * @param {Object} params\n *        Style parameters to set on the object.\n *\n * @param {Object} attributes\n *        Attributes to set on the element.\n *\n * @return {Element}\n *          The embeded Flash DOM element.\n */\nFlash.embed = function (swf, flashVars, params, attributes) {\n  var code = Flash.getEmbedCode(swf, flashVars, params, attributes);\n\n  // Get element by embedding code and retrieving created element\n  var obj = Dom.createEl('div', { innerHTML: code }).childNodes[0];\n\n  return obj;\n};\n\n/**\n * Only use for non-iframe embeds.\n *\n * @param {Object} swf\n *        The videojs-swf object.\n *\n * @param {Object} flashVars\n *        Names and values to use as flash option variables.\n *\n * @param {Object} params\n *        Style parameters to set on the object.\n *\n * @param {Object} attributes\n *        Attributes to set on the element.\n *\n * @return {Element}\n *          The embeded Flash DOM element.\n */\nFlash.getEmbedCode = function (swf, flashVars, params, attributes) {\n  var objTag = '<object type=\"application/x-shockwave-flash\" ';\n  var flashVarsString = '';\n  var paramsString = '';\n  var attrsString = '';\n\n  // Convert flash vars to string\n  if (flashVars) {\n    Object.getOwnPropertyNames(flashVars).forEach(function (key) {\n      flashVarsString += key + '=' + flashVars[key] + '&amp;';\n    });\n  }\n\n  // Add swf, flashVars, and other default params\n  params = mergeOptions({\n    movie: swf,\n    flashvars: flashVarsString,\n    // Required to talk to swf\n    allowScriptAccess: 'always',\n    // All should be default, but having security issues.\n    allowNetworking: 'all'\n  }, params);\n\n  // Create param tags string\n  Object.getOwnPropertyNames(params).forEach(function (key) {\n    paramsString += '<param name=\"' + key + '\" value=\"' + params[key] + '\" />';\n  });\n\n  attributes = mergeOptions({\n    // Add swf to attributes (need both for IE and Others to work)\n    data: swf,\n\n    // Default to 100% width/height\n    width: '100%',\n    height: '100%'\n\n  }, attributes);\n\n  // Create Attributes string\n  Object.getOwnPropertyNames(attributes).forEach(function (key) {\n    attrsString += key + '=\"' + attributes[key] + '\" ';\n  });\n\n  return '' + objTag + attrsString + '>' + paramsString + '</object>';\n};\n\n// Run Flash through the RTMP decorator\nFlashRtmpDecorator(Flash);\n\nif (Tech.getTech('Flash')) {\n  videojs.log.warn('Not using videojs-flash as it appears to already be registered');\n  videojs.log.warn('videojs-flash should only be used with video.js@6 and above');\n} else {\n  videojs.registerTech('Flash', Flash);\n}\n\nFlash.VERSION = version$1;\n\nexport default Flash;\n"],"mappings":"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A;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACArJ,KAAK,CAACsJ,WAAW,GAAG,YAAY;EAC9B;EACA,IAAI3J,OAAO,CAAC4J,OAAO,CAACC,SAAS,KAAK,CAAC7J,OAAO,CAAC4J,OAAO,CAACE,UAAU,IAAI,CAAC9J,OAAO,CAAC4J,OAAO,CAACG,MAAM,CAAC,IAAI/J,OAAO,CAAC4J,OAAO,CAACI,SAAS,IAAI,CAAChK,OAAO,CAAC4J,OAAO,CAACG,MAAM,IAAI/J,OAAO,CAAC4J,OAAO,CAACK,OAAO,EAAE;IAC5K,OAAO,IAAI;EACb;EACA;EACA,OAAO5J,KAAK,CAACJ,OAAO,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE;AACjC,CAAC;;AAED;AACAyD,IAAI,CAACwG,kBAAkB,CAAC7J,KAAK,CAAC;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,KAAK,CAAC8J,mBAAmB,GAAG,CAAC,CAAC;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA9J,KAAK,CAAC8J,mBAAmB,CAAC1I,WAAW,GAAG,UAAUC,IAAI,EAAE;EACtD,IAAIA,IAAI,IAAIrB,KAAK,CAAC+J,OAAO,EAAE;IACzB,OAAO,OAAO;EAChB;EAEA,OAAO,EAAE;AACX,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA/J,KAAK,CAAC8J,mBAAmB,CAACxI,eAAe,GAAG,UAAUC,MAAM,EAAEC,OAAO,EAAE;EACrE,IAAIH,IAAI,GAAG,KAAK,CAAC;;EAEjB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAAS2I,aAAa,CAAC1J,GAAG,EAAE;IAC1B,IAAI2J,GAAG,GAAGxG,GAAG,CAACyG,gBAAgB,CAAC5J,GAAG,CAAC;IAEnC,IAAI2J,GAAG,EAAE;MACP,OAAO,QAAQ,GAAGA,GAAG;IACvB;IACA,OAAO,EAAE;EACX;EAEA,IAAI,CAAC1I,MAAM,CAACF,IAAI,EAAE;IAChBA,IAAI,GAAG2I,aAAa,CAACzI,MAAM,CAACjB,GAAG,CAAC;EAClC,CAAC,MAAM;IACL;IACAe,IAAI,GAAGE,MAAM,CAACF,IAAI,CAAC8I,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAACC,WAAW,EAAE;EACrD;EAEA,OAAOpK,KAAK,CAAC8J,mBAAmB,CAAC1I,WAAW,CAACC,IAAI,CAAC;AACpD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACArB,KAAK,CAAC8J,mBAAmB,CAACpI,YAAY,GAAG,UAAUH,MAAM,EAAEI,IAAI,EAAEH,OAAO,EAAE;EACxEG,IAAI,CAAC6E,MAAM,CAACjF,MAAM,CAACjB,GAAG,CAAC;AACzB,CAAC;;AAED;AACA;AACA;AACAN,KAAK,CAAC8J,mBAAmB,CAACO,OAAO,GAAG,YAAY,CAAC,CAAC;;AAElD;AACArK,KAAK,CAAC+B,qBAAqB,CAAC/B,KAAK,CAAC8J,mBAAmB,CAAC;;AAEtD;AACA;AACA;AACA;AACA;AACA9J,KAAK,CAAC+J,OAAO,GAAG;EACd,WAAW,EAAE,KAAK;EAClB,aAAa,EAAE,KAAK;EACpB,WAAW,EAAE,KAAK;EAClB,WAAW,EAAE;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA/J,KAAK,CAACsE,OAAO,GAAG,UAAUgG,OAAO,EAAE;EACjC,IAAIC,EAAE,GAAGhH,GAAG,CAACiH,CAAC,CAAC,GAAG,GAAGF,OAAO,CAAC;EAC7B,IAAI3I,IAAI,GAAG4I,EAAE,IAAIA,EAAE,CAAC5I,IAAI;;EAExB;EACA;EACA,IAAIA,IAAI,IAAIA,IAAI,CAAC4I,EAAE,EAAE,EAAE;IACrB;IACAvK,KAAK,CAACyK,UAAU,CAAC9I,IAAI,CAAC;EACxB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA3B,KAAK,CAACyK,UAAU,GAAG,UAAU9I,IAAI,EAAE;EACjC;EACA,IAAI,CAACA,IAAI,CAAC4I,EAAE,EAAE,EAAE;IACd;EACF;;EAEA;EACA,IAAI5I,IAAI,CAAC4I,EAAE,EAAE,CAACnD,eAAe,EAAE;IAC7B;IACAzF,IAAI,CAAC+I,YAAY,EAAE;EACrB,CAAC,MAAM;IACL;IACA,IAAI,CAAC9D,UAAU,CAAC,YAAY;MAC1B5G,KAAK,CAACyK,UAAU,CAAC9I,IAAI,CAAC;IACxB,CAAC,EAAE,EAAE,CAAC;EACR;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA3B,KAAK,CAACuE,OAAO,GAAG,UAAUoG,KAAK,EAAEC,SAAS,EAAE;EAC1C,IAAIjJ,IAAI,GAAG4B,GAAG,CAACiH,CAAC,CAAC,GAAG,GAAGG,KAAK,CAAC,CAAChJ,IAAI;EAClC,IAAIkJ,IAAI,GAAGC,KAAK,CAACvI,SAAS,CAAC0G,KAAK,CAAC9F,IAAI,CAAC4H,SAAS,EAAE,CAAC,CAAC;;EAEnD;EACA;EACA;EACA;EACA;EACApJ,IAAI,CAACiF,UAAU,CAAC,YAAY;IAC1BjF,IAAI,CAACuF,OAAO,CAAC0D,SAAS,EAAEC,IAAI,CAAC;EAC/B,CAAC,EAAE,CAAC,CAAC;AACP,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA7K,KAAK,CAACwE,OAAO,GAAG,UAAUmG,KAAK,EAAEK,GAAG,EAAE;EACpC,IAAIrJ,IAAI,GAAG4B,GAAG,CAACiH,CAAC,CAAC,GAAG,GAAGG,KAAK,CAAC,CAAChJ,IAAI;;EAElC;EACA,IAAIqJ,GAAG,KAAK,aAAa,EAAE;IACzB,OAAOrJ,IAAI,CAACsJ,KAAK,CAAC,CAAC,CAAC;EACtB;;EAEA;EACA,IAAI,OAAOD,GAAG,KAAK,QAAQ,EAAE;IAC3BrJ,IAAI,CAACsJ,KAAK,CAAC,SAAS,GAAGD,GAAG,CAAC;EAC7B,CAAC,MAAM;IACLA,GAAG,CAACE,MAAM,GAAG,OAAO;IACpBvJ,IAAI,CAACsJ,KAAK,CAACD,GAAG,CAAC;EACjB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAhL,KAAK,CAACJ,OAAO,GAAG,YAAY;EAC1B,IAAIuL,UAAU,GAAG,OAAO;;EAExB;EACA,IAAI;IACFA,UAAU,GAAG,IAAItL,MAAM,CAACuL,aAAa,CAAC,+BAA+B,CAAC,CAACC,WAAW,CAAC,UAAU,CAAC,CAAClB,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CAACmB,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;;IAE1I;EACF,CAAC,CAAC,OAAOC,CAAC,EAAE;IACV,IAAI;MACF,IAAI1H,SAAS,CAAC2H,SAAS,CAAC,+BAA+B,CAAC,CAACC,aAAa,EAAE;QACtEN,UAAU,GAAG,CAACtH,SAAS,CAAC6H,OAAO,CAAC,qBAAqB,CAAC,IAAI7H,SAAS,CAAC6H,OAAO,CAAC,iBAAiB,CAAC,EAAEC,WAAW,CAACxB,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CAACmB,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;MACzJ;IACF,CAAC,CAAC,OAAON,GAAG,EAAE;MACZ;IAAA;EAEJ;EACA,OAAOG,UAAU,CAACS,KAAK,CAAC,GAAG,CAAC;AAC9B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA5L,KAAK,CAACgG,KAAK,GAAG,UAAUlB,GAAG,EAAEG,SAAS,EAAEQ,MAAM,EAAEG,UAAU,EAAE;EAC1D,IAAIiG,IAAI,GAAG7L,KAAK,CAAC8L,YAAY,CAAChH,GAAG,EAAEG,SAAS,EAAEQ,MAAM,EAAEG,UAAU,CAAC;;EAEjE;EACA,IAAImG,GAAG,GAAGxI,GAAG,CAACqB,QAAQ,CAAC,KAAK,EAAE;IAAEoH,SAAS,EAAEH;EAAK,CAAC,CAAC,CAACI,UAAU,CAAC,CAAC,CAAC;EAEhE,OAAOF,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA/L,KAAK,CAAC8L,YAAY,GAAG,UAAUhH,GAAG,EAAEG,SAAS,EAAEQ,MAAM,EAAEG,UAAU,EAAE;EACjE,IAAIsG,MAAM,GAAG,+CAA+C;EAC5D,IAAIC,eAAe,GAAG,EAAE;EACxB,IAAIC,YAAY,GAAG,EAAE;EACrB,IAAIC,WAAW,GAAG,EAAE;;EAEpB;EACA,IAAIpH,SAAS,EAAE;IACbzC,MAAM,CAAC8J,mBAAmB,CAACrH,SAAS,CAAC,CAACsH,OAAO,CAAC,UAAUC,GAAG,EAAE;MAC3DL,eAAe,IAAIK,GAAG,GAAG,GAAG,GAAGvH,SAAS,CAACuH,GAAG,CAAC,GAAG,OAAO;IACzD,CAAC,CAAC;EACJ;;EAEA;EACA/G,MAAM,GAAG7B,YAAY,CAAC;IACpB6I,KAAK,EAAE3H,GAAG;IACV4H,SAAS,EAAEP,eAAe;IAC1B;IACAQ,iBAAiB,EAAE,QAAQ;IAC3B;IACAC,eAAe,EAAE;EACnB,CAAC,EAAEnH,MAAM,CAAC;;EAEV;EACAjD,MAAM,CAAC8J,mBAAmB,CAAC7G,MAAM,CAAC,CAAC8G,OAAO,CAAC,UAAUC,GAAG,EAAE;IACxDJ,YAAY,IAAI,eAAe,GAAGI,GAAG,GAAG,WAAW,GAAG/G,MAAM,CAAC+G,GAAG,CAAC,GAAG,MAAM;EAC5E,CAAC,CAAC;EAEF5G,UAAU,GAAGhC,YAAY,CAAC;IACxB;IACAiJ,IAAI,EAAE/H,GAAG;IAET;IACAgI,KAAK,EAAE,MAAM;IACbC,MAAM,EAAE;EAEV,CAAC,EAAEnH,UAAU,CAAC;;EAEd;EACApD,MAAM,CAAC8J,mBAAmB,CAAC1G,UAAU,CAAC,CAAC2G,OAAO,CAAC,UAAUC,GAAG,EAAE;IAC5DH,WAAW,IAAIG,GAAG,GAAG,IAAI,GAAG5G,UAAU,CAAC4G,GAAG,CAAC,GAAG,IAAI;EACpD,CAAC,CAAC;EAEF,OAAO,EAAE,GAAGN,MAAM,GAAGG,WAAW,GAAG,GAAG,GAAGD,YAAY,GAAG,WAAW;AACrE,CAAC;;AAED;AACArM,kBAAkB,CAACC,KAAK,CAAC;AAEzB,IAAIqD,IAAI,CAAC2J,OAAO,CAAC,OAAO,CAAC,EAAE;EACzBrN,OAAO,CAACsN,GAAG,CAACC,IAAI,CAAC,gEAAgE,CAAC;EAClFvN,OAAO,CAACsN,GAAG,CAACC,IAAI,CAAC,6DAA6D,CAAC;AACjF,CAAC,MAAM;EACLvN,OAAO,CAACwN,YAAY,CAAC,OAAO,EAAEnN,KAAK,CAAC;AACtC;AAEAA,KAAK,CAACoN,OAAO,GAAGtN,SAAS;AAEzB,eAAeE,KAAK"},"metadata":{},"sourceType":"module","externalDependencies":[]}